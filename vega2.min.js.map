{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index","vega2.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/bin.js","node_modules/datalib/src/date-units.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/histogram.js","node_modules/datalib/src/import/formats/csv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/formats/tsv.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/loaders.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/index.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/summary.js","node_modules/datalib/src/template.js","node_modules/datalib/src/util.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","src/core/Bounds.js","src/core/HeadlessView.js","src/core/Model.js","src/core/View.js","src/dataflow/Collector.js","src/dataflow/Datasource.js","src/dataflow/Graph.js","src/dataflow/Node.js","src/dataflow/Signal.js","src/dataflow/changeset.js","src/dataflow/tuple.js","src/expression/codegen.js","src/expression/constants.js","src/expression/functions.js","src/expression/index.js","src/expression/parser.js","src/parse/axes.js","src/parse/data.js","src/parse/events.js","src/parse/expr.js","src/parse/interactors.js","src/parse/mark.js","src/parse/marks.js","src/parse/modify.js","src/parse/padding.js","src/parse/predicates.js","src/parse/properties.js","src/parse/signals.js","src/parse/spec.js","src/parse/streams.js","src/parse/transforms.js","src/render/canvas/Handler.js","src/render/canvas/Renderer.js","src/render/canvas/index.js","src/render/canvas/marks.js","src/render/canvas/path.js","src/render/svg-headless/Renderer.js","src/render/svg-headless/index.js","src/render/svg-headless/svg.js","src/render/svg/Handler.js","src/render/svg/Renderer.js","src/render/svg/marks.js","src/scene/Bounder.js","src/scene/Builder.js","src/scene/Encoder.js","src/scene/GroupBuilder.js","src/scene/Item.js","src/scene/Scale.js","src/scene/Transition.js","src/scene/axis.js","src/transforms/Aggregate.js","src/transforms/BatchTransform.js","src/transforms/Bin.js","src/transforms/Cross.js","src/transforms/Facet.js","src/transforms/Filter.js","src/transforms/Fold.js","src/transforms/Force.js","src/transforms/Formula.js","src/transforms/Geo.js","src/transforms/GeoPath.js","src/transforms/GroupBy.js","src/transforms/LinkPath.js","src/transforms/Parameter.js","src/transforms/Pie.js","src/transforms/Sort.js","src/transforms/Stack.js","src/transforms/Transform.js","src/transforms/Treemap.js","src/transforms/Unique.js","src/transforms/Zip.js","src/transforms/index.js","src/transforms/measures.js","src/util/bounds.js","src/util/config.js","src/util/constants.js","src/util/debug.js","src/util/quickselect.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vg","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"core","View","dataflow","changeset","Datasource","Graph","Node","parse","spec","scene","Builder","GroupBuilder","transforms","config","util","./src/core/View","./src/dataflow/Datasource","./src/dataflow/Graph","./src/dataflow/Node","./src/dataflow/changeset","./src/parse/spec","./src/scene/Builder","./src/scene/GroupBuilder","./src/transforms/index","./src/util/config","datalib",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"bin","opt","step","logb","level","minstep","precision","v","eps","maxb","maxbins","base","Math","log","div","min","max","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","value","index","x","lo","hi","mid","cmp","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","bins","raw","./date-units","./util",5,"STEPS","entries","type","format","d","Date","UTC","isNumber","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",6,"gen","repeat","val","Array","zeros","range","arguments","Infinity","j","random","uniform","undefined","samples","map","integer","b","normal","mean","stdev","next","rds","c","y","sqrt",7,"infer","values","types","isString","isNotNull","isDate","numerical","h","count","isFinite","categorical","sort","stats","unique","counts","keys","k","comparator","options","isFunction","ext","extent","extend","./bin","./generate","./stats",8,"d3","data","csv","toString",9,"json","tsv","topojson","treejson","./csv","./json","./topojson","./treejson","./tsv",10,"isObject","isBuffer","JSON","property","accessor","../../util",11,"obj","feature","objects","features","mesh",12,"toTable","root","childrenField","visit","node","parent","table","children",13,14,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","test","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","idx","lastIndexOf","load","callback","error","err","slice","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","fs","readFile","readFileSync","body","statusCode","getBody","../util","sync-request",15,"read","formats","reduce","out","./load","./read",16,"infer_type","TESTS","splice","infer_types","fields","PARSERS","cols","parsers","clen","duplicate","boolean","number","string","identity","isBoolean","isNaN","./formats",17,"dl","histogram","summary","template","dateunits","./histogram","./import/load","./import/loaders","./import/read","./summary","./template",18,"results","isArray","distinct","nulls","median","filter","half","quantile","p","H","delta","variance","M2","modeskew","avg","med","std","dot","sum","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","abs","m","R","M","entropy","N","LN2","normalized","mutual","z","px","py","I","profile","sd","vals","iqr",19,"printSummary","profiles","str","forEach","field","printCategoricalProfile","printQuantitativeProfile","join","list","top","concat",20,"text","src","source","Function","bind","context","variable","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","stringCast","filters","split","prop","shift","trim","pidx","args","indexOf","template_format","time","template_escapes","pattern","fmt","format_map","truncate","clearFormatCache","'","\\","\r","\n"," "," ",21,"util_escape_str","escape_str_re","truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","Buffer","stderr","Object","prototype","parseFloat","array","stringify","equal","toMap","keystr","apply","mutator","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","String","searchString","pos","word","ellipsis","l1","l2","_process","buffer",22,"./lib/heap",23,"Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","item","lastelt","returnitem","pop","_ref","_i","_len","_ref1","_results","_results1","_j","elem","result","los","startpos","newitem","parentpos","childpos","endpos","rightpos","nodes","pushpop","peek","contains","clear","empty","size","clone","heap","toArray","insert","front","has","copy","factory",24,"bounds","union","x1","Number","MAX_VALUE","y1","x2","y2","set","add","expand","translate","dx","dy","rotate","angle","cos","sin","cx","cy","encloses","intersects","width","height",25,"canvas","svg","HeadlessView","model","_el","_type","_renderers","_canvas","renderer","canvasAsync","wait","pendingImages","view","render","_renderer","initialize","_width","_height","pad","_padding","_viewport","left","right","bottom","_io","Renderer","initSVG","initCanvas","Canvas","tw","th","ctx","getContext","setAttribute","setTransform","resize","../render/canvas/index","../render/svg-headless/index","../util/debug","./View",26,"Model","_defs","_predicates","_scene","_node","_builder","init","predicates","proto","defs","pipeline","predicate","disconnect","marks","connect","fire","cs","create","propagate","../dataflow/Graph","../dataflow/Node","../dataflow/changeset","../scene/GroupBuilder",27,"parseStreams","Transition","debug","el","_model","__width","__height","_autopad","_handler","_strict","padding","autopad","inset","autopadInset","update","viewport","_build","prevHandler","parentNode","select","remove","append","attr","style","Handler","handlers","handler","trans","duration","ease","reflow","_renderNode","router","evaluate","input","items","ds","revises","finalize","last","../parse/streams","../render/svg/index","../scene/Transition","../util/config","./HeadlessView",28,"Collector","graph","_data","collector","mod","rem","ids","_id","../util/constants","./Node","./changeset",29,"facet","_graph","_name","_source","_facet","_input","_output","_pipeline","_collector","_revises","set_prev","_prev","C","SENTINEL","tuple","prev","ingest","where","func","idMap","unshift","output","listener","dest","_srcMap","derive","listeners","./Collector","./tuple",30,"signal","_signals","forEachNode","branch","Signal","_stamp","_rank","doNotPropagate","db","signalValues","sg","signalRef","ref","schedule","pulse","reflowed","pq","stamp","_listeners","dependency","DATA","signals","SIGNALS","reevaluate","run","./Datasource","./Signal",31,"REEVAL","FIELDS","SCALES","node_id","_registered","_deps","scales","_isRouter","_isCollector","deps","bool","q","cur","foundSending","reeval",32,"_value",33,"reset_prev",34,"datum","tuple_id","reset",35,"codegen_wrap","ast","retval","codegen","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","DATUM","SIGNAL_PREFIX","Literal","Identifier","id","hasOwnProperty","Program","MemberExpression","computed","object","CallExpression","callee","ArrayExpression","elements","BinaryExpression","operator","UnaryExpression","argument","UpdateExpression","prefix","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","Property","key","ExpressionStatement","expression","./constants","./functions",36,"E","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2",37,"fncall","cast","DATE","STRING","REGEXP","acos","asin","atan","atan2","tan","now","datetime","hours","minutes","seconds","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseInt","upper","lower","substring","if",38,"parser","./codegen","./parser",39,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","charCodeAt","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","token","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","EOF","collectToken","entry","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","msg","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","expr","state","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",40,"axes","group","def","axs","axis","scale","orient","ORIENT","layer","grid","titleOffset","tickValues","tickFormat","tickSubdivide","subdivide","tickPadding","tickSize","ts","tickSizeMajor","tickSizeMinor","tickSizeEnd","ticks","majorTickProperties","majorTicks","minorTickProperties","minorTicks","tickLabelProperties","labels","titleProperties","gridLineProperties","domainProperties","../scene/axis",41,"parseTransforms","parseModify","parseData","loaded","datasource","transform","modify","./modify","./transforms",42,"peg$subclass","child","ctor","constructor","SyntaxError","expected","peg$computePosDetails","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","buildMessage","stringEscape","hex","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","peg$parsemerged","s1","s2","s3","s4","s5","peg$parseordered","peg$FAILED","peg$parsesep","peg$c1","peg$silentFails","peg$c2","peg$reportedPos","peg$c3","peg$c0","peg$c4","s6","s7","s8","s9","s10","s11","s12","s13","peg$c5","peg$c6","peg$parsefiltered","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$parsestream","peg$parsefilter","peg$c13","peg$c14","peg$parseclass","peg$parseid","peg$c15","peg$parseeventType","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$parsevalue","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$result","peg$startRuleFunctions","peg$startRuleFunction","f1","f2","middle","event","target","stream","startRule",43,"eval","../expression",44,"defFactory","interactor","inject","pd","nsSignals","nsPredicates","nsMarks","mk","injectMarks","from","ENTER","UPDATE","EXIT","ns","streams","operands","nsOperand","nsProperties","enter","exit","propset","rule","interactors",45,"parseProperties","parseMark","mark","props","delay","./properties",46,"./mark",47,"signalName","ADD","REMOVE","TOGGLE","CLEAR","../dataflow/tuple",48,49,"parseSignal","parseOperands","decl","arg","pred","parseComparator","ops","parseLogical","parseIn","parseScale","scope","invert","=","==","!=",">",">=","<","<=","and","&&","or","||","in",50,"compile","names","vars","valueRef","DEPS","hasPath","encoder","tpl","encode","path","tension","rules","inputs","predName","colorRef","sgRef","fRef","sRef","fieldRef","scaleRef","band","mult","xx","color","yy","zz","nested","fr",51,"dep","./expr",52,"parsePadding","parseMarks","parseSignals","parsePredicates","parseInteractors","viewFactory","../core/Model","../core/View","../parse/data","../parse/interactors","../parse/marks","../parse/padding","../parse/predicates","../parse/signals",53,"changset","selector","START","MIDDLE","END","sig","register","orderedStream","trueFn","sp","mergedStream","sel","evt","filtered","preventDefault","mouse","./events",54,"tx","../transforms/index",55,"eventName","_active","_handlers","_obj","that","events","addEventListener","touchmove","mousemove","getBoundingClientRect","clientX","clientY","pick","touchend","mouseout","DOMMouseScroll","gx","gy","marktype","picker","./marks",56,"scaleCanvas","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","initializeLineDash","vgLineDash","NODASH","setLineDash","dash","vgLineDashOffset","lineDashOffset","webkitLineDash","webkitLineDashOffset","mozDash","translatedBounds","Bounds","getBounds","setBounds","bbox","beginPath","rect","clip","_ctx","_imgload","selectAll","_ratio","element","bb2","save","clearRect","draw","renderAsync","_async_id","clearTimeout","loadImage","uri","image","Image","../../core/Bounds","../../util/config",57,"./Handler","./Renderer",58,"fontString","fontStyle","fontVariant","fontWeight","fontSize","font","arcPath","ir","innerRadius","outerRadius","startAngle","ea","endAngle","moveTo","arc","closePath","areaPath","pathCache","parsePath","area","renderPath","linePath","pathPath","symbolPath","rx","ry","shape","lineTo","tan30","sqrt3","lineStroke","lw","strokeWidth","lc","strokeCap","lineWidth","lineCap","ruleStroke","drawPathOne","opac","fill","stroke","opacity","globalAlpha","fillOpacity","fillStyle","strokeOpacity","strokeStyle","strokeDash","strokeDashOffset","drawPathAll","drawRect","fillRect","strokeRect","drawRule","drawImage","align","baseline","drawText","textAlign","textBaseline","radius","theta","fillText","strokeText","drawAll","pathFunc","drawOne","drawGroup","legends","axisItems","legendItems","gradient","grad","createLinearGradient","stops","addColorStop","pickGroup","subscene","hit","interactive","pickAll","hitTests","pickArea","pickLine","textHit","boundsCalc","tmpBounds","isPointInStroke","isPointInPath","symbol","../../util/bounds","./path",59,"currentPath","chunks","parsed","re","chunksParsed","jlen","command","commandLength","cmdLength","klen","drawArc","coords","rot","large","sweep","ex","ey","segs","arcToSegments","bez","segmentToBezier","bezierCurveTo","boundArc","rotateX","ox","oy","argsStr","arcToSegmentsCache","sin_th","cos_th","pl","a00","a01","a10","a11","x0","y0","sfactor_sq","sfactor","xc","yc","th0","th1","th_arc","segments","th2","th3","segmentToBezierCache","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","current","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","quadraticCurveTo",60,"SVGBuilder","./svg",61,62,"tag","close","escape_text","escape_font","group_bg","styl","class","clip_id","clipping","arc_path","area_path_h","area_path_v","line_path","symbol_path","xlink:href","text-anchor","cssClass","cls","xw","yh","styleProps","styles","_gid","_text","head","foot","svgNamespace","buildDefs","all","dgrad","dclip","stop-color","meta","MARKS","sty","nest","center",63,"svgHandler","__data__","_svg","dom","removeEventListener",64,"updateDefs","each","grd","cr","renderItems",65,"dup",66,"setProperty","removeProperty","area_path","setAttributeNS","removeAttribute","textContent","drawMark","evts","grps","childNodes","notG","mark_id",67,"Bounder","_mark","GROUP","../util/bounds",68,"inlineDs","sibling","_def","geom","_parent_id","_from","_ds","_isSuper","_bounder","newItem","Item","keyf","_map","joinDatasource","fullUpdate","keyFunction","joinValues","_items","Encoder","parent_id","inheritFrom","_parent","_encoder","builder","fcs","./Bounder","./Encoder","./Item",69,"enc","EMPTY",70,"_children","_scaler","_recursor","_scales","recurse","hasMarks","hasAxes","inline","buildMarks","buildAxes","MARK","parseAxes","buildGroup","inherit","axisDef","AXIS","Scale","acc","group_id","../dataflow/Collector","../parse/axes","./Builder","./Scale",71,"hasPropertySet","cousin","iidx","midx","touch",72,"_updated","instance","ORDINAL","ordinal","quantitative","rng","LINEAR","scaleName","dataDrivenRange","dataRef","RANGE","DOMAIN","points","rangePoints","rangeRoundBands","rangeBands","interval","QUANTILE","domainMinMax","rangeRound","exponent","POWER","clamp","nice","TIME","which","rlen","flen","refs","uniques","ck","cache","cacheField","Aggregate","singleton","stat","group_by","MIN","MAX","order","DESC","SINGLETON","domainMin","domainMax","LOG","zero","GROUP_PROPERTY","rangeMin","rangeMax","SIGNAL","../transforms/Aggregate",73,"updates","elapsed","curr","calcBounds","skip","interp","timer",74,"axis_def","newScale","oldScale","rangeBand","vg_axisScaleRange","gridLines","vg_axisTicks","tickLabels","vg_axisTickLabels","vg_axisDomain","vg_axisTitle","gridColor","vg_axisTicksExtend","tickMajorSize","tickMinorSize","vg_axisLabelExtend","vg_axisDomainExtend","tickEndSize","vg_axisTitleExtend","gridLineStyle","majorTickStyle","minorTickStyle","tickLabelStyle","domainStyle","titleStyle","vg_axisUpdate","tickFormatString","tickArguments","injest","major","minor","vg_axisSubdivide","label","tdata","vg_axisOrients","subticks","vg_axisScaleExtent","rangeExtent","vg_axisBaseline","vg_axisAlign","tickColor","tickWidth","tickLabelColor","tickLabelFont","tickLabelFontSize","titleFont","titleFontSize","titleFontWeight","titleColor","axisColor","axisWidth","../parse/mark",75,"GroupBy","Transform","addParameters","var","varp","stdevp","_fieldsDef","_Aggregators","_singleton","meas","aggs","measures","_reset","_keys","_gb","_new_cell","agg","cell","_add","_cell","flg","MOD_CELL","_rem","get","_cells","./GroupBy","./Transform","./measures",76,"BatchTransform","batchTransform",77,"Bin","default",78,"Cross","with","diagonal","_lastRem","_lastWith","_ids","_cache","wdata","diag","cross","upFields","selfCross","woutput",79,"Facet","_new_tuple","_mod","ADD_CELL",80,"Filter","_skip","../parse/expr",81,"Fold","rst","get_tuple","accessors","dlen","fold",82,"Force","links","linkDistance","linkStrength","charge","chargeDistance","iterations","friction","gravity","alpha","_nodes","_links","_layout","layout","force","nodeInput","linkInput","iter","link","tick","nodeIds","linkIds",83,"Formula",84,"Geo","Parameters","lon","lat","projection","clipAngle","clipExtent","d3Projection","proj","param","_mode","_projection","geo","ll","xy",85,"GeoPath","geojson","./Geo",86,"gb","groupBy",87,"LinkPath","sx","sy","ty","curve","ix","iy","diagonalX","diagonalY","shapes",88,"Parameter","_accessors","_resolution","arrayType","dataType","fieldType","exprType","_get","isData","isField","sources","isExpr",89,"Pie","ones","./BatchTransform",90,"Sort","by",91,"Stack","groupby","sortby","partition","groups",92,"params","_parameters","./Parameter",93,"Treemap","sticky","mode","treemap",94,"Unique","as",95,"Zip","withKey","_lastJoin","mp","wds","dflt","prevm","wlen",96,"aggregate","linkpath","formula","geopath","pie","zip","./Aggregate","./Bin","./Cross","./Facet","./Filter","./Fold","./Force","./Formula","./GeoPath","./LinkPath","./Pie","./Sort","./Stack","./Treemap","./Unique","./Zip",97,"measure","resolve","collect","req","ctr","quickselect","v_new","v_old","_counts","../util/quickselect",98,"gfx","pathBounds","boundPath","halfpi","xmin","xmax","ymin","ymax","angles","noRotate","measureText","includeLegends","itemBounds","methods","bounds_prev","pb","markBounds","../core/Bounds","../render/canvas/path","./config",99,"utc","legend","gradientStrokeColor","gradientStrokeWidth","gradientHeight","gradientWidth","labelColor","labelFontSize","labelFont","labelAlign","labelBaseline","labelOffset","symbolShape","symbolSize","symbolColor","symbolStrokeWidth","rgb","lab","hcl","hsl","category10","category20",100,"sentinel","COUNT","ASC",101,"console",102,"swap","pivot"],"mappings":"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","file":"vega2.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};\n},{\"./src/core/View\":27,\"./src/dataflow/Datasource\":29,\"./src/dataflow/Graph\":30,\"./src/dataflow/Node\":31,\"./src/dataflow/changeset\":33,\"./src/parse/spec\":52,\"./src/scene/Builder\":68,\"./src/scene/GroupBuilder\":70,\"./src/transforms/index\":96,\"./src/util/config\":99,\"datalib\":17}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('./util');\nvar units = require('./date-units');\nvar EPSILON = 1e-15;\n\nfunction bin(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, logb, level, minstep, precision, v, i, eps;\n\n  if (opt.step != null) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n};\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbin.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin);\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      bins = bin({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  bins.unit = unit;\n  bins.index = date_index;\n  if (!opt.raw) bins.value = date_value;\n  return bins;\n};\n\nmodule.exports = bin;\n\n},{\"./date-units\":5,\"./util\":21}],5:[function(require,module,exports){\nvar util = require('./util');\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nvar entries = [\n  {\n    type: \"second\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M:%S.%L\",\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: \"minute\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M\",\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: \"hour\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:00\",\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: \"day\",\n    minstep: 1,\n    step: [1, 7],\n    format: \"%Y %b %-d\",\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: \"month\",\n    minstep: 1,\n    step: [1, 3, 6],\n    format: \"%b %Y\",\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (util.isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: \"year\",\n    minstep: 1,\n    format: \"%Y\",\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (util.isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: \"minuteOfHour\",\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: \"%M\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: \"hourOfDay\",\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: \"%H\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: \"dayOfWeek\",\n  min: 0,\n  max: 6,\n  step: [1],\n  format: \"%a\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: \"dayOfMonth\",\n  min: 1,\n  max: 31,\n  step: [1],\n  format: \"%-d\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: \"monthOfYear\",\n  min: 0,\n  max: 11,\n  step: [1],\n  format: \"%b\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  \"second\":       entries[0],\n  \"minute\":       entries[1],\n  \"hour\":         entries[2],\n  \"day\":          entries[3],\n  \"month\":        entries[4],\n  \"year\":         entries[5],\n  \"minuteOfHour\": minuteOfHour,\n  \"hourOfDay\":    hourOfDay,\n  \"dayOfWeek\":    dayOfWeek,\n  \"dayOfMonth\":   dayOfMonth,\n  \"monthOfYear\":  monthOfYear,\n  \"timesteps\":    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{\"./util\":21}],6:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tvar d = max - min;\n\tvar f = function() {\n\t\treturn min + d * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n  var d = b - a;\n\tvar f = function() {\n\t\treturn a + Math.floor(d * Math.random());\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n},{}],7:[function(require,module,exports){\nvar stats = require('./stats');\nvar util = require('./util');\nvar bin = require('./bin');\nvar gen = require('./generate');\n\nmodule.exports = function(values, f, options) {\n  if (options === undefined && !util.isFunction(f)) { options = f; f = null; }\n\n  var type = options && options.type || infer(values, f);\n  if (type !== 'number' && type !== 'date' && type !== 'integer') {\n    return categorical(values, f, options && options.sort);\n  }\n\n  var ext = stats.extent(values, f),\n      opt = util.extend({min: ext[0], max: ext[1]}, options);\n  if (type === 'integer' && opt.minstep == null) opt.minstep = 1;\n  var b = type === 'date' ? bin.date(opt) : bin(opt);\n  return numerical(values, f, b);\n};\n\nfunction infer(values, f) {\n  var v = null, i;\n\n  // if data array has type annotations, use them\n  if (values.types) {\n    v = f(values.types);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0; !util.isNotNull(v) && i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n  return util.isDate(v) ? 'date' : util.isNumber(v) ? 'number' : 'string';\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var c = stats.unique(values, f).counts;\n  return util.keys(c)\n    .map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? \"-count\" : \"+value\"));\n}\n},{\"./bin\":4,\"./generate\":6,\"./stats\":18,\"./util\":21}],8:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.csv.parse(data ? data.toString() : data);\n  return d;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],9:[function(require,module,exports){\nmodule.exports = {\n  json: require('./json'),\n  csv: require('./csv'),\n  tsv: require('./tsv'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson')\n};\n},{\"./csv\":8,\"./json\":10,\"./topojson\":11,\"./treejson\":12,\"./tsv\":13}],10:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data)\n    ? data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":21}],11:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error(\"TopoJSON library not loaded.\"); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if (obj = t.objects[format.feature]) {\n      return topojson.feature(t, obj).features\n    } else {\n      throw Error(\"Invalid TopoJSON object: \"+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if (obj = t.objects[format.mesh]) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error(\"Invalid TopoJSON object: \" + format.mesh);\n    }\n  } else {\n    throw Error(\"Missing TopoJSON feature or mesh parameter.\");\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":10}],12:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || \"children\";\n  var table = [];\n  \n  function visit(node, parent) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":10}],13:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.tsv.parse(data ? data.toString() : data);\n  return d;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],14:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host == \"\") {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function (d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; };\n  \n  try {\n    var url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== \"text\"\n      ? request.response // null on error\n      : request.responseText; // \"\" on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest;\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest\n      && !(\"withCredentials\" in request)\n      && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest;\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    \"onload\" in request\n      ? request.onload = request.onerror = respond\n      : request.onreadystatechange = function() { request.readyState > 3 && respond(); };\n  }\n  \n  request.open(\"GET\", url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(file, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(file, 'utf8');\n  }\n  require('fs').readFile(file, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":21,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],15:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) opt = {url: opt};\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":21,\"./load\":14,\"./read\":16}],16:[function(require,module,exports){\nvar util = require('../util');\nvar formats = require('./formats');\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  util.identity\n};\n\nvar TESTS = {\n  boolean: function(x) { return x===\"true\" || x===\"false\" || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction read(data, format) {\n  var type = (format && format.type) || \"json\";\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction infer_type(values, f) {\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isNotNull(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction infer_types(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer_type(data, util.accessor(f));\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? infer_types(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return PARSERS[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  data.types = types;\n}\n\nread.type = infer_type;\nread.types = infer_types;\nread.formats = formats;\nread.parse = parse;\nmodule.exports = read;\n\n},{\"../util\":21,\"./formats\":9}],17:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  bin:       require('./bin'),\n  histogram: require('./histogram'),\n  summary:   require('./summary'),\n  template:  require('./template'),\n  dateunits: require('./date-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/loaders'));\n\nmodule.exports = dl;\n},{\"./bin\":4,\"./date-units\":5,\"./generate\":6,\"./histogram\":7,\"./import/load\":14,\"./import/loaders\":15,\"./import/read\":16,\"./stats\":18,\"./summary\":19,\"./template\":20,\"./util\":21}],18:[function(require,module,exports){\nvar util = require('./util');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Count the number of non-null values.\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Count the number of null or undefined values.\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error(\"Array lengths must match.\");\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!isNaN(v)) sum += v;\n    }\n  } else {  \n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  var a = values.map(function(v, i) {\n      return {\n        idx: i,\n        val: (f ? f(v) : v)\n      };\n    })\n    .sort(util.comparator(\"val\"));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(b) : a,\n  a = fn ? values.map(a) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(a) : values,\n      Y = b ? values.map(b) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      n = values.length, s = 0, d, i;\n\n  if (e === 2 || e === undefined) {\n    for (i=0; i<n; ++i) {\n      d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n      s += d*d;\n    }\n    return Math.sqrt(s); \n  } else {\n    for (i=0; i<n; ++i) {\n      d = Math.abs(f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]));\n      s += Math.pow(d, e);\n    }\n    return Math.pow(s, 1/e);\n  }\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  var i, p, s = 0, H = 0, N = counts.length;\n  for (i=0; i<N; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<N; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\n// Compute the normalized Shannon entropy (log base 2) of an array of counts.\nstats.entropy.normalized = function(counts, f) {\n  var H = stats.entropy(counts, f);\n  return H===0 ? 0 : H * Math.LN2 / Math.log(counts.length);\n};\n\n// Compute the mutual information between two discrete variables.\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.entropy.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(a) : values,\n      y = counts ? values.map(b) : a,\n      z = counts ? values.map(counts) : b;\n\n  var px = {},\n\t    py = {},\n\t    i, xx, yy, zz, s = 0, t, N = z.length, p, I = 0;\n\n\tfor (i=0; i<N; ++i) {\n\t  px[x[i]] = 0;\n\t  py[y[i]] = 0;\n  }\n\n\tfor (i=0; i<N; ++i) {\n\t\tpx[x[i]] += z[i];\n\t\tpy[y[i]] += z[i];\n\t\ts += z[i];\n\t}\n\n\tt = 1 / (s * Math.LN2);\n\tfor (i=0; i<N; ++i) {\n\t\tif (z[i] === 0) continue;\n\t\tp = (s * z[i]) / (px[x[i]] * py[y[i]]);\n\t\tI += z[i] * t * Math.log(p);\n\t}\n\n\treturn I;\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half, h, h2;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (util.isNotNull(v)) {\n      // update min/max\n      if (min===null || v < min) min = v;\n      if (max===null || v > max) max = v;\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\n    iqr:      [stats.quantile(vals, 0.25), stats.quantile(vals, 0.75)]\n  };\n};\n\nmodule.exports = stats;\n},{\"./generate\":6,\"./util\":21}],19:[function(require,module,exports){\nvar util = require('./util');\nvar stats = require('./stats');\n\n// Compute profiles for all variables in a data set.\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"modeskew: \" + p.modeskew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}\n},{\"./stats\":18,\"./util\":21}],20:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate\n};\n\nfunction template(text) {\n  var src = source(text, \"d\");\n  src = \"var __t; return \" + src + \";\";\n\n  try {\n    return (new Function(\"d\", src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || \"obj\";\n  var index = 0;\n  var src = \"'\";\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += \"'\\n+((__t=(\"\n        + template_var(interpolate, variable)\n        + \"))==null?'':__t)+\\n'\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + \"'\";\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var format = [];\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || \"\";\n    if (stringCast) {\n      stringCast = false;\n      src = \"String(\" + src + \")\" + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  var src = util.field(prop).map(util.str).join(\"][\");\n  src = variable + \"[\" + src + \"]\";\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a\n          + (args.length > 1 ? ',' + util.number(args[1]) : '')\n          + ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!==\"left\" && b!==\"middle\" && b!==\"center\") ? \"right\" : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\"' + b + '\")';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      default:\n        throw Error(\"Unrecognized template filter: \" + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === \"'\" && pattern[pattern.length-1] === \"'\") ||\n      (pattern[0] !== '\"' && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error(\"Format pattern must be quoted: \" + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util\":21}],21:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null && (typeof obj !== 'number' ? true : !isNaN(obj));\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.false = function() { return false; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : \"…\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"_process\":3,\"buffer\":2}],22:[function(require,module,exports){\nmodule.exports = require('./lib/heap');\n\n},{\"./lib/heap\":23}],23:[function(require,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n},{}],24:[function(require,module,exports){\nvar bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;\n},{}],25:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/index\":57,\"../render/svg-headless/index\":61,\"../util/debug\":101,\"./View\":27,\"datalib\":17}],26:[function(require,module,exports){\nvar Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;\n},{\"../dataflow/Graph\":30,\"../dataflow/Node\":31,\"../dataflow/changeset\":33,\"../scene/GroupBuilder\":70,\"datalib\":17}],27:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io = canvas;\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\nprototype.data = function(data) {\n  var m = this.model();\n  if (!arguments.length) return m.data();\n  dl.keys(data).forEach(function(d) { m.data(d).add(dl.duplicate(data[d])); });\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  // TODO: with streaming data API, adds should dl.duplicate just parseSpec\n  // to prevent Vega from polluting the environment.\n\n  var cs = changeset.create();\n  if(trans) cs.trans = trans;\n  if(opt.reflow !== undefined) cs.reflow = opt.reflow\n\n  if(!v._build) {\n    v._renderNode = new Node(v._model)\n      .router(true);\n\n    v._renderNode.evaluate = function(input) {\n      debug(input, [\"rendering\"]);\n\n      var s = v._model.scene();\n      if(input.trans) {\n        input.trans.start(function(items) { v._renderer.render(s, items); });\n      } else {\n        v._renderer.render(s);\n      }\n\n      // For all updated datasources, finalize their changesets.\n      var d, ds;\n      for(d in input.data) {\n        ds = v._model.data(d);\n        if(!ds.revises()) continue;\n        changeset.finalize(ds.last());\n      }\n\n      return input;\n    };\n\n    v._model.scene(v._renderNode);\n    v._build = true;\n  }\n\n  // Pulse the entire model (Datasources + scene).\n  v._model.fire(cs);\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":31,\"../dataflow/changeset\":33,\"../parse/streams\":53,\"../render/canvas/index\":57,\"../render/svg/index\":65,\"../scene/Transition\":73,\"../util/config\":99,\"../util/debug\":101,\"./HeadlessView\":25,\"datalib\":17}],28:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"../util/constants\":100,\"../util/debug\":101,\"./Node\":31,\"./changeset\":33}],29:[function(require,module,exports){\nvar dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.add = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.add(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;\n},{\"../util/constants\":100,\"../util/debug\":101,\"./Collector\":28,\"./Node\":31,\"./changeset\":33,\"./tuple\":34,\"datalib\":17}],30:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(name) {\n  var graph = this;\n  if(!arguments.length) name = dl.keys(this._signals);\n  if(!dl.isArray(name)) return this._signals[name].value();\n  return name.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;\n},{\"../util/constants\":100,\"../util/debug\":101,\"./Datasource\":29,\"./Signal\":32,\"./changeset\":33,\"datalib\":17,\"heap\":22}],31:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;\n},{\"../util/constants\":100,\"datalib\":17}],32:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nmodule.exports = Signal;\n},{\"./Node\":31,\"./changeset\":33}],33:[function(require,module,exports){\nvar C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};\n},{\"../util/constants\":100}],34:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};\n},{\"../util/constants\":100,\"datalib\":17}],35:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};\n},{\"./constants\":36,\"./functions\":37,\"datalib\":17}],36:[function(require,module,exports){\nmodule.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};\n},{}],37:[function(require,module,exports){\nvar datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};\n},{\"datalib\":17}],38:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n\n},{\"./codegen\":35,\"./parser\":39}],39:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],40:[function(require,module,exports){\nvar dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;\n},{\"../scene/axis\":74,\"../util/config\":99,\"datalib\":17}],41:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n\n},{\"../util/config\":99,\"./modify\":47,\"./transforms\":54,\"datalib\":17}],42:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};\n},{}],43:[function(require,module,exports){\nvar dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;\n},{\"../expression\":38,\"datalib\":17}],44:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}\n},{\"../util/config\":99,\"../util/constants\":100,\"datalib\":17}],45:[function(require,module,exports){\nvar dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};\n},{\"./properties\":50,\"datalib\":17}],46:[function(require,module,exports){\nvar parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};\n},{\"./mark\":45}],47:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}\n},{\"../dataflow/Node\":31,\"../dataflow/tuple\":34,\"../util/constants\":100,\"../util/debug\":101,\"datalib\":17}],48:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}\n},{\"datalib\":17}],49:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n},{\"datalib\":17}],50:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"../util/config\":99,\"datalib\":17}],51:[function(require,module,exports){\nvar expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n},{\"../util/constants\":100,\"./expr\":43}],52:[function(require,module,exports){\nvar dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n\n},{\"../core/Model\":26,\"../core/View\":27,\"../parse/data\":41,\"../parse/interactors\":44,\"../parse/marks\":46,\"../parse/padding\":48,\"../parse/predicates\":49,\"../parse/signals\":51,\"datalib\":17}],53:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":31,\"../dataflow/changeset\":33,\"../util/constants\":100,\"./events\":42,\"./expr\":43,\"datalib\":17}],54:[function(require,module,exports){\nvar dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};\n},{\"../transforms/index\":96,\"datalib\":17}],55:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":58,\"datalib\":17}],56:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":24,\"../../util/config\":99,\"./marks\":58,\"datalib\":17}],57:[function(require,module,exports){\nmodule.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};\n},{\"./Handler\":55,\"./Renderer\":56}],58:[function(require,module,exports){\nvar Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};\n},{\"../../core/Bounds\":24,\"../../util/bounds\":98,\"../../util/config\":99,\"./path\":59}],59:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":24}],60:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":99,\"./svg\":62,\"datalib\":17}],61:[function(require,module,exports){\nmodule.exports = {\n  Renderer: require('./Renderer')\n};\n\n},{\"./Renderer\":60}],62:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":99,\"datalib\":17}],63:[function(require,module,exports){\nvar dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;\n},{\"datalib\":17}],64:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":66,\"datalib\":17}],65:[function(require,module,exports){\narguments[4][57][0].apply(exports,arguments)\n},{\"./Handler\":63,\"./Renderer\":64,\"dup\":57}],66:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":99,\"datalib\":17}],67:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;\n},{\"../dataflow/Node\":31,\"../util/bounds\":98,\"../util/constants\":100,\"../util/debug\":101}],68:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;\n},{\"../dataflow/Node\":31,\"../dataflow/changeset\":33,\"../dataflow/tuple\":34,\"../parse/data\":41,\"../util/constants\":100,\"../util/debug\":101,\"./Bounder\":67,\"./Encoder\":69,\"./Item\":71,\"datalib\":17}],69:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db, i, len, item;\n\n  db = graph.data().reduce(function(db, ds) { \n    return (db[ds.name()] = ds.values(), db);\n  }, {});\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg);\n    if(exit)   encode.call(this, exit,   item, input.trans), db, sg; \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg);\n    if(update) encode.call(this, update, item, input.trans, db, sg);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, this._graph.predicates());\n}\n\n// If update property set uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n  return Node.prototype.reevaluate.call(this, pulse) || (update ? update.reflow : false);\n};\n\nmodule.exports = Encoder;\n},{\"../dataflow/Node\":31,\"../util/constants\":100,\"../util/debug\":101}],70:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n},{\"../dataflow/Collector\":28,\"../dataflow/Node\":31,\"../parse/axes\":40,\"../util/constants\":100,\"../util/debug\":101,\"./Builder\":68,\"./Scale\":72,\"datalib\":17}],71:[function(require,module,exports){\nfunction Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;\n},{}],72:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":31,\"../dataflow/changeset\":33,\"../transforms/Aggregate\":75,\"../util/config\":99,\"../util/constants\":100,\"../util/debug\":101,\"datalib\":17}],73:[function(require,module,exports){\nvar tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;\n},{\"../dataflow/tuple\":34,\"../util/bounds\":98,\"../util/constants\":100}],74:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"../parse/mark\":45,\"../util/config\":99,\"datalib\":17}],75:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;\n},{\"../dataflow/changeset\":33,\"../dataflow/tuple\":34,\"../util/constants\":100,\"../util/debug\":101,\"./GroupBy\":86,\"./Transform\":92,\"./measures\":97,\"datalib\":17}],76:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n\n},{\"../dataflow/Collector\":28,\"./Transform\":92}],77:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bin({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n},{\"../dataflow/tuple\":34,\"./Transform\":92,\"datalib\":17}],78:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;\n},{\"../dataflow/Collector\":28,\"../dataflow/changeset\":33,\"../dataflow/tuple\":34,\"../util/debug\":101,\"./Transform\":92}],79:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;\n},{\"../dataflow/changeset\":33,\"../dataflow/tuple\":34,\"../util/constants\":100,\"../util/debug\":101,\"./GroupBy\":86,\"./Transform\":92}],80:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n},{\"../dataflow/changeset\":33,\"../parse/expr\":43,\"../util/constants\":100,\"../util/debug\":101,\"./Transform\":92}],81:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;\n},{\"../dataflow/changeset\":33,\"../dataflow/tuple\":34,\"../util/debug\":101,\"./Transform\":92}],82:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"./Transform\":92}],83:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n},{\"../dataflow/tuple\":34,\"../parse/expr\":43,\"../util/constants\":100,\"../util/debug\":101,\"./Transform\":92}],84:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"./Transform\":92,\"datalib\":17}],85:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"./Geo\":84,\"./Transform\":92,\"datalib\":17}],86:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;\n},{\"../dataflow/changeset\":33,\"../dataflow/tuple\":34,\"../util/constants\":100,\"./Transform\":92}],87:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n},{\"../dataflow/tuple\":34,\"./Transform\":92}],88:[function(require,module,exports){\nvar dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":43,\"../util/constants\":100,\"datalib\":17}],89:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"./BatchTransform\":76,\"./Transform\":92,\"datalib\":17}],90:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;\n},{\"../parse/expr\":43,\"../util/debug\":101,\"./Transform\":92,\"datalib\":17}],91:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n},{\"../dataflow/tuple\":34,\"./BatchTransform\":76,\"./Transform\":92,\"datalib\":17}],92:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"../dataflow/Node\":31,\"../util/constants\":100,\"./Parameter\":88}],93:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":34,\"./BatchTransform\":76,\"./Transform\":92,\"datalib\":17}],94:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;\n},{\"../dataflow/tuple\":34,\"../util/debug\":101,\"./GroupBy\":86,\"./Transform\":92}],95:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;\n},{\"../dataflow/Collector\":28,\"../util/debug\":101,\"./Transform\":92,\"datalib\":17}],96:[function(require,module,exports){\nmodule.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};\n},{\"./Aggregate\":75,\"./Bin\":77,\"./Cross\":78,\"./Facet\":79,\"./Filter\":80,\"./Fold\":81,\"./Force\":82,\"./Formula\":83,\"./Geo\":84,\"./GeoPath\":85,\"./LinkPath\":87,\"./Pie\":89,\"./Sort\":90,\"./Stack\":91,\"./Treemap\":93,\"./Unique\":94,\"./Zip\":95}],97:[function(require,module,exports){\nvar dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;\n},{\"../dataflow/tuple\":34,\"../util/constants\":100,\"../util/quickselect\":102,\"datalib\":17}],98:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../core/Bounds\":24,\"../render/canvas/path\":59,\"./config\":99}],99:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],100:[function(require,module,exports){\nmodule.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};\n},{}],101:[function(require,module,exports){\nvar config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};\n},{\"./config\":99}],102:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};\n},{\"datalib\":17}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleCIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2Jpbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9kYXRlLXVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9jc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90cmVlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90c3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2xvYWQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2xvYWRlcnMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3JlYWQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3RhdHMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3VtbWFyeS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2hlYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qcyIsInNyYy9jb3JlL0JvdW5kcy5qcyIsInNyYy9jb3JlL0hlYWRsZXNzVmlldy5qcyIsInNyYy9jb3JlL01vZGVsLmpzIiwic3JjL2NvcmUvVmlldy5qcyIsInNyYy9kYXRhZmxvdy9Db2xsZWN0b3IuanMiLCJzcmMvZGF0YWZsb3cvRGF0YXNvdXJjZS5qcyIsInNyYy9kYXRhZmxvdy9HcmFwaC5qcyIsInNyYy9kYXRhZmxvdy9Ob2RlLmpzIiwic3JjL2RhdGFmbG93L1NpZ25hbC5qcyIsInNyYy9kYXRhZmxvdy9jaGFuZ2VzZXQuanMiLCJzcmMvZGF0YWZsb3cvdHVwbGUuanMiLCJzcmMvZXhwcmVzc2lvbi9jb2RlZ2VuLmpzIiwic3JjL2V4cHJlc3Npb24vY29uc3RhbnRzLmpzIiwic3JjL2V4cHJlc3Npb24vZnVuY3Rpb25zLmpzIiwic3JjL2V4cHJlc3Npb24vaW5kZXguanMiLCJzcmMvZXhwcmVzc2lvbi9wYXJzZXIuanMiLCJzcmMvcGFyc2UvYXhlcy5qcyIsInNyYy9wYXJzZS9kYXRhLmpzIiwic3JjL3BhcnNlL2V2ZW50cy5qcyIsInNyYy9wYXJzZS9leHByLmpzIiwic3JjL3BhcnNlL2ludGVyYWN0b3JzLmpzIiwic3JjL3BhcnNlL21hcmsuanMiLCJzcmMvcGFyc2UvbWFya3MuanMiLCJzcmMvcGFyc2UvbW9kaWZ5LmpzIiwic3JjL3BhcnNlL3BhZGRpbmcuanMiLCJzcmMvcGFyc2UvcHJlZGljYXRlcy5qcyIsInNyYy9wYXJzZS9wcm9wZXJ0aWVzLmpzIiwic3JjL3BhcnNlL3NpZ25hbHMuanMiLCJzcmMvcGFyc2Uvc3BlYy5qcyIsInNyYy9wYXJzZS9zdHJlYW1zLmpzIiwic3JjL3BhcnNlL3RyYW5zZm9ybXMuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9IYW5kbGVyLmpzIiwic3JjL3JlbmRlci9jYW52YXMvUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9pbmRleC5qcyIsInNyYy9yZW5kZXIvY2FudmFzL21hcmtzLmpzIiwic3JjL3JlbmRlci9jYW52YXMvcGF0aC5qcyIsInNyYy9yZW5kZXIvc3ZnLWhlYWRsZXNzL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9zdmctaGVhZGxlc3MvaW5kZXguanMiLCJzcmMvcmVuZGVyL3N2Zy1oZWFkbGVzcy9zdmcuanMiLCJzcmMvcmVuZGVyL3N2Zy9IYW5kbGVyLmpzIiwic3JjL3JlbmRlci9zdmcvUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy9tYXJrcy5qcyIsInNyYy9zY2VuZS9Cb3VuZGVyLmpzIiwic3JjL3NjZW5lL0J1aWxkZXIuanMiLCJzcmMvc2NlbmUvRW5jb2Rlci5qcyIsInNyYy9zY2VuZS9Hcm91cEJ1aWxkZXIuanMiLCJzcmMvc2NlbmUvSXRlbS5qcyIsInNyYy9zY2VuZS9TY2FsZS5qcyIsInNyYy9zY2VuZS9UcmFuc2l0aW9uLmpzIiwic3JjL3NjZW5lL2F4aXMuanMiLCJzcmMvdHJhbnNmb3Jtcy9BZ2dyZWdhdGUuanMiLCJzcmMvdHJhbnNmb3Jtcy9CYXRjaFRyYW5zZm9ybS5qcyIsInNyYy90cmFuc2Zvcm1zL0Jpbi5qcyIsInNyYy90cmFuc2Zvcm1zL0Nyb3NzLmpzIiwic3JjL3RyYW5zZm9ybXMvRmFjZXQuanMiLCJzcmMvdHJhbnNmb3Jtcy9GaWx0ZXIuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb2xkLmpzIiwic3JjL3RyYW5zZm9ybXMvRm9yY2UuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb3JtdWxhLmpzIiwic3JjL3RyYW5zZm9ybXMvR2VvLmpzIiwic3JjL3RyYW5zZm9ybXMvR2VvUGF0aC5qcyIsInNyYy90cmFuc2Zvcm1zL0dyb3VwQnkuanMiLCJzcmMvdHJhbnNmb3Jtcy9MaW5rUGF0aC5qcyIsInNyYy90cmFuc2Zvcm1zL1BhcmFtZXRlci5qcyIsInNyYy90cmFuc2Zvcm1zL1BpZS5qcyIsInNyYy90cmFuc2Zvcm1zL1NvcnQuanMiLCJzcmMvdHJhbnNmb3Jtcy9TdGFjay5qcyIsInNyYy90cmFuc2Zvcm1zL1RyYW5zZm9ybS5qcyIsInNyYy90cmFuc2Zvcm1zL1RyZWVtYXAuanMiLCJzcmMvdHJhbnNmb3Jtcy9VbmlxdWUuanMiLCJzcmMvdHJhbnNmb3Jtcy9aaXAuanMiLCJzcmMvdHJhbnNmb3Jtcy9pbmRleC5qcyIsInNyYy90cmFuc2Zvcm1zL21lYXN1cmVzLmpzIiwic3JjL3V0aWwvYm91bmRzLmpzIiwic3JjL3V0aWwvY29uZmlnLmpzIiwic3JjL3V0aWwvY29uc3RhbnRzLmpzIiwic3JjL3V0aWwvZGVidWcuanMiLCJzcmMvdXRpbC9xdWlja3NlbGVjdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29yZToge1xuICAgIFZpZXc6IHJlcXVpcmUoJy4vc3JjL2NvcmUvVmlldycpXG4gIH0sXG4gIGRhdGFmbG93OiB7XG4gICAgY2hhbmdlc2V0OiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBEYXRhc291cmNlOiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9EYXRhc291cmNlJyksXG4gICAgR3JhcGg6IHJlcXVpcmUoJy4vc3JjL2RhdGFmbG93L0dyYXBoJyksXG4gICAgTm9kZTogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvTm9kZScpXG4gIH0sXG4gIHBhcnNlOiB7XG4gICAgc3BlYzogcmVxdWlyZSgnLi9zcmMvcGFyc2Uvc3BlYycpXG4gIH0sXG4gIHNjZW5lOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi9zcmMvc2NlbmUvQnVpbGRlcicpLFxuICAgIEdyb3VwQnVpbGRlcjogcmVxdWlyZSgnLi9zcmMvc2NlbmUvR3JvdXBCdWlsZGVyJylcbiAgfSxcbiAgdHJhbnNmb3JtczogcmVxdWlyZSgnLi9zcmMvdHJhbnNmb3Jtcy9pbmRleCcpLFxuICBjb25maWc6IHJlcXVpcmUoJy4vc3JjL3V0aWwvY29uZmlnJyksXG4gIHV0aWw6IHJlcXVpcmUoJ2RhdGFsaWInKVxufTsiLG51bGwsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHVuaXRzID0gcmVxdWlyZSgnLi9kYXRlLXVuaXRzJyk7XG52YXIgRVBTSUxPTiA9IDFlLTE1O1xuXG5mdW5jdGlvbiBiaW4ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgdmFyIG1heGIgPSBvcHQubWF4YmlucyB8fCAxNSxcbiAgICAgIGJhc2UgPSBvcHQuYmFzZSB8fCAxMCxcbiAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgIGRpdiA9IG9wdC5kaXYgfHwgWzUsIDJdLCAgICAgIFxuICAgICAgbWluID0gb3B0Lm1pbixcbiAgICAgIG1heCA9IG9wdC5tYXgsXG4gICAgICBzcGFuID0gbWF4IC0gbWluLFxuICAgICAgc3RlcCwgbG9nYiwgbGV2ZWwsIG1pbnN0ZXAsIHByZWNpc2lvbiwgdiwgaSwgZXBzO1xuXG4gIGlmIChvcHQuc3RlcCAhPSBudWxsKSB7XG4gICAgLy8gaWYgc3RlcCBzaXplIGlzIGV4cGxpY2l0bHkgZ2l2ZW4sIHVzZSB0aGF0XG4gICAgc3RlcCA9IG9wdC5zdGVwO1xuICB9IGVsc2UgaWYgKG9wdC5zdGVwcykge1xuICAgIC8vIGlmIHByb3ZpZGVkLCBsaW1pdCBjaG9pY2UgdG8gYWNjZXB0YWJsZSBzdGVwIHNpemVzXG4gICAgc3RlcCA9IG9wdC5zdGVwc1tNYXRoLm1pbihcbiAgICAgIG9wdC5zdGVwcy5sZW5ndGggLSAxLFxuICAgICAgYmlzZWN0KG9wdC5zdGVwcywgc3Bhbi9tYXhiLCAwLCBvcHQuc3RlcHMubGVuZ3RoKVxuICAgICldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IG9wdC5taW5zdGVwIHx8IDA7XG4gICAgc3RlcCA9IE1hdGgubWF4KFxuICAgICAgbWluc3RlcCxcbiAgICAgIE1hdGgucG93KGJhc2UsIE1hdGgucm91bmQoTWF0aC5sb2coc3BhbikgLyBsb2diKSAtIGxldmVsKVxuICAgICk7XG4gICAgXG4gICAgLy8gaW5jcmVhc2Ugc3RlcCBzaXplIGlmIHRvbyBtYW55IGJpbnNcbiAgICBkbyB7IHN0ZXAgKj0gYmFzZTsgfSB3aGlsZSAoTWF0aC5jZWlsKHNwYW4vc3RlcCkgPiBtYXhiKTtcblxuICAgIC8vIGRlY3JlYXNlIHN0ZXAgc2l6ZSBpZiBhbGxvd2VkXG4gICAgZm9yIChpPTA7IGk8ZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnN0ZXAgJiYgc3BhbiAvIHYgPD0gbWF4Yikgc3RlcCA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDE7XG4gIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcbiAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmZsb29yKG1pbiAvIHN0ZXAgKyBlcHMpICogc3RlcCk7XG4gIG1heCA9IE1hdGguY2VpbChtYXggLyBzdGVwKSAqIHN0ZXA7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbWluLFxuICAgIHN0b3A6ICBtYXgsXG4gICAgc3RlcDogIHN0ZXAsXG4gICAgdW5pdDogIHtwcmVjaXNpb246IHByZWNpc2lvbn0sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGluZGV4OiBpbmRleFxuICB9O1xufTtcblxuZnVuY3Rpb24gYmlzZWN0KGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmICh1dGlsLmNtcChhW21pZF0sIHgpIDwgMCkgeyBsbyA9IG1pZCArIDE7IH1cbiAgICBlbHNlIHsgaGkgPSBtaWQ7IH1cbiAgfVxuICByZXR1cm4gbG87XG59O1xuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbi5kYXRlID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBmaW5kIHRpbWUgc3RlcCwgdGhlbiBiaW5cbiAgdmFyIGRtaW4gPSBvcHQubWluLFxuICAgICAgZG1heCA9IG9wdC5tYXgsXG4gICAgICBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMjAsXG4gICAgICBtaW5iID0gb3B0Lm1pbmJpbnMgfHwgNCxcbiAgICAgIHNwYW4gPSAoK2RtYXgpIC0gKCtkbWluKTtcbiAgICAgIHVuaXQgPSBvcHQudW5pdCA/IHVuaXRzW29wdC51bml0XSA6IHVuaXRzLmZpbmQoc3BhbiwgbWluYiwgbWF4YiksXG4gICAgICBiaW5zID0gYmluKHtcbiAgICAgICAgbWluOiAgICAgdW5pdC5taW4gIT0gbnVsbCA/IHVuaXQubWluIDogdW5pdC51bml0KGRtaW4pLFxuICAgICAgICBtYXg6ICAgICB1bml0Lm1heCAhPSBudWxsID8gdW5pdC5tYXggOiB1bml0LnVuaXQoZG1heCksXG4gICAgICAgIG1heGJpbnM6IG1heGIsXG4gICAgICAgIG1pbnN0ZXA6IHVuaXQubWluc3RlcCxcbiAgICAgICAgc3RlcHM6ICAgdW5pdC5zdGVwXG4gICAgICB9KTtcblxuICBiaW5zLnVuaXQgPSB1bml0O1xuICBiaW5zLmluZGV4ID0gZGF0ZV9pbmRleDtcbiAgaWYgKCFvcHQucmF3KSBiaW5zLnZhbHVlID0gZGF0ZV92YWx1ZTtcbiAgcmV0dXJuIGJpbnM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBTVEVQUyA9IFtcbiAgWzMxNTM2ZTYsIDVdLCAgLy8gMS15ZWFyXG4gIFs3Nzc2ZTYsIDRdLCAgIC8vIDMtbW9udGhcbiAgWzI1OTJlNiwgNF0sICAgLy8gMS1tb250aFxuICBbMTIwOTZlNSwgM10sICAvLyAyLXdlZWtcbiAgWzYwNDhlNSwgM10sICAgLy8gMS13ZWVrXG4gIFsxNzI4ZTUsIDNdLCAgIC8vIDItZGF5XG4gIFs4NjRlNSwgM10sICAgIC8vIDEtZGF5XG4gIFs0MzJlNSwgMl0sICAgIC8vIDEyLWhvdXJcbiAgWzIxNmU1LCAyXSwgICAgLy8gNi1ob3VyXG4gIFsxMDhlNSwgMl0sICAgIC8vIDMtaG91clxuICBbMzZlNSwgMl0sICAgICAvLyAxLWhvdXJcbiAgWzE4ZTUsIDFdLCAgICAgLy8gMzAtbWludXRlXG4gIFs5ZTUsIDFdLCAgICAgIC8vIDE1LW1pbnV0ZVxuICBbM2U1LCAxXSwgICAgICAvLyA1LW1pbnV0ZVxuICBbNmU0LCAxXSwgICAgICAvLyAxLW1pbnV0ZVxuICBbM2U0LCAwXSwgICAgICAvLyAzMC1zZWNvbmRcbiAgWzE1ZTMsIDBdLCAgICAgLy8gMTUtc2Vjb25kXG4gIFs1ZTMsIDBdLCAgICAgIC8vIDUtc2Vjb25kXG4gIFsxZTMsIDBdICAgICAgIC8vIDEtc2Vjb25kXG5dO1xuXG52YXIgZW50cmllcyA9IFtcbiAge1xuICAgIHR5cGU6IFwic2Vjb25kXCIsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6IFwiJVkgJWIgJS1kICVIOiVNOiVTLiVMXCIsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiAxZTMpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuICgrZCAvIDFlMyk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogXCJtaW51dGVcIixcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogXCIlWSAlYiAlLWQgJUg6JU1cIixcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDZlNCk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyA2ZTQpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiaG91clwiLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiBcIiVZICViICUtZCAlSDowMFwiLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogMzZlNSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyAzNmU1KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImRheVwiLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgc3RlcDogWzEsIDddLFxuICAgIGZvcm1hdDogXCIlWSAlYiAlLWRcIixcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDg2NGU1KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDg2NGU1KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIm1vbnRoXCIsXG4gICAgbWluc3RlcDogMSxcbiAgICBzdGVwOiBbMSwgMywgNl0sXG4gICAgZm9ybWF0OiBcIiViICVZXCIsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKH5+KGQgLyAxMiksIGQgJSAxMiwgMSkpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKHV0aWwuaXNOdW1iZXIoZCkpIGQgPSBuZXcgRGF0ZShkKTtcbiAgICAgIHJldHVybiAxMiAqIGQuZ2V0VVRDRnVsbFllYXIoKSArIGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInllYXJcIixcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogXCIlWVwiLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLCAwLCAxKSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gKHV0aWwuaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgfVxuICB9XG5dO1xuXG52YXIgbWludXRlT2ZIb3VyID0ge1xuICB0eXBlOiBcIm1pbnV0ZU9mSG91clwiLFxuICBtaW46IDAsXG4gIG1heDogNTksXG4gIG1pbnN0ZXA6IDEsXG4gIGZvcm1hdDogXCIlTVwiLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAodXRpbC5pc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDTWludXRlcygpO1xuICB9XG59O1xuXG52YXIgaG91ck9mRGF5ID0ge1xuICB0eXBlOiBcImhvdXJPZkRheVwiLFxuICBtaW46IDAsXG4gIG1heDogMjMsXG4gIG1pbnN0ZXA6IDEsXG4gIGZvcm1hdDogXCIlSFwiLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAodXRpbC5pc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDSG91cnMoKTtcbiAgfVxufTtcblxudmFyIGRheU9mV2VlayA9IHtcbiAgdHlwZTogXCJkYXlPZldlZWtcIixcbiAgbWluOiAwLFxuICBtYXg6IDYsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiBcIiVhXCIsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgNCArIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAodXRpbC5pc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRGF5KCk7XG4gIH1cbn07XG5cbnZhciBkYXlPZk1vbnRoID0ge1xuICB0eXBlOiBcImRheU9mTW9udGhcIixcbiAgbWluOiAxLFxuICBtYXg6IDMxLFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogXCIlLWRcIixcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKHV0aWwuaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0RhdGUoKTtcbiAgfVxufTtcblxudmFyIG1vbnRoT2ZZZWFyID0ge1xuICB0eXBlOiBcIm1vbnRoT2ZZZWFyXCIsXG4gIG1pbjogMCxcbiAgbWF4OiAxMSxcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6IFwiJWJcIixcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCBkICUgMTIsIDEpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAodXRpbC5pc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDTW9udGgoKTtcbiAgfVxufTtcblxudmFyIHVuaXRzID0ge1xuICBcInNlY29uZFwiOiAgICAgICBlbnRyaWVzWzBdLFxuICBcIm1pbnV0ZVwiOiAgICAgICBlbnRyaWVzWzFdLFxuICBcImhvdXJcIjogICAgICAgICBlbnRyaWVzWzJdLFxuICBcImRheVwiOiAgICAgICAgICBlbnRyaWVzWzNdLFxuICBcIm1vbnRoXCI6ICAgICAgICBlbnRyaWVzWzRdLFxuICBcInllYXJcIjogICAgICAgICBlbnRyaWVzWzVdLFxuICBcIm1pbnV0ZU9mSG91clwiOiBtaW51dGVPZkhvdXIsXG4gIFwiaG91ck9mRGF5XCI6ICAgIGhvdXJPZkRheSxcbiAgXCJkYXlPZldlZWtcIjogICAgZGF5T2ZXZWVrLFxuICBcImRheU9mTW9udGhcIjogICBkYXlPZk1vbnRoLFxuICBcIm1vbnRoT2ZZZWFyXCI6ICBtb250aE9mWWVhcixcbiAgXCJ0aW1lc3RlcHNcIjogICAgZW50cmllc1xufTtcblxudW5pdHMuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIGksIGxlbiwgYmlucywgc3RlcCA9IFNURVBTWzBdO1xuXG4gIGZvciAoaSA9IDEsIGxlbiA9IFNURVBTLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW1NURVBTW2kgLSAxXVsxXV07XG4gICAgICB9XG4gICAgICBpZiAoYmlucyA+PSBtaW5iKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZW50cmllc1tTVEVQU1tTVEVQUy5sZW5ndGggLSAxXVsxXV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXRzO1xuIiwidmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmdlbi5yZXBlYXQgPSBmdW5jdGlvbih2YWwsIG4pIHtcbiAgdmFyIGEgPSBBcnJheShuKSwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBhW2ldID0gdmFsO1xuICByZXR1cm4gYTtcbn07XG5cbmdlbi56ZXJvcyA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIGdlbi5yZXBlYXQoMCwgbik7XG59O1xuXG5nZW4ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBzdGVwID0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSByYW5nZScpO1xuICB2YXIgcmFuZ2UgPSBbXSwgaSA9IC0xLCBqO1xuICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGopO1xuICBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGopO1xuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5nZW4ucmFuZG9tID0ge307XG5cbmdlbi5yYW5kb20udW5pZm9ybSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuXHRcdG1heCA9IG1pbjtcblx0XHRtaW4gPSAwO1xuXHR9XG5cdHZhciBkID0gbWF4IC0gbWluO1xuXHR2YXIgZiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBtaW4gKyBkICogTWF0aC5yYW5kb20oKTtcblx0fTtcblx0Zi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcblx0cmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLmludGVnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcblx0XHRiID0gYTtcblx0XHRhID0gMDtcblx0fVxuICB2YXIgZCA9IGIgLSBhO1xuXHR2YXIgZiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBhICsgTWF0aC5mbG9vcihkICogTWF0aC5yYW5kb20oKSk7XG5cdH07XG5cdGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG5cdHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5ub3JtYWwgPSBmdW5jdGlvbihtZWFuLCBzdGRldikge1xuXHRtZWFuID0gbWVhbiB8fCAwO1xuXHRzdGRldiA9IHN0ZGV2IHx8IDE7XG5cdHZhciBuZXh0ID0gdW5kZWZpbmVkO1xuXHR2YXIgZiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB4ID0gMCwgeSA9IDAsIHJkcywgYztcblx0XHRpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR4ID0gbmV4dDtcblx0XHRcdG5leHQgPSB1bmRlZmluZWQ7XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9XG5cdFx0ZG8ge1xuXHRcdFx0eCA9IE1hdGgucmFuZG9tKCkqMi0xO1xuXHRcdFx0eSA9IE1hdGgucmFuZG9tKCkqMi0xO1xuXHRcdFx0cmRzID0geCp4ICsgeSp5O1xuXHRcdH0gd2hpbGUgKHJkcyA9PSAwIHx8IHJkcyA+IDEpO1xuXHRcdGMgPSBNYXRoLnNxcnQoLTIqTWF0aC5sb2cocmRzKS9yZHMpOyAvLyBCb3gtTXVsbGVyIHRyYW5zZm9ybVxuXHRcdG5leHQgPSBtZWFuICsgeSpjKnN0ZGV2O1xuXHRcdHJldHVybiBtZWFuICsgeCpjKnN0ZGV2O1xuXHR9O1xuXHRmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuXHRyZXR1cm4gZjtcbn07IiwidmFyIHN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW4gPSByZXF1aXJlKCcuL2JpbicpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiAhdXRpbC5pc0Z1bmN0aW9uKGYpKSB7IG9wdGlvbnMgPSBmOyBmID0gbnVsbDsgfVxuXG4gIHZhciB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgaW5mZXIodmFsdWVzLCBmKTtcbiAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdkYXRlJyAmJiB0eXBlICE9PSAnaW50ZWdlcicpIHtcbiAgICByZXR1cm4gY2F0ZWdvcmljYWwodmFsdWVzLCBmLCBvcHRpb25zICYmIG9wdGlvbnMuc29ydCk7XG4gIH1cblxuICB2YXIgZXh0ID0gc3RhdHMuZXh0ZW50KHZhbHVlcywgZiksXG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7bWluOiBleHRbMF0sIG1heDogZXh0WzFdfSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlID09PSAnaW50ZWdlcicgJiYgb3B0Lm1pbnN0ZXAgPT0gbnVsbCkgb3B0Lm1pbnN0ZXAgPSAxO1xuICB2YXIgYiA9IHR5cGUgPT09ICdkYXRlJyA/IGJpbi5kYXRlKG9wdCkgOiBiaW4ob3B0KTtcbiAgcmV0dXJuIG51bWVyaWNhbCh2YWx1ZXMsIGYsIGIpO1xufTtcblxuZnVuY3Rpb24gaW5mZXIodmFsdWVzLCBmKSB7XG4gIHZhciB2ID0gbnVsbCwgaTtcblxuICAvLyBpZiBkYXRhIGFycmF5IGhhcyB0eXBlIGFubm90YXRpb25zLCB1c2UgdGhlbVxuICBpZiAodmFsdWVzLnR5cGVzKSB7XG4gICAgdiA9IGYodmFsdWVzLnR5cGVzKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2KSkgcmV0dXJuIHY7XG4gIH1cblxuICBmb3IgKGk9MDsgIXV0aWwuaXNOb3ROdWxsKHYpICYmIGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gIH1cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDogdXRpbC5pc051bWJlcih2KSA/ICdudW1iZXInIDogJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIG51bWVyaWNhbCh2YWx1ZXMsIGYsIGIpIHtcbiAgdmFyIGggPSBnZW4ucmFuZ2UoYi5zdGFydCwgYi5zdG9wICsgYi5zdGVwLzIsIGIuc3RlcClcbiAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHt2YWx1ZTogYi52YWx1ZSh2KSwgY291bnQ6IDB9OyB9KTtcblxuICBmb3IgKHZhciBpPTAsIHYsIGo7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICBqID0gYi5pbmRleCh2KTtcbiAgICAgIGlmIChqIDwgMCB8fCBqID49IGgubGVuZ3RoIHx8ICFpc0Zpbml0ZShqKSkgY29udGludWU7XG4gICAgICBoW2pdLmNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIGguYmlucyA9IGI7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBjYXRlZ29yaWNhbCh2YWx1ZXMsIGYsIHNvcnQpIHtcbiAgdmFyIGMgPSBzdGF0cy51bmlxdWUodmFsdWVzLCBmKS5jb3VudHM7XG4gIHJldHVybiB1dGlsLmtleXMoYylcbiAgICAubWFwKGZ1bmN0aW9uKGspIHsgcmV0dXJuIHt2YWx1ZTogaywgY291bnQ6IGNba119OyB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcihzb3J0ID8gXCItY291bnRcIiA6IFwiK3ZhbHVlXCIpKTtcbn0iLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSBkMy5jc3YucGFyc2UoZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IGRhdGEpO1xuICByZXR1cm4gZDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAganNvbjogcmVxdWlyZSgnLi9qc29uJyksXG4gIGNzdjogcmVxdWlyZSgnLi9jc3YnKSxcbiAgdHN2OiByZXF1aXJlKCcuL3RzdicpLFxuICB0b3BvanNvbjogcmVxdWlyZSgnLi90b3BvanNvbicpLFxuICB0cmVlanNvbjogcmVxdWlyZSgnLi90cmVlanNvbicpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IHV0aWwuaXNPYmplY3QoZGF0YSkgJiYgIXV0aWwuaXNCdWZmZXIoZGF0YSlcbiAgICA/IGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5wcm9wZXJ0eSkge1xuICAgIGQgPSB1dGlsLmFjY2Vzc29yKGZvcm1hdC5wcm9wZXJ0eSkoZCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59O1xuIiwidmFyIGpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcbnZhciB0b3BvanNvbiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnRvcG9qc29uIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC50b3BvanNvbiA6IG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBpZiAodG9wb2pzb24gPT0gbnVsbCkgeyB0aHJvdyBFcnJvcihcIlRvcG9KU09OIGxpYnJhcnkgbm90IGxvYWRlZC5cIik7IH1cblxuICB2YXIgdCA9IGpzb24oZGF0YSwgZm9ybWF0KSwgb2JqO1xuXG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LmZlYXR1cmUpIHtcbiAgICBpZiAob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5mZWF0dXJlXSkge1xuICAgICAgcmV0dXJuIHRvcG9qc29uLmZlYXR1cmUodCwgb2JqKS5mZWF0dXJlc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgVG9wb0pTT04gb2JqZWN0OiBcIitmb3JtYXQuZmVhdHVyZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCAmJiBmb3JtYXQubWVzaCkge1xuICAgIGlmIChvYmogPSB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKSB7XG4gICAgICByZXR1cm4gW3RvcG9qc29uLm1lc2godCwgdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgVG9wb0pTT04gb2JqZWN0OiBcIiArIGZvcm1hdC5tZXNoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIFRvcG9KU09OIGZlYXR1cmUgb3IgbWVzaCBwYXJhbWV0ZXIuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIGRhdGEgPSBqc29uKGRhdGEsIGZvcm1hdCk7XG4gIHJldHVybiB0b1RhYmxlKGRhdGEsIChmb3JtYXQgJiYgZm9ybWF0LmNoaWxkcmVuKSk7XG59O1xuXG5mdW5jdGlvbiB0b1RhYmxlKHJvb3QsIGNoaWxkcmVuRmllbGQpIHtcbiAgY2hpbGRyZW5GaWVsZCA9IGNoaWxkcmVuRmllbGQgfHwgXCJjaGlsZHJlblwiO1xuICB2YXIgdGFibGUgPSBbXTtcbiAgXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUsIHBhcmVudCkge1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB2aXNpdChyb290LCBudWxsKTtcbiAgcmV0dXJuICh0YWJsZS5yb290ID0gcm9vdCwgdGFibGUpO1xufSIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IGQzLnRzdi5wYXJzZShkYXRhID8gZGF0YS50b1N0cmluZygpIDogZGF0YSk7XG4gIHJldHVybiBkO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGFic29sdXRlIFVSTHMgd2l0aCBvcHRpb25hbCBwcm90b2NvbFxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG52YXIgcHJvdG9jb2xfcmUgPSAvXihbQS1aYS16XSs6KT9cXC9cXC8vO1xuXG4vLyBTcGVjaWFsIHRyZWF0bWVudCBpbiBub2RlLmpzIGZvciB0aGUgZmlsZTogcHJvdG9jb2xcbnZhciBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG5cbi8vIFZhbGlkYXRlIGFuZCBjbGVhbnVwIFVSTCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGJlIGFjY2Vzc2VkXG4vLyBSZXR1cm5zIGNsZWFuZWQgdXAgVVJMLCBvciBmYWxzZSBpZiBhY2Nlc3MgaXMgbm90IGFsbG93ZWRcbmZ1bmN0aW9uIHNhbml0aXplVXJsKG9wdCkge1xuICB2YXIgdXJsID0gb3B0LnVybDtcbiAgaWYgKCF1cmwgJiYgb3B0LmZpbGUpIHsgcmV0dXJuIGZpbGVQcm90b2NvbCArIG9wdC5maWxlOyB9XG5cbiAgLy8gSW4gY2FzZSB0aGlzIGlzIGEgcmVsYXRpdmUgdXJsIChoYXMgbm8gaG9zdCksIHByZXBlbmQgb3B0LmJhc2VVUkxcbiAgaWYgKG9wdC5iYXNlVVJMICYmICFwcm90b2NvbF9yZS50ZXN0KHVybCkpIHtcbiAgICBpZiAoIXV0aWwuc3RhcnRzV2l0aCh1cmwsICcvJykgJiYgb3B0LmJhc2VVUkxbb3B0LmJhc2VVUkwubGVuZ3RoLTFdICE9PSAnLycpIHtcbiAgICAgIHVybCA9ICcvJyArIHVybDsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgfVxuICAgIHVybCA9IG9wdC5iYXNlVVJMICsgdXJsO1xuICB9XG4gIC8vIHJlbGF0aXZlIHByb3RvY29sLCBzdGFydHMgd2l0aCAnLy8nXG4gIGlmICh1dGlsLmlzTm9kZSAmJiB1dGlsLnN0YXJ0c1dpdGgodXJsLCAnLy8nKSkge1xuICAgIHVybCA9IChvcHQuZGVmYXVsdFByb3RvY29sIHx8ICdodHRwJykgKyAnOicgKyB1cmw7XG4gIH1cbiAgLy8gSWYgb3B0LmRvbWFpbldoaXRlTGlzdCBpcyBzZXQsIG9ubHkgYWxsb3dzIHVybCwgd2hvc2UgaG9zdG5hbWVcbiAgLy8gKiBJcyB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpXG4gIC8vICogRXF1YWxzIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgLy8gKiBJcyBhIHByb3BlciBzdWJkb21haW4gb2Ygb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICBpZiAob3B0LmRvbWFpbldoaXRlTGlzdCkge1xuICAgIHZhciBkb21haW4sIG9yaWdpbjtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgIC8vIHJlbGF0aXZlIHByb3RvY29sIGlzIGJyb2tlbjogaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS11cmwvaXNzdWVzLzVcbiAgICAgIHZhciBwYXJ0cyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHVybCk7XG4gICAgICBkb21haW4gPSBwYXJ0cy5ob3N0bmFtZTtcbiAgICAgIG9yaWdpbiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNjUxMy9ob3ctZG8taS1wYXJzZS1hLXVybC1pbnRvLWhvc3RuYW1lLWFuZC1wYXRoLWluLWphdmFzY3JpcHRcbiAgICAgIC8vIElFIGRvZXNuJ3QgcG9wdWxhdGUgYWxsIGxpbmsgcHJvcGVydGllcyB3aGVuIHNldHRpbmcgLmhyZWYgd2l0aCBhIHJlbGF0aXZlIFVSTCxcbiAgICAgIC8vIGhvd2V2ZXIgLmhyZWYgd2lsbCByZXR1cm4gYW4gYWJzb2x1dGUgVVJMIHdoaWNoIHRoZW4gY2FuIGJlIHVzZWQgb24gaXRzZWxmXG4gICAgICAvLyB0byBwb3B1bGF0ZSB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkcy5cbiAgICAgIGlmIChhLmhvc3QgPT0gXCJcIikge1xuICAgICAgICBhLmhyZWYgPSBhLmhyZWY7XG4gICAgICB9XG4gICAgICBkb21haW4gPSBhLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9yaWdpbiAhPT0gZG9tYWluKSB7XG4gICAgICB2YXIgd2hpdGVMaXN0ZWQgPSBvcHQuZG9tYWluV2hpdGVMaXN0LnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGlkeCA9IGRvbWFpbi5sZW5ndGggLSBkLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGQgPT09IGRvbWFpbiB8fFxuICAgICAgICAgIChpZHggPiAxICYmIGRvbWFpbltpZHgtMV0gPT09ICcuJyAmJiBkb21haW4ubGFzdEluZGV4T2YoZCkgPT09IGlkeCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghd2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgJ1VSTCBpcyBub3Qgd2hpdGVsaXN0ZWQ6ICcgKyB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGxvYWQob3B0LCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlKSB7IHRocm93IGU7IH07XG4gIFxuICB0cnkge1xuICAgIHZhciB1cmwgPSBsb2FkLnNhbml0aXplVXJsKG9wdCk7IC8vIGVuYWJsZSBvdmVycmlkZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcihlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgVVJMOiAnICsgdXJsKTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUpIHtcbiAgICAvLyBpbiBicm93c2VyLCB1c2UgeGhyXG4gICAgcmV0dXJuIHhocih1cmwsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh1dGlsLnN0YXJ0c1dpdGgodXJsLCBmaWxlUHJvdG9jb2wpKSB7XG4gICAgLy8gaW4gbm9kZS5qcywgaWYgdXJsIHN0YXJ0cyB3aXRoICdmaWxlOi8vJywgc3RyaXAgaXQgYW5kIGxvYWQgZnJvbSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLnNsaWNlKGZpbGVQcm90b2NvbC5sZW5ndGgpLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZm9yIHJlZ3VsYXIgVVJMcyBpbiBub2RlLmpzXG4gICAgcmV0dXJuIGh0dHAodXJsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24geGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSBcInRleHRcIlxuICAgICAgPyByZXF1ZXN0LnJlc3BvbnNlIC8vIG51bGwgb24gZXJyb3JcbiAgICAgIDogcmVxdWVzdC5yZXNwb25zZVRleHQ7IC8vIFwiXCIgb24gZXJyb3Jcbn1cblxuZnVuY3Rpb24geGhyKHVybCwgY2FsbGJhY2spIHtcbiAgdmFyIGFzeW5jID0gISFjYWxsYmFjaztcbiAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIC8vIElmIElFIGRvZXMgbm90IHN1cHBvcnQgQ09SUywgdXNlIFhEb21haW5SZXF1ZXN0IChjb3BpZWQgZnJvbSBkMy54aHIpXG4gIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0XG4gICAgICAmJiAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdClcbiAgICAgICYmIC9eKGh0dHAocyk/Oik/XFwvXFwvLy50ZXN0KHVybCkpIHJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3Q7XG5cbiAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgaWYgKCFzdGF0dXMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVxdWVzdCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzeW5jKSB7XG4gICAgXCJvbmxvYWRcIiBpbiByZXF1ZXN0XG4gICAgICA/IHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZFxuICAgICAgOiByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgeyByZXF1ZXN0LnJlYWR5U3RhdGUgPiAzICYmIHJlc3BvbmQoKTsgfTtcbiAgfVxuICBcbiAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgYXN5bmMpO1xuICByZXF1ZXN0LnNlbmQoKTtcbiAgXG4gIGlmICghYXN5bmMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsZShmaWxlLCBjYWxsYmFjaykge1xuICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICB9XG4gIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGUoZmlsZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBodHRwKHVybCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiByZXF1aXJlKCdzeW5jLXJlcXVlc3QnKSgnR0VUJywgdXJsKS5nZXRCb2R5KCk7XG4gIH1cbiAgcmVxdWlyZSgncmVxdWVzdCcpKHVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgaWYgKCFlcnJvciAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxubG9hZC5zYW5pdGl6ZVVybCA9IHNhbml0aXplVXJsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsb2FkID0gcmVxdWlyZSgnLi9sb2FkJyk7XG52YXIgcmVhZCA9IHJlcXVpcmUoJy4vcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxcbiAgLmtleXMocmVhZC5mb3JtYXRzKVxuICAucmVkdWNlKGZ1bmN0aW9uKG91dCwgdHlwZSkge1xuICAgIG91dFt0eXBlXSA9IGZ1bmN0aW9uKG9wdCwgZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgLy8gcHJvY2VzcyBhcmd1bWVudHNcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9wdCkpIG9wdCA9IHt1cmw6IG9wdH07XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB1dGlsLmlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgICBjYWxsYmFjayA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdXAgcmVhZCBmb3JtYXRcbiAgICAgIGZvcm1hdCA9IHV0aWwuZXh0ZW5kKHtwYXJzZTogJ2F1dG8nfSwgZm9ybWF0KTtcbiAgICAgIGZvcm1hdC50eXBlID0gdHlwZTtcblxuICAgICAgLy8gbG9hZCBkYXRhXG4gICAgICB2YXIgZGF0YSA9IGxvYWQob3B0LCBjYWxsYmFjayA/IGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnJvcikgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGRhdGEgbG9hZGVkLCBub3cgcGFyc2UgaXQgKGFzeW5jKVxuICAgICAgICAgIGRhdGEgPSByZWFkKGRhdGEsIGZvcm1hdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgIH0gOiB1bmRlZmluZWQpO1xuICAgICAgXG4gICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChzeW5jKVxuICAgICAgaWYgKGRhdGEpIHJldHVybiByZWFkKGRhdGEsIGZvcm1hdCk7XG4gICAgfTtcbiAgICByZXR1cm4gb3V0O1xuICB9LCB7fSk7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBQQVJTRVJTID0ge1xuICBib29sZWFuOiB1dGlsLmJvb2xlYW4sXG4gIGludGVnZXI6IHV0aWwubnVtYmVyLFxuICBudW1iZXI6ICB1dGlsLm51bWJlcixcbiAgZGF0ZTogICAgdXRpbC5kYXRlLFxuICBzdHJpbmc6ICB1dGlsLmlkZW50aXR5XG59O1xuXG52YXIgVEVTVFMgPSB7XG4gIGJvb2xlYW46IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT1cInRydWVcIiB8fCB4PT09XCJmYWxzZVwiIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbih4KSB7IHJldHVybiBURVNUUy5udW1iZXIoeCkgJiYgKHg9K3gpID09PSB+fng7IH0sXG4gIG51bWJlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH0sXG4gIGRhdGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHgpKTsgfVxufTtcblxuZnVuY3Rpb24gcmVhZChkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIHR5cGUgPSAoZm9ybWF0ICYmIGZvcm1hdC50eXBlKSB8fCBcImpzb25cIjtcbiAgZGF0YSA9IGZvcm1hdHNbdHlwZV0oZGF0YSwgZm9ybWF0KTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucGFyc2UpIHBhcnNlKGRhdGEsIGZvcm1hdC5wYXJzZSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpbmZlcl90eXBlKHZhbHVlcywgZikge1xuICB2YXIgaSwgaiwgdjtcblxuICAvLyB0eXBlcyB0byB0ZXN0IGZvciwgaW4gcHJlY2VkZW5jZSBvcmRlclxuICB2YXIgdHlwZXMgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGdldCBuZXh0IHZhbHVlIHRvIHRlc3RcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICAvLyB0ZXN0IHZhbHVlIGFnYWluc3QgcmVtYWluaW5nIHR5cGVzXG4gICAgZm9yIChqPTA7IGo8dHlwZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh1dGlsLmlzTm90TnVsbCh2KSAmJiAhVEVTVFNbdHlwZXNbal1dKHYpKSB7XG4gICAgICAgIHR5cGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgaiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBubyB0eXBlcyBsZWZ0LCByZXR1cm4gJ3N0cmluZydcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICByZXR1cm4gdHlwZXNbMF07XG59XG5cbmZ1bmN0aW9uIGluZmVyX3R5cGVzKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHZhciB0eXBlID0gaW5mZXJfdHlwZShkYXRhLCB1dGlsLmFjY2Vzc29yKGYpKTtcbiAgICBpZiAoUEFSU0VSU1t0eXBlXSkgdHlwZXNbZl0gPSB0eXBlO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcykge1xuICB2YXIgY29scywgcGFyc2VycywgZCwgaSwgaiwgY2xlbiwgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgdHlwZXMgPSAodHlwZXM9PT0nYXV0bycpID8gaW5mZXJfdHlwZXMoZGF0YSkgOiB1dGlsLmR1cGxpY2F0ZSh0eXBlcyk7XG4gIGNvbHMgPSB1dGlsLmtleXModHlwZXMpO1xuICBwYXJzZXJzID0gY29scy5tYXAoZnVuY3Rpb24oYykgeyByZXR1cm4gUEFSU0VSU1t0eXBlc1tjXV07IH0pO1xuXG4gIGZvciAoaT0wLCBjbGVuPWNvbHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgZCA9IGRhdGFbaV07XG4gICAgZm9yIChqPTA7IGo8Y2xlbjsgKytqKSB7XG4gICAgICBkW2NvbHNbal1dID0gcGFyc2Vyc1tqXShkW2NvbHNbal1dKTtcbiAgICB9XG4gIH1cbiAgZGF0YS50eXBlcyA9IHR5cGVzO1xufVxuXG5yZWFkLnR5cGUgPSBpbmZlcl90eXBlO1xucmVhZC50eXBlcyA9IGluZmVyX3R5cGVzO1xucmVhZC5mb3JtYXRzID0gZm9ybWF0cztcbnJlYWQucGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzID0gcmVhZDtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBkbCA9IHtcbiAgbG9hZDogICAgICByZXF1aXJlKCcuL2ltcG9ydC9sb2FkJyksXG4gIHJlYWQ6ICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZCcpLFxuICBiaW46ICAgICAgIHJlcXVpcmUoJy4vYmluJyksXG4gIGhpc3RvZ3JhbTogcmVxdWlyZSgnLi9oaXN0b2dyYW0nKSxcbiAgc3VtbWFyeTogICByZXF1aXJlKCcuL3N1bW1hcnknKSxcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL3RlbXBsYXRlJyksXG4gIGRhdGV1bml0czogcmVxdWlyZSgnLi9kYXRlLXVuaXRzJylcbn07XG5cbnV0aWwuZXh0ZW5kKGRsLCB1dGlsKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2dlbmVyYXRlJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vc3RhdHMnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9pbXBvcnQvbG9hZGVycycpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkbDsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKTtcbnZhciBzdGF0cyA9IHt9O1xuXG4vLyBDb2xsZWN0IHVuaXF1ZSB2YWx1ZXMgYW5kIGFzc29jaWF0ZWQgY291bnRzLlxuLy8gT3V0cHV0OiBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvYnNlcnZlZCBvcmRlclxuLy8gVGhlIGFycmF5IGluY2x1ZGVzIGFuIGFkZGl0aW9uYWwgJ2NvdW50cycgcHJvcGVydHksXG4vLyB3aGljaCBpcyBhIGhhc2ggZnJvbSB1bmlxdWUgdmFsdWVzIHRvIG9jY3VycmVuY2UgY291bnRzLlxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiBbXTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGk7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkge1xuICAgICAgdVt2XSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB1W3ZdID0gMTtcbiAgICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0cy5jb3VudHMgPSB1O1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwgdmFsdWVzLlxuc3RhdHMuY291bnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIHZhciB2LCBpLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcy5cbnN0YXRzLmNvdW50Lm51bGxzID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdiwgaSwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKGYpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNOb3ROdWxsKS5zb3J0KHV0aWwuY21wKTtcbiAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGgvMik7XG4gIGlmICh2YWx1ZXMubGVuZ3RoICUgMikge1xuICAgIHJldHVybiB2YWx1ZXNbaGFsZl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZXNbaGFsZi0xXSArIHZhbHVlc1toYWxmXSkgLyAyLjA7XG4gIH1cbn07XG5cbi8vIENvbXB1dGUgdGhlIHF1YW50aWxlIG9mIGEgc29ydGVkIGFycmF5IG9mIG51bWJlcnMuXG4vLyBBZGFwdGVkIGZyb20gdGhlIEQzLmpzIGltcGxlbWVudGF0aW9uLlxuc3RhdHMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHApIHtcbiAgaWYgKHAgPT09IHVuZGVmaW5lZCkgeyBwID0gZjsgZiA9IHV0aWwuaWRlbnRpdHk7IH1cbiAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsXG4gICAgICBoID0gTWF0aC5mbG9vcihIKSxcbiAgICAgIHYgPSArZih2YWx1ZXNbaCAtIDFdKSxcbiAgICAgIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChmKHZhbHVlc1toXSkgLSB2KSA6IHY7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiAhPSBudWxsICYmICFpc05hTih2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgdmFyaWFuY2Ugb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgbWVhbiA9IDAsIE0yID0gMCwgZGVsdGEsIGksIGMsIHY7XG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCAmJiAhaXNOYU4odikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG9mIGFuIGFycmF5IG9mIHZhbHVlcy5cbnN0YXRzLmV4dGVudCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzTm90TnVsbCh2KSkgeyBhID0gYiA9IHY7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGEsIGIsIHgsIHksIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc05vdE51bGwodikpIHsgYSA9IGIgPSB2OyB4ID0geSA9IGk7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBcnJheSBsZW5ndGhzIG11c3QgbWF0Y2guXCIpO1xuICAgIH1cbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaV0gKiBhW2ldO1xuICAgICAgaWYgKCFpc05hTih2KSkgc3VtICs9IHY7XG4gICAgfVxuICB9IGVsc2UgeyAgXG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gYSh2YWx1ZXNbaV0pICogYih2YWx1ZXNbaV0pO1xuICAgICAgaWYgKCFpc05hTih2KSkgc3VtICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIGFzY2VuZGluZyByYW5rIHNjb3JlcyBmb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuLy8gVGllcyBhcmUgYXNzaWduZWQgdGhlaXIgY29sbGVjdGl2ZSBtZWFuIHJhbmsuXG5zdGF0cy5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZHg6IGksXG4gICAgICAgIHZhbDogKGYgPyBmKHYpIDogdilcbiAgICAgIH07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoXCJ2YWxcIikpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAoYikgOiBhLFxuICBhID0gZm4gPyB2YWx1ZXMubWFwKGEpIDogdmFsdWVzO1xuXG4gIHZhciBkb3QgPSBzdGF0cy5kb3QoYSwgYiksXG4gICAgICBtdWEgPSBzdGF0cy5tZWFuKGEpLFxuICAgICAgbXViID0gc3RhdHMubWVhbihiKSxcbiAgICAgIHNkYSA9IHN0YXRzLnN0ZGV2KGEpLFxuICAgICAgc2RiID0gc3RhdHMuc3RkZXYoYiksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aDtcblxuICByZXR1cm4gKGRvdCAtIG4qbXVhKm11YikgLyAoKG4tMSkgKiBzZGEgKiBzZGIpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU3BlYXJtYW4gcmFuayBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIHZhbHVlcy5cbnN0YXRzLmNvci5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciByYSA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgYSkgOiBzdGF0cy5yYW5rKHZhbHVlcyksXG4gICAgICByYiA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgYikgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcChhKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcChiKSA6IGE7XG5cbiAgdmFyIEEgPSBzdGF0cy5kaXN0Lm1hdChYKSxcbiAgICAgIEIgPSBzdGF0cy5kaXN0Lm1hdChZKSxcbiAgICAgIG4gPSBBLmxlbmd0aCxcbiAgICAgIGksIGFhLCBiYiwgYWI7XG5cbiAgZm9yIChpPTAsIGFhPTAsIGJiPTAsIGFiPTA7IGk8bjsgKytpKSB7XG4gICAgYWEgKz0gQVtpXSpBW2ldO1xuICAgIGJiICs9IEJbaV0qQltpXTtcbiAgICBhYiArPSBBW2ldKkJbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGFiIC8gTWF0aC5zcXJ0KGFhKmJiKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSB2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBEZWZhdWx0IGlzIEV1Y2xpZGVhbiAoZXhwPTIpIGRpc3RhbmNlLCBjb25maWd1cmFibGUgdmlhIGV4cCBhcmd1bWVudC5cbnN0YXRzLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGV4cCkge1xuICB2YXIgZiA9IHV0aWwuaXNGdW5jdGlvbihiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgcyA9IDAsIGQsIGk7XG5cbiAgaWYgKGUgPT09IDIgfHwgZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgICBzICs9IGQqZDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydChzKTsgXG4gIH0gZWxzZSB7XG4gICAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgICBkID0gTWF0aC5hYnMoZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSkpO1xuICAgICAgcyArPSBNYXRoLnBvdyhkLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucG93KHMsIDEvZSk7XG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdCBhIG1lYW4tY2VudGVyZWQgZGlzdGFuY2UgbWF0cml4IGZvciBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuZGlzdC5tYXQgPSBmdW5jdGlvbihYKSB7XG4gIHZhciBuID0gWC5sZW5ndGgsXG4gICAgICBtID0gbipuLFxuICAgICAgQSA9IEFycmF5KG0pLFxuICAgICAgUiA9IGdlbi56ZXJvcyhuKSxcbiAgICAgIE0gPSAwLCB2LCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIEFbaSpuK2ldID0gMDtcbiAgICBmb3IgKGo9aSsxOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gPSAodiA9IE1hdGguYWJzKFhbaV0gLSBYW2pdKSk7XG4gICAgICBBW2oqbitpXSA9IHY7XG4gICAgICBSW2ldICs9IHY7XG4gICAgICBSW2pdICs9IHY7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgTSArPSBSW2ldO1xuICAgIFJbaV0gLz0gbjtcbiAgfVxuICBNIC89IG07XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZm9yIChqPWk7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSArPSBNIC0gUltpXSAtIFJbal07XG4gICAgICBBW2oqbitpXSA9IEFbaSpuK2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU2hhbm5vbiBlbnRyb3B5IChsb2cgYmFzZSAyKSBvZiBhbiBhcnJheSBvZiBjb3VudHMuXG5zdGF0cy5lbnRyb3B5ID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIHZhciBpLCBwLCBzID0gMCwgSCA9IDAsIE4gPSBjb3VudHMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxOOyArK2kpIHtcbiAgICBzICs9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKTtcbiAgfVxuICBpZiAocyA9PT0gMCkgcmV0dXJuIDA7XG4gIGZvciAoaT0wOyBpPE47ICsraSkge1xuICAgIHAgPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSkgLyBzO1xuICAgIGlmIChwID4gMCkgSCArPSBwICogTWF0aC5sb2cocCkgLyBNYXRoLkxOMjtcbiAgfVxuICByZXR1cm4gLUg7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBub3JtYWxpemVkIFNoYW5ub24gZW50cm9weSAobG9nIGJhc2UgMikgb2YgYW4gYXJyYXkgb2YgY291bnRzLlxuc3RhdHMuZW50cm9weS5ub3JtYWxpemVkID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIHZhciBIID0gc3RhdHMuZW50cm9weShjb3VudHMsIGYpO1xuICByZXR1cm4gSD09PTAgPyAwIDogSCAqIE1hdGguTE4yIC8gTWF0aC5sb2coY291bnRzLmxlbmd0aCk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NdXR1YWxfaW5mb3JtYXRpb25cbnN0YXRzLmVudHJvcHkubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKGEpIDogdmFsdWVzLFxuICAgICAgeSA9IGNvdW50cyA/IHZhbHVlcy5tYXAoYikgOiBhLFxuICAgICAgeiA9IGNvdW50cyA/IHZhbHVlcy5tYXAoY291bnRzKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG5cdCAgICBweSA9IHt9LFxuXHQgICAgaSwgeHgsIHl5LCB6eiwgcyA9IDAsIHQsIE4gPSB6Lmxlbmd0aCwgcCwgSSA9IDA7XG5cblx0Zm9yIChpPTA7IGk8TjsgKytpKSB7XG5cdCAgcHhbeFtpXV0gPSAwO1xuXHQgIHB5W3lbaV1dID0gMDtcbiAgfVxuXG5cdGZvciAoaT0wOyBpPE47ICsraSkge1xuXHRcdHB4W3hbaV1dICs9IHpbaV07XG5cdFx0cHlbeVtpXV0gKz0geltpXTtcblx0XHRzICs9IHpbaV07XG5cdH1cblxuXHR0ID0gMSAvIChzICogTWF0aC5MTjIpO1xuXHRmb3IgKGk9MDsgaTxOOyArK2kpIHtcblx0XHRpZiAoeltpXSA9PT0gMCkgY29udGludWU7XG5cdFx0cCA9IChzICogeltpXSkgLyAocHhbeFtpXV0gKiBweVt5W2ldXSk7XG5cdFx0SSArPSB6W2ldICogdCAqIE1hdGgubG9nKHApO1xuXHR9XG5cblx0cmV0dXJuIEk7XG59O1xuXG4vLyBDb21wdXRlIGEgcHJvZmlsZSBvZiBzdW1tYXJ5IHN0YXRpc3RpY3MgZm9yIGEgdmFyaWFibGUuXG5zdGF0cy5wcm9maWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBwID0ge30sXG4gICAgICBtZWFuID0gMCxcbiAgICAgIGNvdW50ID0gMCxcbiAgICAgIGRpc3RpbmN0ID0gMCxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgTTIgPSAwLFxuICAgICAgdmFscyA9IFtdLFxuICAgICAgdSA9IHt9LCBkZWx0YSwgc2QsIGksIHYsIHgsIGhhbGYsIGgsIGgyO1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuXG4gICAgLy8gdXBkYXRlIHVuaXF1ZSB2YWx1ZXNcbiAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcblxuICAgIGlmICh1dGlsLmlzTm90TnVsbCh2KSkge1xuICAgICAgLy8gdXBkYXRlIG1pbi9tYXhcbiAgICAgIGlmIChtaW49PT1udWxsIHx8IHYgPCBtaW4pIG1pbiA9IHY7XG4gICAgICBpZiAobWF4PT09bnVsbCB8fCB2ID4gbWF4KSBtYXggPSB2O1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2NvdW50KTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoY291bnQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdW5pcXVlOiAgIHUsXG4gICAgY291bnQ6ICAgIGNvdW50LFxuICAgIG51bGxzOiAgICB2YWx1ZXMubGVuZ3RoIC0gY291bnQsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgbW9kZXNrZXc6IHNkID09PSAwID8gMCA6IChtZWFuIC0gdikgLyBzZCxcbiAgICBpcXI6ICAgICAgW3N0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLCBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KV1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcblxuLy8gQ29tcHV0ZSBwcm9maWxlcyBmb3IgYWxsIHZhcmlhYmxlcyBpbiBhIGRhdGEgc2V0LlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG5cbiAgdmFyIHByb2ZpbGVzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuYWNjZXNzb3IoZikpO1xuICAgIHJldHVybiAocC5maWVsZCA9IGYsIHApO1xuICB9KTtcbiAgXG4gIHByb2ZpbGVzLnRvU3RyaW5nID0gcHJpbnRTdW1tYXJ5O1xuICByZXR1cm4gcHJvZmlsZXM7XG59O1xuXG5mdW5jdGlvbiBwcmludFN1bW1hcnkoKSB7XG4gIHZhciBwcm9maWxlcyA9IHRoaXM7XG4gIHZhciBzdHIgPSBbXTtcbiAgcHJvZmlsZXMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgc3RyLnB1c2goXCItLS0tLSBGaWVsZDogJ1wiICsgcC5maWVsZCArIFwiJyAtLS0tLVwiKTtcbiAgICBpZiAodHlwZW9mIHAubWluID09PSAnc3RyaW5nJyB8fCBwLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHApKTtcbiAgICB9XG4gICAgc3RyLnB1c2goXCJcIik7XG4gIH0pO1xuICByZXR1cm4gc3RyLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShwKSB7XG4gIHJldHVybiBbXG4gICAgXCJkaXN0aW5jdDogXCIgKyBwLmRpc3RpbmN0LFxuICAgIFwibnVsbHM6ICAgIFwiICsgcC5udWxscyxcbiAgICBcIm1pbjogICAgICBcIiArIHAubWluLFxuICAgIFwibWF4OiAgICAgIFwiICsgcC5tYXgsXG4gICAgXCJtZWRpYW46ICAgXCIgKyBwLm1lZGlhbixcbiAgICBcIm1lYW46ICAgICBcIiArIHAubWVhbixcbiAgICBcInN0ZGV2OiAgICBcIiArIHAuc3RkZXYsXG4gICAgXCJtb2Rlc2tldzogXCIgKyBwLm1vZGVza2V3XG4gIF0uam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUocCkge1xuICB2YXIgbGlzdCA9IFtcbiAgICBcImRpc3RpbmN0OiBcIiArIHAuZGlzdGluY3QsXG4gICAgXCJudWxsczogICAgXCIgKyBwLm51bGxzLFxuICAgIFwidG9wIHZhbHVlczogXCJcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBcIiAnXCIgKyB2ICsgXCInIChcIiArIHVbdl0gKyBcIilcIjsgfSk7XG4gIHJldHVybiBsaXN0LmNvbmNhdCh0b3ApLmpvaW4oXCJcXG5cIik7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICB1dGlsLnRydW5jYXRlXG59O1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0KSB7XG4gIHZhciBzcmMgPSBzb3VyY2UodGV4dCwgXCJkXCIpO1xuICBzcmMgPSBcInZhciBfX3Q7IHJldHVybiBcIiArIHNyYyArIFwiO1wiO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oXCJkXCIsIHNyYykpLmJpbmQoY29udGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLnNvdXJjZSA9IHNyYztcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbi8vIGNsZWFyIGNhY2hlIG9mIGZvcm1hdCBvYmplY3RzXG4vLyBjYW4gKmJyZWFrKiBwcmlvciB0ZW1wbGF0ZSBmdW5jdGlvbnMsIHNvIGludm9rZSB3aXRoIGNhcmVcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuZnVuY3Rpb24gc291cmNlKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhcmlhYmxlID0gdmFyaWFibGUgfHwgXCJvYmpcIjtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHNyYyA9IFwiJ1wiO1xuICB2YXIgcmVnZXggPSB0ZW1wbGF0ZV9yZTtcblxuICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICB0ZXh0LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBpbnRlcnBvbGF0ZSwgb2Zmc2V0KSB7XG4gICAgc3JjICs9IHRleHRcbiAgICAgIC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgLnJlcGxhY2UodGVtcGxhdGVfZXNjYXBlciwgdGVtcGxhdGVfZXNjYXBlQ2hhcik7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgIHNyYyArPSBcIidcXG4rKChfX3Q9KFwiXG4gICAgICAgICsgdGVtcGxhdGVfdmFyKGludGVycG9sYXRlLCB2YXJpYWJsZSlcbiAgICAgICAgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgIH1cblxuICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gc3JjICsgXCInXCI7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX3Zhcih0ZXh0LCB2YXJpYWJsZSkge1xuICB2YXIgZmlsdGVycyA9IHRleHQuc3BsaXQoJ3wnKTtcbiAgdmFyIHByb3AgPSBmaWx0ZXJzLnNoaWZ0KCkudHJpbSgpO1xuICB2YXIgZm9ybWF0ID0gW107XG4gIHZhciBzdHJpbmdDYXN0ID0gdHJ1ZTtcbiAgXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8IFwiXCI7XG4gICAgaWYgKHN0cmluZ0Nhc3QpIHtcbiAgICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICAgIHNyYyA9IFwiU3RyaW5nKFwiICsgc3JjICsgXCIpXCIgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIFxuICB2YXIgc3JjID0gdXRpbC5maWVsZChwcm9wKS5tYXAodXRpbC5zdHIpLmpvaW4oXCJdW1wiKTtcbiAgc3JjID0gdmFyaWFibGUgKyBcIltcIiArIHNyYyArIFwiXVwiO1xuICBcbiAgZm9yICh2YXIgaT0wOyBpPGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IGZpbHRlcnNbaV0sIGFyZ3MgPSBudWxsLCBwaWR4LCBhLCBiO1xuXG4gICAgaWYgKChwaWR4PWYuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgIGYgPSBmLnNsaWNlKDAsIHBpZHgpO1xuICAgICAgYXJncyA9IGZpbHRlcnNbaV0uc2xpY2UocGlkeCsxKS5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH0pO1xuICAgIH1cbiAgICBmID0gZi50cmltKCk7XG5cbiAgICBzd2l0Y2ggKGYpIHtcbiAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgIHN0cmNhbGwoJy5sZW5ndGgnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9VcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZUxvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cmltJzpcbiAgICAgICAgc3RyY2FsbCgnLnRyaW0oKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgwLCcgKyBhICsgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKC0nICsgYSArJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhICsgdXRpbC5udW1iZXIoYXJnc1sxXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgrJythKycsJytiKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2xpY2UnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgnKyBhXG4gICAgICAgICAgKyAoYXJncy5sZW5ndGggPiAxID8gJywnICsgdXRpbC5udW1iZXIoYXJnc1sxXSkgOiAnJylcbiAgICAgICAgICArICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT1cImxlZnRcIiAmJiBiIT09XCJtaWRkbGVcIiAmJiBiIT09XCJjZW50ZXJcIikgPyBcInJpZ2h0XCIgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy50cnVuY2F0ZSgnICsgc3RyY2FsbCgpICsgJywnICsgYSArICcsXCInICsgYiArICdcIiknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMuZm9ybWF0KTtcbiAgICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK3NyYysnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMudGltZS5mb3JtYXQpO1xuICAgICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrc3JjKycpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihcIlVucmVjb2duaXplZCB0ZW1wbGF0ZSBmaWx0ZXI6IFwiICsgZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNyYztcbn1cblxudmFyIHRlbXBsYXRlX3JlID0gL1xce1xceyguKz8pXFx9XFx9fCQvZztcblxuLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbi8vIHN0cmluZyBsaXRlcmFsLlxudmFyIHRlbXBsYXRlX2VzY2FwZXMgPSB7XG4gIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICdcXHInOiAgICAgJ3InLFxuICAnXFxuJzogICAgICduJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbnZhciB0ZW1wbGF0ZV9lc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZV9lc2NhcGVDaGFyKG1hdGNoKSB7XG4gIHJldHVybiAnXFxcXCcgKyB0ZW1wbGF0ZV9lc2NhcGVzW21hdGNoXTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfZm9ybWF0KHBhdHRlcm4sIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09IFwiJ1wiICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09IFwiJ1wiKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gIT09ICdcIicgJiYgcGF0dGVybltwYXR0ZXJuLmxlbmd0aC0xXSA9PT0gJ1wiJykpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogXCIgKyBwYXR0ZXJuKTtcbiAgfVxuICBpZiAoIWNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSkge1xuICAgIHZhciBmID0gZm10KHBhdHRlcm4pO1xuICAgIHZhciBpID0gY29udGV4dC5mb3JtYXRzLmxlbmd0aDtcbiAgICBjb250ZXh0LmZvcm1hdHMucHVzaChmKTtcbiAgICBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl07XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyB3aGVyZSBhcmUgd2U/XG5cbnUuaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICYmIHR5cGVvZiBwcm9jZXNzLnN0ZGVyciAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudS5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQob2JqKSkgJiYgaXNGaW5pdGUob2JqKTtcbn07XG5cbnUuaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxudS5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzTm90TnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKHR5cGVvZiBvYmogIT09ICdudW1iZXInID8gdHJ1ZSA6ICFpc05hTihvYmopKTtcbn07XG5cbnUuaXNCdWZmZXIgPSAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzID09IG51bGwgPyBudWxsIDogK3M7IH07XG5cbnUuYm9vbGVhbiA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgPT0gbnVsbCA/IG51bGwgOiBzPT09J2ZhbHNlJyA/IGZhbHNlIDogISFzOyB9O1xuXG51LmRhdGUgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzID09IG51bGwgPyBudWxsIDogRGF0ZS5wYXJzZShzKTsgfVxuXG51LmFycmF5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geCAhPSBudWxsID8gKHUuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107IH07XG5cbnUuc3RyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdS5pc0FycmF5KHgpID8gXCJbXCIgKyB4Lm1hcCh1LnN0cikgKyBcIl1cIlxuICAgIDogdS5pc09iamVjdCh4KSA/IEpTT04uc3RyaW5naWZ5KHgpXG4gICAgOiB1LmlzU3RyaW5nKHgpID8gKFwiJ1wiK3V0aWxfZXNjYXBlX3N0cih4KStcIidcIikgOiB4O1xufTtcblxudmFyIGVzY2FwZV9zdHJfcmUgPSAvKF58W15cXFxcXSknL2c7XG5cbmZ1bmN0aW9uIHV0aWxfZXNjYXBlX3N0cih4KSB7XG4gIHJldHVybiB4LnJlcGxhY2UoZXNjYXBlX3N0cl9yZSwgXCIkMVxcXFwnXCIpO1xufVxuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG51LmlkZW50aXR5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcblxudS50cnVlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuXG51LmZhbHNlID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHtcbiAgICByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7XG4gIH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICByZXR1cm4gdmFsdWVzLmpvaW4oXCJ8XCIpO1xufTtcblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBmLnNwbGl0KFwiXFxcXC5cIilcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoXCIuXCIpOyB9KVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoKSB7IGFbYS5sZW5ndGgtMV0gKz0gXCIuXCIgKyBiLnNoaWZ0KCk7IH1cbiAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFtdKTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gKHUuaXNGdW5jdGlvbihmKSB8fCBmPT1udWxsKVxuICAgID8gZiA6IHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMVxuICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7XG4gICAgICAgICAgcmV0dXJuIHhbZl07XG4gICAgICAgIH0sIHgpO1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4geFtmXTsgfTtcbn07XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDFcbiAgICA/IGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICAgIHhbc1tpXV0gPSB2O1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSBcIi1cIikgeyBzID0gLTE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgZWxzZSBpZiAoZlswXSA9PT0gXCIrXCIpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbi8vIEVTNiBjb21wYXRpYmlsaXR5IHBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aCNQb2x5ZmlsbFxuLy8gV2UgY291bGQgaGF2ZSB1c2VkIHRoZSBwb2x5ZmlsbCBjb2RlLCBidXQgbGV0cyB3YWl0IHVudGlsIEVTNiBiZWNvbWVzIGEgc3RhbmRhcmQgZmlyc3RcbnUuc3RhcnRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aFxuICA/IGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XG4gIH1cbiAgOiBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCAwKSA9PT0gMDtcbiAgfTtcblxudS50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVsbGlwc2lzKSA6IFwi4oCmXCI7XG4gIHZhciBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZWxsaXBzaXMubGVuZ3RoKTtcblxuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCwxKSA6IHMuc2xpY2UobGVuLWwpKTtcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgdmFyIGwxID0gTWF0aC5jZWlsKGwvMiksIGwyID0gTWF0aC5mbG9vcihsLzIpO1xuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMSkgOiBzLnNsaWNlKDAsbDEpKSArIGVsbGlwc2lzXG4gICAgICAgICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwyLDEpIDogcy5zbGljZShsZW4tbDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsKSA6IHMuc2xpY2UoMCxsKSkgKyBlbGxpcHNpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJ1bmNhdGVPbldvcmQocywgbGVuLCByZXYpIHtcbiAgdmFyIGNudCA9IDAsIHRvayA9IHMuc3BsaXQodHJ1bmNhdGVfd29yZF9yZSk7XG4gIGlmIChyZXYpIHtcbiAgICBzID0gKHRvayA9IHRvay5yZXZlcnNlKCkpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHRvay5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyBzLmpvaW4oXCJcIikudHJpbSgpIDogdG9rWzBdLnNsaWNlKDAsIGxlbik7XG59XG5cbnZhciB0cnVuY2F0ZV93b3JkX3JlID0gLyhbXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTIwMjhcXHUyMDI5XFx1MzAwMFxcdUZFRkZdKS87XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIGJvdW5kcyA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBpZiAoYikgdGhpcy51bmlvbihiKTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSBib3VuZHMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnkxID0gK051bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueDIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbiAgdGhpcy54MiA9IHgyO1xuICB0aGlzLnkyID0geTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcbiAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgaWYgKHggPiB0aGlzLngyKSB0aGlzLngyID0geDtcbiAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24oZCkge1xuICB0aGlzLngxIC09IGQ7XG4gIHRoaXMueTEgLT0gZDtcbiAgdGhpcy54MiArPSBkO1xuICB0aGlzLnkyICs9IGQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSBNYXRoLmZsb29yKHRoaXMueDEpO1xuICB0aGlzLnkxID0gTWF0aC5mbG9vcih0aGlzLnkxKTtcbiAgdGhpcy54MiA9IE1hdGguY2VpbCh0aGlzLngyKTtcbiAgdGhpcy55MiA9IE1hdGguY2VpbCh0aGlzLnkyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gIHRoaXMueDEgKz0gZHg7XG4gIHRoaXMueDIgKz0gZHg7XG4gIHRoaXMueTEgKz0gZHk7XG4gIHRoaXMueTIgKz0gZHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCB4LCB5KSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICBjeCA9IHggLSB4KmNvcyArIHkqc2luLFxuICAgICAgY3kgPSB5IC0geCpzaW4gLSB5KmNvcyxcbiAgICAgIHgxID0gdGhpcy54MSwgeDIgPSB0aGlzLngyLFxuICAgICAgeTEgPSB0aGlzLnkxLCB5MiA9IHRoaXMueTI7XG5cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIC5hZGQoY29zKngxIC0gc2luKnkxICsgY3gsICBzaW4qeDEgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MiArIGN4LCAgc2luKngxICsgY29zKnkyICsgY3kpXG4gICAgLmFkZChjb3MqeDIgLSBzaW4qeTEgKyBjeCwgIHNpbip4MiArIGNvcyp5MSArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkyICsgY3gsICBzaW4qeDIgKyBjb3MqeTIgKyBjeSk7XG59XG5cbnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKGIpIHtcbiAgaWYgKGIueDEgPCB0aGlzLngxKSB0aGlzLngxID0gYi54MTtcbiAgaWYgKGIueTEgPCB0aGlzLnkxKSB0aGlzLnkxID0gYi55MTtcbiAgaWYgKGIueDIgPiB0aGlzLngyKSB0aGlzLngyID0gYi54MjtcbiAgaWYgKGIueTIgPiB0aGlzLnkyKSB0aGlzLnkyID0gYi55MjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZW5jbG9zZXMgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiBiICYmIChcbiAgICB0aGlzLngxIDw9IGIueDEgJiZcbiAgICB0aGlzLngyID49IGIueDIgJiZcbiAgICB0aGlzLnkxIDw9IGIueTEgJiZcbiAgICB0aGlzLnkyID49IGIueTJcbiAgKTtcbn07XG5cbnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAhKFxuICAgIHRoaXMueDIgPCBiLngxIHx8XG4gICAgdGhpcy54MSA+IGIueDIgfHxcbiAgICB0aGlzLnkyIDwgYi55MSB8fFxuICAgIHRoaXMueTEgPiBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiAhKFxuICAgIHggPCB0aGlzLngxIHx8XG4gICAgeCA+IHRoaXMueDIgfHxcbiAgICB5IDwgdGhpcy55MSB8fFxuICAgIHkgPiB0aGlzLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55MiAtIHRoaXMueTE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2NhbnZhcy9pbmRleCcpLFxuICAgIHN2ZyA9IHJlcXVpcmUoJy4uL3JlbmRlci9zdmctaGVhZGxlc3MvaW5kZXgnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbnZhciBIZWFkbGVzc1ZpZXcgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBtb2RlbCkge1xuICBWaWV3LmNhbGwobnVsbCwgd2lkdGgsIGhlaWdodCwgbW9kZWwpO1xuICB0aGlzLl9lbCA9IFwiYm9keVwiO1xuICB0aGlzLl90eXBlID0gXCJjYW52YXNcIjtcbiAgdGhpcy5fcmVuZGVyZXJzID0ge2NhbnZhczogY2FudmFzLCBzdmc6IHN2Z307XG4gIHRoaXMuX2NhbnZhcyA9IG51bGw7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoSGVhZGxlc3NWaWV3LnByb3RvdHlwZSA9IG5ldyBWaWV3KCkpO1xuXG5wcm90b3R5cGUucmVuZGVyZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmKHR5cGUpIHRoaXMuX3R5cGUgPSB0eXBlO1xuICByZXR1cm4gVmlldy5wcm90b3R5cGUucmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvdHlwZS5jYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbn07XG5cbnByb3RvdHlwZS5jYW52YXNBc3luYyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciByID0gdGhpcy5fcmVuZGVyZXIsIHZpZXcgPSB0aGlzO1xuICBcbiAgZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoci5wZW5kaW5nSW1hZ2VzKCkgPT09IDApIHtcbiAgICAgIHZpZXcucmVuZGVyKCk7IC8vIHJlLXJlbmRlciB3aXRoIGFsbCBpbWFnZXNcbiAgICAgIGNhbGxiYWNrKHZpZXcuX2NhbnZhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQod2FpdCwgMTApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGltYWdlcyBsb2FkaW5nLCBwb2xsIHVudGlsIHJlYWR5XG4gIChyLnBlbmRpbmdJbWFnZXMoKSA+IDApID8gd2FpdCgpIDogY2FsbGJhY2sodGhpcy5fY2FudmFzKTtcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl90eXBlID09PSBcInN2Z1wiKVxuICAgID8gdGhpcy5fcmVuZGVyZXIuc3ZnKClcbiAgICA6IG51bGw7XG59O1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkgeyAgICBcbiAgdmFyIHcgPSB0aGlzLl93aWR0aCxcbiAgICAgIGggPSB0aGlzLl9oZWlnaHQsXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nO1xuXG4gIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgIHcgPSB0aGlzLl92aWV3cG9ydFswXSAtIChwYWQgPyBwYWQubGVmdCArIHBhZC5yaWdodCA6IDApO1xuICAgIGggPSB0aGlzLl92aWV3cG9ydFsxXSAtIChwYWQgPyBwYWQudG9wICsgcGFkLmJvdHRvbSA6IDApO1xuICB9XG5cbiAgdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciB8fCBuZXcgdGhpcy5faW8uUmVuZGVyZXIoKTtcbiAgXG4gIGlmICh0aGlzLl90eXBlID09PSBcInN2Z1wiKSB7XG4gICAgdGhpcy5pbml0U1ZHKHcsIGgsIHBhZCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbml0Q2FudmFzKHcsIGgsIHBhZCk7XG4gIH1cbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmluaXRDYW52YXMgPSBmdW5jdGlvbih3LCBoLCBwYWQpIHtcbiAgdmFyIENhbnZhcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmNhbnZhcyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuY2FudmFzIDogbnVsbCksXG4gICAgICB0dyA9IHcgKyBwYWQubGVmdCArIHBhZC5yaWdodCxcbiAgICAgIHRoID0gaCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICAgICAgY2FudmFzID0gdGhpcy5fY2FudmFzID0gZGwuaXNOb2RlID8gbmV3IENhbnZhcyh0dywgdGgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gIGlmKCFkbC5pc05vZGUpIHsgIC8vIE1hbnVhbGx5IHNldCB3aWR0aC9oZWlnaHQgb24gRE9NIGVsZW1lbnRzXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHR3KTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoKTtcbiAgfVxuICBcbiAgLy8gc2V0dXAgY2FudmFzIGNvbnRleHRcbiAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBwYWQubGVmdCwgcGFkLnRvcCk7XG5cbiAgLy8gY29uZmlndXJlIHJlbmRlcmVyXG4gIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQoY3R4KTtcbiAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHcsIGgsIHBhZCk7XG59O1xuXG5wcm90b3R5cGUuaW5pdFNWRyA9IGZ1bmN0aW9uKHcsIGgsIHBhZCkge1xuICAvLyBjb25maWd1cmUgcmVuZGVyZXJcbiAgdGhpcy5fcmVuZGVyZXIuaW5pdGlhbGl6ZSh0aGlzLl9lbCwgdywgaCwgcGFkKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGxlc3NWaWV3O1xuIiwidmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvR3JhcGgnKSwgXG4gICAgTm9kZSAgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgR3JvdXBCdWlsZGVyID0gcmVxdWlyZSgnLi4vc2NlbmUvR3JvdXBCdWlsZGVyJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksIFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5mdW5jdGlvbiBNb2RlbCgpIHtcbiAgdGhpcy5fZGVmcyA9IHt9O1xuICB0aGlzLl9wcmVkaWNhdGVzID0ge307XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcblxuICB0aGlzLl9ub2RlID0gbnVsbDtcbiAgdGhpcy5fYnVpbGRlciA9IG51bGw7IC8vIFRvcC1sZXZlbCBzY2VuZWdyYXBoIGJ1aWxkZXJcblxuICBHcmFwaC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xufTtcblxudmFyIHByb3RvID0gKE1vZGVsLnByb3RvdHlwZSA9IG5ldyBHcmFwaCgpKTtcblxucHJvdG8uZGVmcyA9IGZ1bmN0aW9uKGRlZnMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGVmcztcbiAgdGhpcy5fZGVmcyA9IGRlZnM7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ubm9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZSB8fCAodGhpcy5fbm9kZSA9IG5ldyBOb2RlKHRoaXMpKTtcbn07XG5cbnByb3RvLmRhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBHcmFwaC5wcm90b3R5cGUuZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkgeyAgLy8gbmV3IERhdGFzb3VyY2VcbiAgICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcihkYXRhLnBpcGVsaW5lKClbMF0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5mdW5jdGlvbiBwcmVkaWNhdGVzKG5hbWUpIHtcbiAgdmFyIG0gPSB0aGlzLCBwcmVkaWNhdGVzID0ge307XG4gIGlmKCFkbC5pc0FycmF5KG5hbWUpKSByZXR1cm4gdGhpcy5fcHJlZGljYXRlc1tuYW1lXTtcbiAgbmFtZS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHsgcHJlZGljYXRlc1tuXSA9IG0uX3ByZWRpY2F0ZXNbbl0gfSk7XG4gIHJldHVybiBwcmVkaWNhdGVzO1xufVxuXG5wcm90by5wcmVkaWNhdGUgPSBmdW5jdGlvbihuYW1lLCBwcmVkaWNhdGUpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHByZWRpY2F0ZXMuY2FsbCh0aGlzLCBuYW1lKTtcbiAgcmV0dXJuICh0aGlzLl9wcmVkaWNhdGVzW25hbWVdID0gcHJlZGljYXRlKTtcbn07XG5cbnByb3RvLnByZWRpY2F0ZXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZXM7IH07XG5cbnByb3RvLnNjZW5lID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgaWYodGhpcy5fYnVpbGRlcikgdGhpcy5ub2RlKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5fYnVpbGRlci5kaXNjb25uZWN0KCkpO1xuICB0aGlzLl9idWlsZGVyID0gbmV3IEdyb3VwQnVpbGRlcih0aGlzLCB0aGlzLl9kZWZzLm1hcmtzLCB0aGlzLl9zY2VuZT17fSk7XG4gIHRoaXMubm9kZSgpLmFkZExpc3RlbmVyKHRoaXMuX2J1aWxkZXIuY29ubmVjdCgpKTtcbiAgdmFyIHAgPSB0aGlzLl9idWlsZGVyLnBpcGVsaW5lKCk7XG4gIHBbcC5sZW5ndGgtMV0uYWRkTGlzdGVuZXIocmVuZGVyZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkgeyB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcihsKTsgfTtcbnByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obCkgeyB0aGlzLm5vZGUoKS5yZW1vdmVMaXN0ZW5lcihsKTsgfTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmKCFjcykgY3MgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gIHRoaXMucHJvcGFnYXRlKGNzLCB0aGlzLm5vZGUoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgcGFyc2VTdHJlYW1zID0gcmVxdWlyZSgnLi4vcGFyc2Uvc3RyZWFtcycpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvaW5kZXgnKSxcbiAgICBzdmcgPSByZXF1aXJlKCcuLi9yZW5kZXIvc3ZnL2luZGV4JyksXG4gICAgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL3NjZW5lL1RyYW5zaXRpb24nKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpO1xuXG52YXIgVmlldyA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBtb2RlbCkge1xuICB0aGlzLl9lbCAgICA9IG51bGw7XG4gIHRoaXMuX21vZGVsID0gbnVsbDtcbiAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aCB8fCA1MDA7XG4gIHRoaXMuX2hlaWdodCA9IHRoaXMuX19oZWlnaHQgPSBoZWlnaHQgfHwgMzAwO1xuICB0aGlzLl9hdXRvcGFkID0gMTtcbiAgdGhpcy5fcGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHRoaXMuX3ZpZXdwb3J0ID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVyID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZXJzID0ge2NhbnZhczogY2FudmFzLCBzdmc6IHN2Z307XG4gIHRoaXMuX2lvID0gY2FudmFzO1xufTtcblxudmFyIHByb3RvdHlwZSA9IFZpZXcucHJvdG90eXBlO1xuXG5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihtb2RlbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgaWYgKHRoaXMuX21vZGVsICE9PSBtb2RlbCkge1xuICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIubW9kZWwobW9kZWwpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtID0gdGhpcy5tb2RlbCgpO1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtLmRhdGEoKTtcbiAgZGwua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgbS5kYXRhKGQpLmFkZChkbC5kdXBsaWNhdGUoZGF0YVtkXSkpOyB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9fd2lkdGg7XG4gIGlmICh0aGlzLl9fd2lkdGggIT09IHdpZHRoKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fc3RyaWN0KSB0aGlzLl9hdXRvcGFkID0gMTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fX2hlaWdodDtcbiAgaWYgKHRoaXMuX19oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX3N0cmljdCkgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICBpZiAodGhpcy5fcGFkZGluZyAhPT0gcGFkKSB7XG4gICAgaWYgKGRsLmlzU3RyaW5nKHBhZCkpIHtcbiAgICAgIHRoaXMuX2F1dG9wYWQgPSAxO1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gICAgICB0aGlzLl9zdHJpY3QgPSAocGFkID09PSBcInN0cmljdFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDA7XG4gICAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgICAgdGhpcy5fc3RyaWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbCkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHBhZCk7XG4gICAgICBpZih0aGlzLl9oYW5kbGVyKSB0aGlzLl9oYW5kbGVyLnBhZGRpbmcocGFkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYXV0b3BhZCA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAodGhpcy5fYXV0b3BhZCA8IDEpIHJldHVybiB0aGlzO1xuICBlbHNlIHRoaXMuX2F1dG9wYWQgPSAwO1xuXG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IHRoaXMubW9kZWwoKS5zY2VuZSgpLmJvdW5kcyxcbiAgICAgIGluc2V0ID0gY29uZmlnLmF1dG9wYWRJbnNldCxcbiAgICAgIGwgPSBiLngxIDwgMCA/IE1hdGguY2VpbCgtYi54MSkgKyBpbnNldCA6IDAsXG4gICAgICB0ID0gYi55MSA8IDAgPyBNYXRoLmNlaWwoLWIueTEpICsgaW5zZXQgOiAwLFxuICAgICAgciA9IGIueDIgPiB0aGlzLl93aWR0aCAgPyBNYXRoLmNlaWwoK2IueDIgLSB0aGlzLl93aWR0aCkgKyBpbnNldCA6IDAsXG4gICAgICBiID0gYi55MiA+IHRoaXMuX2hlaWdodCA/IE1hdGguY2VpbCgrYi55MiAtIHRoaXMuX2hlaWdodCkgKyBpbnNldCA6IDA7XG4gIHBhZCA9IHtsZWZ0OmwsIHRvcDp0LCByaWdodDpyLCBib3R0b206Yn07XG5cbiAgaWYgKHRoaXMuX3N0cmljdCkge1xuICAgIHRoaXMuX2F1dG9wYWQgPSAwO1xuICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgdGhpcy5fd2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9fd2lkdGggLSAobCtyKSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5tYXgoMCwgdGhpcy5fX2hlaWdodCAtICh0K2IpKTtcbiAgICB0aGlzLl9tb2RlbC53aWR0aCh0aGlzLl93aWR0aCk7XG4gICAgdGhpcy5fbW9kZWwuaGVpZ2h0KHRoaXMuX2hlaWdodCk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhZGRpbmcocGFkKS51cGRhdGUob3B0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gIGlmICh0aGlzLl92aWV3cG9ydCAhPT0gc2l6ZSkge1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gc2l6ZTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gIGlmICh0aGlzLl9yZW5kZXJlcnNbdHlwZV0pIHR5cGUgPSB0aGlzLl9yZW5kZXJlcnNbdHlwZV07XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJlbmRlcmVyOiBcIiArIHR5cGUpO1xuICBlbHNlIGlmICghdHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVuZGVyZXIgc3BlY2lmaWVkXCIpO1xuXG4gIGlmICh0aGlzLl9pbyAhPT0gdHlwZSkge1xuICAgIHRoaXMuX2lvID0gdHlwZTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX2J1aWxkKSB0aGlzLnJlbmRlcigpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCkge1xuICB2YXIgdiA9IHRoaXMsIHByZXZIYW5kbGVyLFxuICAgICAgdyA9IHYuX3dpZHRoLCBoID0gdi5faGVpZ2h0LCBwYWQgPSB2Ll9wYWRkaW5nO1xuXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCBlbCA9PT0gbnVsbCkge1xuICAgIGVsID0gdGhpcy5fZWwgPyB0aGlzLl9lbC5wYXJlbnROb2RlIDogbnVsbDtcbiAgICBpZighZWwpIHJldHVybiB0aGlzOyAgLy8gVGhpcyBWaWV3IGNhbm5vdCBpbml0IHcvbyBhblxuICB9XG4gIFxuICAvLyBjbGVhciBwcmUtZXhpc3RpbmcgY29udGFpbmVyXG4gIGQzLnNlbGVjdChlbCkuc2VsZWN0KFwiZGl2LnZlZ2FcIikucmVtb3ZlKCk7XG4gIFxuICAvLyBhZGQgZGl2IGNvbnRhaW5lclxuICB0aGlzLl9lbCA9IGVsID0gZDMuc2VsZWN0KGVsKVxuICAgIC5hcHBlbmQoXCJkaXZcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwidmVnYVwiKVxuICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcbiAgICAubm9kZSgpO1xuICBpZiAodi5fdmlld3BvcnQpIHtcbiAgICBkMy5zZWxlY3QoZWwpXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAgKHYuX3ZpZXdwb3J0WzBdIHx8IHcpK1wicHhcIilcbiAgICAgIC5zdHlsZShcImhlaWdodFwiLCAodi5fdmlld3BvcnRbMV0gfHwgaCkrXCJweFwiKVxuICAgICAgLnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICB9XG5cbiAgLy8gcmVuZGVyZXJcbiAgdi5fcmVuZGVyZXIgPSAodi5fcmVuZGVyZXIgfHwgbmV3IHRoaXMuX2lvLlJlbmRlcmVyKCkpXG4gICAgLmluaXRpYWxpemUoZWwsIHcsIGgsIHBhZCk7XG4gIFxuICAvLyBpbnB1dCBoYW5kbGVyXG4gIHByZXZIYW5kbGVyID0gdi5faGFuZGxlcjtcbiAgdi5faGFuZGxlciA9IG5ldyB0aGlzLl9pby5IYW5kbGVyKClcbiAgICAuaW5pdGlhbGl6ZShlbCwgcGFkLCB2KVxuICAgIC5tb2RlbCh2Ll9tb2RlbCk7XG5cbiAgaWYgKHByZXZIYW5kbGVyKSB7XG4gICAgcHJldkhhbmRsZXIuaGFuZGxlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgIHYuX2hhbmRsZXIub24oaC50eXBlLCBoLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBmb3Igc2lnbmFsIHN0cmVhbSBkZWZpbml0aW9ucy5cbiAgICBwYXJzZVN0cmVhbXModGhpcyk7XG4gIH1cbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG9wdCkgeyAgICBcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgdiA9IHRoaXMsXG4gICAgICB0cmFucyA9IG9wdC5kdXJhdGlvblxuICAgICAgICA/IG5ldyBUcmFuc2l0aW9uKG9wdC5kdXJhdGlvbiwgb3B0LmVhc2UpXG4gICAgICAgIDogbnVsbDtcblxuICAvLyBUT0RPOiB3aXRoIHN0cmVhbWluZyBkYXRhIEFQSSwgYWRkcyBzaG91bGQgZGwuZHVwbGljYXRlIGp1c3QgcGFyc2VTcGVjXG4gIC8vIHRvIHByZXZlbnQgVmVnYSBmcm9tIHBvbGx1dGluZyB0aGUgZW52aXJvbm1lbnQuXG5cbiAgdmFyIGNzID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuICBpZih0cmFucykgY3MudHJhbnMgPSB0cmFucztcbiAgaWYob3B0LnJlZmxvdyAhPT0gdW5kZWZpbmVkKSBjcy5yZWZsb3cgPSBvcHQucmVmbG93XG5cbiAgaWYoIXYuX2J1aWxkKSB7XG4gICAgdi5fcmVuZGVyTm9kZSA9IG5ldyBOb2RlKHYuX21vZGVsKVxuICAgICAgLnJvdXRlcih0cnVlKTtcblxuICAgIHYuX3JlbmRlck5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgZGVidWcoaW5wdXQsIFtcInJlbmRlcmluZ1wiXSk7XG5cbiAgICAgIHZhciBzID0gdi5fbW9kZWwuc2NlbmUoKTtcbiAgICAgIGlmKGlucHV0LnRyYW5zKSB7XG4gICAgICAgIGlucHV0LnRyYW5zLnN0YXJ0KGZ1bmN0aW9uKGl0ZW1zKSB7IHYuX3JlbmRlcmVyLnJlbmRlcihzLCBpdGVtcyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi5fcmVuZGVyZXIucmVuZGVyKHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgYWxsIHVwZGF0ZWQgZGF0YXNvdXJjZXMsIGZpbmFsaXplIHRoZWlyIGNoYW5nZXNldHMuXG4gICAgICB2YXIgZCwgZHM7XG4gICAgICBmb3IoZCBpbiBpbnB1dC5kYXRhKSB7XG4gICAgICAgIGRzID0gdi5fbW9kZWwuZGF0YShkKTtcbiAgICAgICAgaWYoIWRzLnJldmlzZXMoKSkgY29udGludWU7XG4gICAgICAgIGNoYW5nZXNldC5maW5hbGl6ZShkcy5sYXN0KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfTtcblxuICAgIHYuX21vZGVsLnNjZW5lKHYuX3JlbmRlck5vZGUpO1xuICAgIHYuX2J1aWxkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFB1bHNlIHRoZSBlbnRpcmUgbW9kZWwgKERhdGFzb3VyY2VzICsgc2NlbmUpLlxuICB2Ll9tb2RlbC5maXJlKGNzKTtcblxuICByZXR1cm4gdi5hdXRvcGFkKG9wdCk7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX21vZGVsLnNjZW5lKCksIGl0ZW1zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vbi5hcHBseSh0aGlzLl9oYW5kbGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vZmYuYXBwbHkodGhpcy5faGFuZGxlciwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WaWV3LmZhY3RvcnkgPSBmdW5jdGlvbihtb2RlbCkge1xuICB2YXIgSGVhZGxlc3NWaWV3ID0gcmVxdWlyZSgnLi9IZWFkbGVzc1ZpZXcnKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB2YXIgZGVmcyA9IG1vZGVsLmRlZnMoKTtcbiAgICB2YXIgdiA9IChvcHQuZWwgPyBuZXcgVmlldygpIDogbmV3IEhlYWRsZXNzVmlldygpKVxuICAgICAgLm1vZGVsKG1vZGVsKVxuICAgICAgLnJlbmRlcmVyKG9wdC5yZW5kZXJlciB8fCBcImNhbnZhc1wiKVxuICAgICAgLndpZHRoKGRlZnMud2lkdGgpXG4gICAgICAuaGVpZ2h0KGRlZnMuaGVpZ2h0KVxuICAgICAgLnBhZGRpbmcoZGVmcy5wYWRkaW5nKTtcblxuICAgIGlmKG9wdC5lbCB8fCAoIW9wdC5lbCAmJiB2IGluc3RhbmNlb2YgSGVhZGxlc3NWaWV3KSkgdi5pbml0aWFsaXplKG9wdC5lbCk7XG4gICAgaWYob3B0LmRhdGEpIHYuZGF0YShvcHQuZGF0YSk7XG4gIFxuICAgIHJldHVybiB2O1xuICB9OyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldztcbiIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gQ29sbGVjdG9yKGdyYXBoKSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX2RhdGEgPSBbXTtcbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKENvbGxlY3Rvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uZGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJjb2xsZWN0aW5nXCJdKTtcblxuICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgaW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcbiAgICBpbnB1dC5tb2QgPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgaWYgKGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICB2YXIgaWRzID0gaW5wdXQucmVtLnJlZHVjZShmdW5jdGlvbihtLHgpIHsgcmV0dXJuIChtW3guX2lkXT0xLCBtKTsgfSwge30pO1xuICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBpZHNbeC5faWRdICE9PSAxOyB9KTtcbiAgfVxuXG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoKSB7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEubGVuZ3RoID8gdGhpcy5fZGF0YS5jb25jYXQoaW5wdXQuYWRkKSA6IGlucHV0LmFkZDtcbiAgfVxuXG4gIGlmIChpbnB1dC5zb3J0KSB7XG4gICAgdGhpcy5fZGF0YS5zb3J0KGlucHV0LnNvcnQpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0JyksIFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi90dXBsZScpLCBcbiAgICBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRGF0YXNvdXJjZShncmFwaCwgbmFtZSwgZmFjZXQpIHtcbiAgdGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2RhdGEgPSBbXTtcbiAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgdGhpcy5fZmFjZXQgPSBmYWNldDtcbiAgdGhpcy5faW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gIHRoaXMuX291dHB1dCA9IG51bGw7ICAgIC8vIE91dHB1dCBjaGFuZ2VzZXRcblxuICB0aGlzLl9waXBlbGluZSAgPSBudWxsOyAvLyBQaXBlbGluZSBvZiB0cmFuc2Zvcm1hdGlvbnMuXG4gIHRoaXMuX2NvbGxlY3RvciA9IG51bGw7IC8vIENvbGxlY3RvciB0byBtYXRlcmlhbGl6ZSBvdXRwdXQgb2YgcGlwZWxpbmVcbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAvLyBEb2VzIGFueSBwaXBlbGluZSBvcGVyYXRvciBuZWVkIHRvIHRyYWNrIHByZXY/XG59O1xuXG52YXIgcHJvdG8gPSBEYXRhc291cmNlLnByb3RvdHlwZTtcblxucHJvdG8ubmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9uYW1lO1xuICByZXR1cm4gKHRoaXMuX25hbWUgPSBuYW1lLCB0aGlzKTtcbn07XG5cbnByb3RvLnNvdXJjZSA9IGZ1bmN0aW9uKHNyYykge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgcmV0dXJuICh0aGlzLl9zb3VyY2UgPSB0aGlzLl9ncmFwaC5kYXRhKHNyYykpO1xufTtcblxucHJvdG8uYWRkID0gZnVuY3Rpb24oZCkge1xuICB2YXIgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX2lucHV0LmFkZCA9IHRoaXMuX2lucHV0LmFkZFxuICAgIC5jb25jYXQoZGwuYXJyYXkoZCkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHR1cGxlLmluZ2VzdChkLCBwcmV2KTsgfSkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gIHZhciBkID0gdGhpcy5fZGF0YS5maWx0ZXIod2hlcmUpO1xuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9pbnB1dC5yZW0uY29uY2F0KGQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKHdoZXJlLCBmaWVsZCwgZnVuYykge1xuICB2YXIgbW9kID0gdGhpcy5faW5wdXQubW9kLFxuICAgICAgaWRzID0gdHVwbGUuaWRNYXAobW9kKSxcbiAgICAgIHByZXYgPSB0aGlzLl9yZXZpc2VzID8gbnVsbCA6IHVuZGVmaW5lZDsgXG5cbiAgdGhpcy5faW5wdXQuZmllbGRzW2ZpZWxkXSA9IDE7XG4gIHRoaXMuX2RhdGEuZmlsdGVyKHdoZXJlKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcHJldiA9IHhbZmllbGRdLFxuICAgICAgICBuZXh0ID0gZnVuYyh4KTtcbiAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgdHVwbGUuc2V0KHgsIGZpZWxkLCBuZXh0KTtcbiAgICAgIGlmKGlkc1t4Ll9pZF0gIT09IDEpIHtcbiAgICAgICAgbW9kLnB1c2goeCk7XG4gICAgICAgIGlkc1t4Ll9pZF0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udmFsdWVzID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdG9yID8gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSA6IHRoaXMuX2RhdGE7XG5cbiAgLy8gUmVwbGFjZSBiYWNraW5nIGRhdGFcbiAgdGhpcy5faW5wdXQucmVtID0gdGhpcy5fZGF0YS5zbGljZSgpO1xuICBpZiAoZGF0YSkgeyB0aGlzLmFkZChkYXRhKTsgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHNldF9wcmV2KGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfVxuXG5wcm90by5yZXZpc2VzID0gZnVuY3Rpb24ocCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JldmlzZXM7XG5cbiAgLy8gSWYgd2UndmUgbm90IG5lZWRlZCBwcmV2IGluIHRoZSBwYXN0LCBidXQgYSBuZXcgZGF0YWZsb3cgbm9kZSBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIHR1cGxlcyBoYXZlIHByZXYgc2V0LlxuICBpZighdGhpcy5fcmV2aXNlcyAmJiBwKSB7XG4gICAgdGhpcy5fZGF0YS5mb3JFYWNoKHNldF9wcmV2KTtcbiAgICB0aGlzLl9pbnB1dC5hZGQuZm9yRWFjaChzZXRfcHJldik7IC8vIE5ldyB0dXBsZXMgdGhhdCBoYXZlbid0IHlldCBiZWVuIG1lcmdlZCBpbnRvIF9kYXRhXG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX291dHB1dDsgfTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmKGlucHV0KSB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUodGhpcy5faW5wdXQsIHRoaXMuX3BpcGVsaW5lWzBdKTsgXG59O1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gIHZhciBkcyA9IHRoaXMsIG4sIGM7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG5cbiAgaWYocGlwZWxpbmUubGVuZ3RoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBpcGVsaW5lLCBhZGQgYSBjb2xsZWN0b3IgdG8gdGhlIGVuZCB0byBtYXRlcmlhbGl6ZVxuICAgIC8vIHRoZSBvdXRwdXQuXG4gICAgZHMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IodGhpcy5fZ3JhcGgpO1xuICAgIHBpcGVsaW5lLnB1c2goZHMuX2NvbGxlY3Rvcik7XG4gICAgZHMuX3JldmlzZXMgPSBwaXBlbGluZS5zb21lKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAucmV2aXNlcygpOyB9KTtcbiAgfVxuXG4gIC8vIElucHV0IG5vZGUgYXBwbGllcyB0aGUgZGF0YXNvdXJjZSdzIGRlbHRhLCBhbmQgcHJvcGFnYXRlcyBpdCB0byBcbiAgLy8gdGhlIHJlc3Qgb2YgdGhlIHBpcGVsaW5lLiBJdCByZWNlaXZlcyB0b3VjaGVzIHRvIHJlZmxvdyBkYXRhLlxuICB2YXIgaW5wdXQgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBpbnB1dC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcImlucHV0XCIsIGRzLl9uYW1lXSk7XG5cbiAgICB2YXIgZGVsdGEgPSBkcy5faW5wdXQsIFxuICAgICAgICBvdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgICAgcmVtO1xuXG4gICAgLy8gRGVsdGEgbWlnaHQgY29udGFpbiBmaWVsZHMgdXBkYXRlZCB0aHJvdWdoIEFQSVxuICAgIGRsLmtleXMoZGVsdGEuZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHsgb3V0LmZpZWxkc1tmXSA9IDEgfSk7XG5cbiAgICBpZihpbnB1dC5yZWZsb3cpIHtcbiAgICAgIG91dC5tb2QgPSBkcy5fZGF0YS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgZGF0YVxuICAgICAgaWYoZGVsdGEucmVtLmxlbmd0aCkge1xuICAgICAgICByZW0gPSB0dXBsZS5pZE1hcChkZWx0YS5yZW0pO1xuICAgICAgICBkcy5fZGF0YSA9IGRzLl9kYXRhXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW1beC5faWRdICE9PSAxIH0pO1xuICAgICAgfVxuXG4gICAgICBpZihkZWx0YS5hZGQubGVuZ3RoKSBkcy5fZGF0YSA9IGRzLl9kYXRhLmNvbmNhdChkZWx0YS5hZGQpO1xuXG4gICAgICAvLyByZXNldCBjaGFuZ2UgbGlzdFxuICAgICAgZHMuX2lucHV0ID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuXG4gICAgICBvdXQuYWRkID0gZGVsdGEuYWRkOyBcbiAgICAgIG91dC5tb2QgPSBkZWx0YS5tb2Q7XG4gICAgICBvdXQucmVtID0gZGVsdGEucmVtO1xuICAgIH1cblxuICAgIHJldHVybiAob3V0LmZhY2V0ID0gZHMuX2ZhY2V0LCBvdXQpO1xuICB9O1xuXG4gIHBpcGVsaW5lLnVuc2hpZnQoaW5wdXQpO1xuXG4gIC8vIE91dHB1dCBub2RlIGNhcHR1cmVzIHRoZSBsYXN0IGNoYW5nZXNldCBzZWVuIGJ5IHRoaXMgZGF0YXNvdXJjZVxuICAvLyAobmVlZGVkIGZvciBqb2lucyBhbmQgYnVpbGRzKSBhbmQgbWF0ZXJpYWxpemVzIGFueSBuZXN0ZWQgZGF0YS5cbiAgLy8gSWYgdGhpcyBkYXRhc291cmNlIGlzIGZhY2V0ZWQsIG1hdGVyaWFsaXplcyB0aGUgdmFsdWVzIGluIHRoZSBmYWNldC5cbiAgdmFyIG91dHB1dCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIG91dHB1dC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcIm91dHB1dFwiLCBkcy5fbmFtZV0pO1xuICAgIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0LCB0cnVlKTtcblxuICAgIGlmKGRzLl9mYWNldCkge1xuICAgICAgZHMuX2ZhY2V0LnZhbHVlcyA9IGRzLnZhbHVlcygpO1xuICAgICAgaW5wdXQuZmFjZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGRzLl9vdXRwdXQgPSBpbnB1dDtcbiAgICBvdXRwdXQuZGF0YVtkcy5fbmFtZV0gPSAxO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgcGlwZWxpbmUucHVzaChvdXRwdXQpO1xuXG4gIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QoZHMuX3BpcGVsaW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5saXN0ZW5lciA9IGZ1bmN0aW9uKCkgeyBcbiAgdmFyIGwgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCkucm91dGVyKHRydWUpLFxuICAgICAgZGVzdCA9IHRoaXMsXG4gICAgICBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQ7XG5cbiAgbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVzdC5fc3JjTWFwID0gZGVzdC5fc3JjTWFwIHx8IHt9OyAgLy8gdG8gcHJvcGFnYXRlIHR1cGxlcyBjb3JyZWN0bHlcbiAgICB2YXIgbWFwID0gZGVzdC5fc3JjTWFwLFxuICAgICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgICBvdXRwdXQuYWRkID0gaW5wdXQuYWRkLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gKG1hcFt0Ll9pZF0gPSB0dXBsZS5kZXJpdmUodCwgdC5fcHJldiAhPT0gdW5kZWZpbmVkID8gdC5fcHJldiA6IHByZXYpKTtcbiAgICB9KTtcbiAgICBvdXRwdXQubW9kID0gaW5wdXQubW9kLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBtYXBbdC5faWRdOyB9KTtcbiAgICBvdXRwdXQucmVtID0gaW5wdXQucmVtLm1hcChmdW5jdGlvbih0KSB7IFxuICAgICAgdmFyIG8gPSBtYXBbdC5faWRdO1xuICAgICAgbWFwW3QuX2lkXSA9IG51bGw7XG4gICAgICByZXR1cm4gbztcbiAgICB9KTtcblxuICAgIHJldHVybiAoZGVzdC5faW5wdXQgPSBvdXRwdXQpO1xuICB9O1xuXG4gIGwuYWRkTGlzdGVuZXIodGhpcy5fcGlwZWxpbmVbMF0pO1xuICByZXR1cm4gbDtcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZihsIGluc3RhbmNlb2YgRGF0YXNvdXJjZSkge1xuICAgIGlmKHRoaXMuX2NvbGxlY3RvcikgdGhpcy5fY29sbGVjdG9yLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gICAgZWxzZSB0aGlzLl9waXBlbGluZVswXS5hZGRMaXN0ZW5lcihsLmxpc3RlbmVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5hZGRMaXN0ZW5lcihsKTsgICAgICBcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5yZW1vdmVMaXN0ZW5lcihsKTtcbn07XG5cbnByb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGRzKSB7XG4gIHJldHVybiBkcyBcbiAgICA/IHRoaXMuX2NvbGxlY3RvciA/IHRoaXMuX2NvbGxlY3Rvci5saXN0ZW5lcnMoKSA6IHRoaXMuX3BpcGVsaW5lWzBdLmxpc3RlbmVycygpXG4gICAgOiB0aGlzLl9waXBlbGluZVt0aGlzLl9waXBlbGluZS5sZW5ndGgtMV0ubGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFzb3VyY2U7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEhlYXAgPSByZXF1aXJlKCdoZWFwJyksXG4gICAgRGF0YXNvdXJjZSA9IHJlcXVpcmUoJy4vRGF0YXNvdXJjZScpLFxuICAgIFNpZ25hbCA9IHJlcXVpcmUoJy4vU2lnbmFsJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gR3JhcGgoKSB7XG59XG5cbnZhciBwcm90byA9IEdyYXBoLnByb3RvdHlwZTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFtcCA9IDA7XG4gIHRoaXMuX3JhbmsgID0gMDtcblxuICB0aGlzLl9kYXRhID0ge307XG4gIHRoaXMuX3NpZ25hbHMgPSB7fTtcblxuICB0aGlzLmRvTm90UHJvcGFnYXRlID0ge307XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24obmFtZSwgcGlwZWxpbmUsIGZhY2V0KSB7XG4gIHZhciBkYiA9IHRoaXMuX2RhdGE7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGwua2V5cyhkYikubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRiW2RdOyB9KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGRiW25hbWVdO1xuICByZXR1cm4gKGRiW25hbWVdID0gbmV3IERhdGFzb3VyY2UodGhpcywgbmFtZSwgZmFjZXQpLnBpcGVsaW5lKHBpcGVsaW5lKSk7XG59O1xuXG5mdW5jdGlvbiBzaWduYWwobmFtZSkge1xuICB2YXIgbSA9IHRoaXMsIGksIGxlbjtcbiAgaWYoIWRsLmlzQXJyYXkobmFtZSkpIHJldHVybiB0aGlzLl9zaWduYWxzW25hbWVdO1xuICByZXR1cm4gbmFtZS5tYXAoZnVuY3Rpb24obikgeyBtLl9zaWduYWxzW25dOyB9KTtcbn1cblxucHJvdG8uc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaW5pdCkge1xuICB2YXIgbSA9IHRoaXM7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBzaWduYWwuY2FsbCh0aGlzLCBuYW1lKTtcbiAgcmV0dXJuICh0aGlzLl9zaWduYWxzW25hbWVdID0gbmV3IFNpZ25hbCh0aGlzLCBuYW1lLCBpbml0KSk7XG59O1xuXG5wcm90by5zaWduYWxWYWx1ZXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBncmFwaCA9IHRoaXM7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSBuYW1lID0gZGwua2V5cyh0aGlzLl9zaWduYWxzKTtcbiAgaWYoIWRsLmlzQXJyYXkobmFtZSkpIHJldHVybiB0aGlzLl9zaWduYWxzW25hbWVdLnZhbHVlKCk7XG4gIHJldHVybiBuYW1lLnJlZHVjZShmdW5jdGlvbihzZywgbikge1xuICAgIHJldHVybiAoc2dbbl0gPSBncmFwaC5fc2lnbmFsc1tuXS52YWx1ZSgpLCBzZyk7XG4gIH0sIHt9KTtcbn07XG5cbnByb3RvLnNpZ25hbFJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICBpZighZGwuaXNBcnJheShyZWYpKSByZWYgPSBkbC5maWVsZChyZWYpO1xuICB2YXIgdmFsdWUgPSB0aGlzLnNpZ25hbChyZWYuc2hpZnQoKSkudmFsdWUoKTtcbiAgaWYocmVmLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZm4gPSBGdW5jdGlvbihcInNcIiwgXCJyZXR1cm4gc1tcIityZWYubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiKTtcbiAgICB2YWx1ZSA9IGZuLmNhbGwobnVsbCwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIHNjaGVkdWxlID0gZnVuY3Rpb24oYSwgYikge1xuICAvLyBJZiB0aGUgbm9kZXMgYXJlIGVxdWFsLCBwcm9wYWdhdGUgdGhlIG5vbi1yZWZsb3cgcHVsc2UgZmlyc3QsXG4gIC8vIHNvIHRoYXQgd2UgY2FuIGlnbm9yZSBzdWJzZXF1ZW50IHJlZmxvdyBwdWxzZXMuIFxuICBpZihhLnJhbmsgPT0gYi5yYW5rKSByZXR1cm4gYS5wdWxzZS5yZWZsb3cgPyAxIDogLTE7XG4gIGVsc2UgcmV0dXJuIGEucmFuayAtIGIucmFuazsgXG59O1xuXG5wcm90by5wcm9wYWdhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICB2YXIgdiwgbCwgbiwgcCwgciwgaSwgbGVuLCByZWZsb3dlZDtcblxuICAvLyBuZXcgUFEgd2l0aCBlYWNoIHByb3BhZ2F0aW9uIGN5Y2xlIHNvIHRoYXQgd2UgY2FuIHB1bHNlIGJyYW5jaGVzXG4gIC8vIG9mIHRoZSBkYXRhZmxvdyBncmFwaCBkdXJpbmcgYSBwcm9wYWdhdGlvbiAoZS5nLiwgd2hlbiBjcmVhdGluZ1xuICAvLyBhIG5ldyBpbmxpbmUgZGF0YXNvdXJjZSkuXG4gIHZhciBwcSA9IG5ldyBIZWFwKHNjaGVkdWxlKTsgXG5cbiAgaWYocHVsc2Uuc3RhbXApIHRocm93IFwiUHVsc2UgYWxyZWFkeSBoYXMgYSBub24temVybyBzdGFtcFwiXG5cbiAgcHVsc2Uuc3RhbXAgPSArK3RoaXMuX3N0YW1wO1xuICBwcS5wdXNoKHsgbm9kZTogbm9kZSwgcHVsc2U6IHB1bHNlLCByYW5rOiBub2RlLnJhbmsoKSB9KTtcblxuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5wb3AoKSwgbiA9IHYubm9kZSwgcCA9IHYucHVsc2UsIHIgPSB2LnJhbmssIGwgPSBuLl9saXN0ZW5lcnM7XG4gICAgcmVmbG93ZWQgPSBwLnJlZmxvdyAmJiBuLmxhc3QoKSA+PSBwLnN0YW1wO1xuXG4gICAgaWYocmVmbG93ZWQpIGNvbnRpbnVlOyAvLyBEb24ndCBuZWVkbGVzc2x5IHJlZmxvdyBvcHMuXG5cbiAgICAvLyBBIG5vZGUncyByYW5rIG1pZ2h0IGNoYW5nZSBkdXJpbmcgYSBwcm9wYWdhdGlvbiAoZS5nLiBpbnN0YW50aWF0aW5nXG4gICAgLy8gYSBncm91cCdzIGRhdGFmbG93IGJyYW5jaCkuIFJlLXF1ZXVlIGlmIGl0IGhhcy4gVFxuICAgIC8vIFRPRE86IHVzZSBwcS5yZXBsYWNlIG9yIHBxLnBvcHB1c2g/XG4gICAgaWYociAhPSBuLnJhbmsoKSkge1xuICAgICAgZGVidWcocCwgWydSYW5rIG1pc21hdGNoJywgciwgbi5yYW5rKCldKTtcbiAgICAgIHBxLnB1c2goeyBub2RlOiBuLCBwdWxzZTogcCwgcmFuazogbi5yYW5rKCkgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwID0gdGhpcy5ldmFsdWF0ZShwLCBuKTtcblxuICAgIC8vIEV2ZW4gaWYgd2UgZGlkbid0IHJ1biB0aGUgbm9kZSwgd2Ugc3RpbGwgd2FudCB0byBwcm9wYWdhdGUgXG4gICAgLy8gdGhlIHB1bHNlLiBcbiAgICBpZiAocCAhPT0gdGhpcy5kb05vdFByb3BhZ2F0ZSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcS5wdXNoKHsgbm9kZTogbFtpXSwgcHVsc2U6IHAsIHJhbms6IGxbaV0uX3JhbmsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDb25uZWN0IGEgYnJhbmNoIG9mIGRhdGFmbG93IG5vZGVzLiBcbi8vIERlcGVuZGVuY2llcyBnZXQgd2lyZWQgdG8gdGhlIG5lYXJlc3QgY29sbGVjdG9yLiBcbmZ1bmN0aW9uIGZvckVhY2hOb2RlKGJyYW5jaCwgZm4pIHtcbiAgdmFyIG5vZGUsIGNvbGxlY3RvciwgaSwgbGVuO1xuICBmb3IoaT0wLCBsZW49YnJhbmNoLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG5vZGUgPSBicmFuY2hbaV07XG4gICAgaWYobm9kZS5jb2xsZWN0b3IoKSkgY29sbGVjdG9yID0gbm9kZTtcbiAgICBmbihub2RlLCBjb2xsZWN0b3IsIGkpO1xuICB9XG59XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgZGVidWcoe30sIFsnY29ubmVjdGluZyddKTtcbiAgdmFyIGdyYXBoID0gdGhpcztcbiAgZm9yRWFjaE5vZGUoYnJhbmNoLCBmdW5jdGlvbihuLCBjLCBpKSB7XG4gICAgdmFyIGRhdGEgPSBuLmRlcGVuZGVuY3koQy5EQVRBKSxcbiAgICAgICAgc2lnbmFscyA9IG4uZGVwZW5kZW5jeShDLlNJR05BTFMpO1xuXG4gICAgaWYoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyBcbiAgICAgICAgZ3JhcGguZGF0YShkKVxuICAgICAgICAgIC5yZXZpc2VzKG4ucmV2aXNlcygpKVxuICAgICAgICAgIC5hZGRMaXN0ZW5lcihjKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKHNpZ25hbHMubGVuZ3RoID4gMCkge1xuICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgZ3JhcGguc2lnbmFsKHMpLmFkZExpc3RlbmVyKGMpOyB9KTtcbiAgICB9XG5cbiAgICBpZihpID4gMCkge1xuICAgICAgYnJhbmNoW2ktMV0uYWRkTGlzdGVuZXIoYnJhbmNoW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIGRlYnVnKHt9LCBbJ2Rpc2Nvbm5lY3RpbmcnXSk7XG4gIHZhciBncmFwaCA9IHRoaXM7XG5cbiAgZm9yRWFjaE5vZGUoYnJhbmNoLCBmdW5jdGlvbihuLCBjLCBpKSB7XG4gICAgdmFyIGRhdGEgPSBuLmRlcGVuZGVuY3koQy5EQVRBKSxcbiAgICAgICAgc2lnbmFscyA9IG4uZGVwZW5kZW5jeShDLlNJR05BTFMpO1xuXG4gICAgaWYoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyBncmFwaC5kYXRhKGQpLnJlbW92ZUxpc3RlbmVyKGMpOyB9KTtcbiAgICB9XG5cbiAgICBpZihzaWduYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IGdyYXBoLnNpZ25hbChzKS5yZW1vdmVMaXN0ZW5lcihjKSB9KTtcbiAgICB9XG5cbiAgICBuLmRpc2Nvbm5lY3QoKTsgIFxuICB9KTtcblxuICByZXR1cm4gYnJhbmNoO1xufTtcblxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciByZWZsb3dlZCA9ICFwdWxzZS5yZWZsb3cgfHwgKHB1bHNlLnJlZmxvdyAmJiBub2RlLmxhc3QoKSA+PSBwdWxzZS5zdGFtcCksXG4gICAgICBydW4gPSAhIXB1bHNlLmFkZC5sZW5ndGggfHwgISFwdWxzZS5yZW0ubGVuZ3RoIHx8IG5vZGUucm91dGVyKCk7XG4gIHJ1biA9IHJ1biB8fCAhcmVmbG93ZWQ7XG4gIHJldHVybiBydW4gfHwgbm9kZS5yZWV2YWx1YXRlKHB1bHNlKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgaWYoIXRoaXMucmVldmFsdWF0ZShwdWxzZSwgbm9kZSkpIHJldHVybiBwdWxzZTtcbiAgcHVsc2UgPSBub2RlLmV2YWx1YXRlKHB1bHNlKTtcbiAgbm9kZS5sYXN0KHB1bHNlLnN0YW1wKTtcbiAgcmV0dXJuIHB1bHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKSxcbiAgICBSRUVWQUwgPSBbQy5EQVRBLCBDLkZJRUxEUywgQy5TQ0FMRVMsIEMuU0lHTkFMU107XG5cbnZhciBub2RlX2lkID0gMTtcblxuZnVuY3Rpb24gTm9kZShncmFwaCkge1xuICBpZihncmFwaCkgdGhpcy5pbml0KGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IE5vZGUucHJvdG90eXBlO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5faWQgPSBub2RlX2lkKys7XG4gIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gIHRoaXMuX3JhbmsgPSArK2dyYXBoLl9yYW5rOyAvLyBGb3IgdG9wb2xvZ2lhbCBzb3J0XG4gIHRoaXMuX3N0YW1wID0gMDsgIC8vIExhc3Qgc3RhbXAgc2VlblxuXG4gIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICB0aGlzLl9yZWdpc3RlcmVkID0ge307IC8vIFRvIHByZXZlbnQgZHVwbGljYXRlIGxpc3RlbmVyc1xuXG4gIHRoaXMuX2RlcHMgPSB7XG4gICAgZGF0YTogICAgW10sXG4gICAgZmllbGRzOiAgW10sXG4gICAgc2NhbGVzOiAgW10sXG4gICAgc2lnbmFsczogW10sXG4gIH07XG5cbiAgdGhpcy5faXNSb3V0ZXIgPSBmYWxzZTsgLy8gUmVzcG9uc2libGUgZm9yIHByb3BhZ2F0aW5nIHR1cGxlcywgY2Fubm90IGV2ZXIgYmUgc2tpcHBlZFxuICB0aGlzLl9pc0NvbGxlY3RvciA9IGZhbHNlOyAgLy8gSG9sZHMgYSBtYXRlcmlhbGl6ZWQgZGF0YXNldCwgcHVsc2UgdG8gcmVmbG93XG4gIHRoaXMuX3JldmlzZXMgPSBmYWxzZTsgLy8gRG9lcyB0aGUgb3BlcmF0b3IgcmVxdWlyZSB0dXBsZXMnIHByZXZpb3VzIHZhbHVlcz8gXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCk7XG4gIG4uZXZhbHVhdGUgPSB0aGlzLmV2YWx1YXRlO1xuICBuLl9kZXBzID0gdGhpcy5fZGVwcztcbiAgbi5faXNSb3V0ZXIgPSB0aGlzLl9pc1JvdXRlcjtcbiAgbi5faXNDb2xsZWN0b3IgPSB0aGlzLl9pc0NvbGxlY3RvcjtcbiAgcmV0dXJuIG47XG59O1xuXG5wcm90by5yYW5rID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9yYW5rOyB9O1xuXG5wcm90by5sYXN0ID0gZnVuY3Rpb24oc3RhbXApIHsgXG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc3RhbXA7XG4gIHRoaXMuX3N0YW1wID0gc3RhbXA7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uZGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHR5cGUsIGRlcHMpIHtcbiAgdmFyIGQgPSB0aGlzLl9kZXBzW3R5cGVdO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZDtcbiAgaWYoZGVwcyA9PT0gbnVsbCkgeyAvLyBDbGVhciBkZXBlbmRlbmNpZXMgb2YgYSBjZXJ0YWluIHR5cGVcbiAgICB3aGlsZShkLmxlbmd0aCA+IDApIGQucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYoIWRsLmlzQXJyYXkoZGVwcykgJiYgZC5pbmRleE9mKGRlcHMpIDwgMCkgZC5wdXNoKGRlcHMpO1xuICAgIGVsc2UgZC5wdXNoLmFwcGx5KGQsIGRsLmFycmF5KGRlcHMpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJvdXRlciA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pc1JvdXRlcjtcbiAgdGhpcy5faXNSb3V0ZXIgPSAhIWJvb2xcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5jb2xsZWN0b3IgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faXNDb2xsZWN0b3I7XG4gIHRoaXMuX2lzQ29sbGVjdG9yID0gISFib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJldmlzZXMgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmV2aXNlcztcbiAgdGhpcy5fcmV2aXNlcyA9ICEhYm9vbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5saXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycztcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZighKGwgaW5zdGFuY2VvZiBOb2RlKSkgdGhyb3cgXCJMaXN0ZW5lciBpcyBub3QgYSBOb2RlXCI7XG4gIGlmKHRoaXMuX3JlZ2lzdGVyZWRbbC5faWRdKSByZXR1cm4gdGhpcztcblxuICB0aGlzLl9saXN0ZW5lcnMucHVzaChsKTtcbiAgdGhpcy5fcmVnaXN0ZXJlZFtsLl9pZF0gPSAxO1xuICBpZih0aGlzLl9yYW5rID4gbC5fcmFuaykge1xuICAgIHZhciBxID0gW2xdO1xuICAgIHdoaWxlKHEubGVuZ3RoKSB7XG4gICAgICB2YXIgY3VyID0gcS5zcGxpY2UoMCwxKVswXTtcbiAgICAgIGN1ci5fcmFuayA9ICsrdGhpcy5fZ3JhcGguX3Jhbms7XG4gICAgICBxLnB1c2guYXBwbHkocSwgY3VyLl9saXN0ZW5lcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobCkge1xuICB2YXIgZm91bmRTZW5kaW5nID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuICYmICFmb3VuZFNlbmRpbmc7IGkrKykge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbaV0gPT09IGwpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9yZWdpc3RlcmVkW2wuX2lkXSA9IG51bGw7XG4gICAgICBmb3VuZFNlbmRpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGZvdW5kU2VuZGluZztcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX3JlZ2lzdGVyZWQgPSB7fTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHsgcmV0dXJuIHB1bHNlOyB9XG5cbnByb3RvLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkge1xuICB2YXIgbm9kZSA9IHRoaXMsIHJlZXZhbCA9IGZhbHNlO1xuICByZXR1cm4gUkVFVkFMLnNvbWUoZnVuY3Rpb24ocHJvcCkge1xuICAgIHJlZXZhbCA9IHJlZXZhbCB8fCBub2RlLl9kZXBzW3Byb3BdLnNvbWUoZnVuY3Rpb24oaykgeyByZXR1cm4gISFwdWxzZVtwcm9wXVtrXSB9KTtcbiAgICByZXR1cm4gcmVldmFsO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIFNpZ25hbChncmFwaCwgbmFtZSwgaW5pdCkge1xuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9uYW1lICA9IG5hbWU7XG4gIHRoaXMuX3ZhbHVlID0gaW5pdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgcHJvdG8gPSAoU2lnbmFsLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5uYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uYW1lOyB9O1xuXG5wcm90by52YWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5maXJlID0gZnVuY3Rpb24oY3MpIHtcbiAgaWYoIWNzKSBjcyA9IGNoYW5nZXNldC5jcmVhdGUobnVsbCwgdHJ1ZSk7XG4gIGNzLnNpZ25hbHNbdGhpcy5fbmFtZV0gPSAxO1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUoY3MsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYWw7IiwidmFyIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xudmFyIFJFRVZBTCA9IFtDLkRBVEEsIEMuRklFTERTLCBDLlNDQUxFUywgQy5TSUdOQUxTXTtcblxuZnVuY3Rpb24gY3JlYXRlKGNzLCByZWZsb3cpIHtcbiAgdmFyIG91dCA9IHt9O1xuICBjb3B5KGNzLCBvdXQpO1xuXG4gIG91dC5hZGQgPSBbXTtcbiAgb3V0Lm1vZCA9IFtdO1xuICBvdXQucmVtID0gW107XG5cbiAgb3V0LnJlZmxvdyA9IHJlZmxvdztcblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiByZXNldF9wcmV2KHgpIHtcbiAgeC5fcHJldiA9ICh4Ll9wcmV2ID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogQy5TRU5USU5FTDtcbn1cblxuZnVuY3Rpb24gZmluYWxpemUoY3MpIHtcbiAgZm9yKGk9MCwgbGVuPWNzLmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHJlc2V0X3ByZXYoY3MuYWRkW2ldKTtcbiAgZm9yKGk9MCwgbGVuPWNzLm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHJlc2V0X3ByZXYoY3MubW9kW2ldKTtcbn1cblxuZnVuY3Rpb24gY29weShhLCBiKSB7XG4gIGIuc3RhbXAgPSBhID8gYS5zdGFtcCA6IDA7XG4gIGIuc29ydCAgPSBhID8gYS5zb3J0ICA6IG51bGw7XG4gIGIuZmFjZXQgPSBhID8gYS5mYWNldCA6IG51bGw7XG4gIGIudHJhbnMgPSBhID8gYS50cmFucyA6IG51bGw7XG4gIFJFRVZBTC5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgYltkXSA9IGEgPyBhW2RdIDoge307IH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNvcHk6IGNvcHksXG4gIGZpbmFsaXplOiBmaW5hbGl6ZSxcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIHR1cGxlX2lkID0gMTtcblxuLy8gT2JqZWN0LmNyZWF0ZSBpcyBleHBlbnNpdmUuIFNvLCB3aGVuIGluZ2VzdGluZywgdHJ1c3QgdGhhdCB0aGVcbi8vIGRhdHVtIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBiZWVuIGFwcHJvcHJpYXRlbHkgc2FuZGJveGVkIGZyb20gXG4vLyB0aGUgb3V0c2lkZSBlbnZpcm9ubWVudC4gXG5mdW5jdGlvbiBpbmdlc3QoZGF0dW0sIHByZXYpIHtcbiAgZGF0dW0gPSBkbC5pc09iamVjdChkYXR1bSkgPyBkYXR1bSA6IHtkYXRhOiBkYXR1bX07XG4gIGRhdHVtLl9pZCA9IHR1cGxlX2lkKys7XG4gIGRhdHVtLl9wcmV2ID0gKHByZXYgIT09IHVuZGVmaW5lZCkgPyAocHJldiB8fCBDLlNFTlRJTkVMKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGRhdHVtO1xufVxuXG5mdW5jdGlvbiBkZXJpdmUoZGF0dW0sIHByZXYpIHtcbiAgcmV0dXJuIGluZ2VzdChPYmplY3QuY3JlYXRlKGRhdHVtKSwgcHJldik7XG59XG5cbi8vIFdBUk5JTkc6IG9wZXJhdG9ycyBzaG91bGQgb25seSBjYWxsIHRoaXMgb25jZSBwZXIgdGltZXN0YW1wIVxuZnVuY3Rpb24gc2V0KHQsIGssIHYpIHtcbiAgdmFyIHByZXYgPSB0W2tdO1xuICBpZihwcmV2ID09PSB2KSByZXR1cm47XG4gIHNldF9wcmV2KHQsIGspO1xuICB0W2tdID0gdjtcbn1cblxuZnVuY3Rpb24gc2V0X3ByZXYodCwgaykge1xuICBpZih0Ll9wcmV2ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgdC5fcHJldiA9ICh0Ll9wcmV2ID09PSBDLlNFTlRJTkVMKSA/IHt9IDogdC5fcHJldjtcbiAgdC5fcHJldltrXSA9IHRba107XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkgeyB0dXBsZV9pZCA9IDE7IH1cblxuZnVuY3Rpb24gaWRNYXAoYSkge1xuICByZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24obSx4KSB7XG4gICAgcmV0dXJuIChtW3guX2lkXSA9IDEsIG0pO1xuICB9LCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5nZXN0OiBpbmdlc3QsXG4gIGRlcml2ZTogZGVyaXZlLFxuICBzZXQ6ICAgIHNldCxcbiAgcHJldjogICBzZXRfcHJldixcbiAgcmVzZXQ6ICByZXNldCxcbiAgaWRNYXA6ICBpZE1hcFxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbiAgdmFyIGZ1bmN0aW9ucyA9IChvcHQuZnVuY3Rpb25zIHx8IHJlcXVpcmUoJy4vZnVuY3Rpb25zJykpKGNvZGVnZW4pO1xuICB2YXIgaWRXaGl0ZUxpc3QgPSBvcHQuaWRXaGl0ZUxpc3QgPyBkbC50b01hcChvcHQuaWRXaGl0ZUxpc3QpIDogbnVsbDtcbiAgdmFyIGlkQmxhY2tMaXN0ID0gb3B0LmlkQmxhY2tMaXN0ID8gZGwudG9NYXAob3B0LmlkQmxhY2tMaXN0KSA6IG51bGw7XG4gIHZhciBtZW1iZXJEZXB0aCA9IDA7XG5cbiAgLy8gVE9ETyBnZW5lcmFsaXplP1xuICB2YXIgREFUVU0gPSAnZCc7XG4gIHZhciBTSUdOQUxfUFJFRklYID0gJ3NnLic7XG4gIHZhciBzaWduYWxzID0ge307XG4gIHZhciBmaWVsZHMgPSB7fTtcblxuICBmdW5jdGlvbiBjb2RlZ2VuX3dyYXAoYXN0KSB7ICAgIFxuICAgIHZhciByZXR2YWwgPSB7XG4gICAgICBmbjogY29kZWdlbihhc3QpLFxuICAgICAgc2lnbmFsczogZGwua2V5cyhzaWduYWxzKSxcbiAgICAgIGZpZWxkczogZGwua2V5cyhmaWVsZHMpXG4gICAgfTtcbiAgICBzaWduYWxzID0ge307XG4gICAgZmllbGRzID0ge307XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVnZW4oYXN0KSB7XG4gICAgaWYgKGFzdCBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIGFzdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gQ09ERUdFTl9UWVBFU1thc3QudHlwZV07XG4gICAgaWYgKGdlbmVyYXRvciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlOiBcIiArIGFzdC50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRvcihhc3QpO1xuICB9XG5cbiAgdmFyIENPREVHRU5fVFlQRVMgPSB7XG4gICAgXCJMaXRlcmFsXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4ucmF3O1xuICAgICAgfSxcbiAgICBcIklkZW50aWZpZXJcIjogZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgaWQgPSBuLm5hbWU7XG4gICAgICAgIGlmIChtZW1iZXJEZXB0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3RhbnRzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRXaGl0ZUxpc3QpIHtcbiAgICAgICAgICBpZiAoaWRXaGl0ZUxpc3QuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25hbHNbaWRdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBTSUdOQUxfUFJFRklYICsgaWQ7IC8vIEhBQ0tpc2guLi5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkQmxhY2tMaXN0ICYmIGlkQmxhY2tMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaWRlbnRpZmllcjogXCIgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSxcbiAgICBcIlByb2dyYW1cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi5ib2R5Lm1hcChjb2RlZ2VuKS5qb2luKFwiXFxuXCIpO1xuICAgICAgfSxcbiAgICBcIk1lbWJlckV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZCA9ICFuLmNvbXB1dGVkO1xuICAgICAgICB2YXIgbyA9IGNvZGVnZW4obi5vYmplY3QpO1xuICAgICAgICBpZiAoZCkgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgICAgdmFyIHAgPSBjb2RlZ2VuKG4ucHJvcGVydHkpO1xuICAgICAgICBpZiAobyA9PT0gREFUVU0pIHsgZmllbGRzW3BdID0gMTsgfSAvLyBIQUNLaXNoLi4uXG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgICByZXR1cm4gbyArIChkID8gXCIuXCIrcCA6IFwiW1wiK3ArXCJdXCIpO1xuICAgICAgfSxcbiAgICBcIkNhbGxFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgaWYgKG4uY2FsbGVlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjYWxsZWUgdHlwZTogXCIgKyBuLmNhbGxlZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGVlID0gbi5jYWxsZWUubmFtZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBuLmFyZ3VtZW50cztcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb25zLmhhc093blByb3BlcnR5KGNhbGxlZSkgJiYgZnVuY3Rpb25zW2NhbGxlZV07XG4gICAgICAgIGlmICghZm4pIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBmdW5jdGlvbjogXCIgKyBjYWxsZWUpO1xuICAgICAgICByZXR1cm4gZm4gaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgID8gZm4oYXJncylcbiAgICAgICAgICA6IGZuICsgXCIoXCIgKyBhcmdzLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIkFycmF5RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIG4uZWxlbWVudHMubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICB9LFxuICAgIFwiQmluYXJ5RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiVW5hcnlFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5hcmd1bWVudCkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJVcGRhdGVFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgKHByZWZpeFxuICAgICAgICAgID8gbi5vcGVyYXRvciArIGNvZGVnZW4obi5hcmd1bWVudClcbiAgICAgICAgICA6IGNvZGVnZW4obi5hcmd1bWVudCkgKyBuLm9wZXJhdG9yXG4gICAgICAgICkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBjb2RlZ2VuKG4udGVzdClcbiAgICAgICAgICArIFwiP1wiICsgY29kZWdlbihuLmNvbnNlcXVlbnQpXG4gICAgICAgICAgKyBcIjpcIiArIGNvZGVnZW4obi5hbHRlcm5hdGUpXG4gICAgICAgICAgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJMb2dpY2FsRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiT2JqZWN0RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG4ucHJvcGVydGllcy5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgIH0sXG4gICAgXCJQcm9wZXJ0eVwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBrID0gY29kZWdlbihuLmtleSk7XG4gICAgICAgIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBrICsgXCI6XCIgKyBjb2RlZ2VuKG4udmFsdWUpO1xuICAgICAgfSxcbiAgICBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gY29kZWdlbihuLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICB9O1xuICBcbiAgcmV0dXJuIGNvZGVnZW5fd3JhcDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwiTmFOXCI6ICAgICBcIk5hTlwiLFxuICBcIkVcIjogICAgICAgXCJNYXRoLkVcIixcbiAgXCJMTjJcIjogICAgIFwiTWF0aC5MTjJcIixcbiAgXCJMTjEwXCI6ICAgIFwiTWF0aC5MTjEwXCIsXG4gIFwiTE9HMkVcIjogICBcIk1hdGguTE9HMkVcIixcbiAgXCJMT0cxMEVcIjogIFwiTWF0aC5MT0cxMEVcIixcbiAgXCJQSVwiOiAgICAgIFwiTWF0aC5QSVwiLFxuICBcIlNRUlQxXzJcIjogXCJNYXRoLlNRUlQxXzJcIixcbiAgXCJTUVJUMlwiOiAgIFwiTWF0aC5TUVJUMlwiXG59OyIsInZhciBkYXRhbGliID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvZGVnZW4pIHtcblxuICBmdW5jdGlvbiBmbmNhbGwobmFtZSwgYXJncywgY2FzdCwgdHlwZSkge1xuICAgIHZhciBvYmogPSBjb2RlZ2VuKGFyZ3NbMF0pO1xuICAgIGlmIChjYXN0KSB7XG4gICAgICBvYmogPSBjYXN0ICsgXCIoXCIgKyBvYmogKyBcIilcIjtcbiAgICAgIGlmIChkbC5zdGFydHNXaXRoKGNhc3QsIFwibmV3IFwiKSkgb2JqID0gXCIoXCIgKyBvYmogKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIG9iaiArIFwiLlwiICsgbmFtZSArICh0eXBlIDwgMCA/IFwiXCIgOiB0eXBlID09PSAwXG4gICAgICA/IFwiKClcIlxuICAgICAgOiBcIihcIiArIGFyZ3Muc2xpY2UoMSkubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICB9XG4gIFxuICB2YXIgREFURSA9IFwibmV3IERhdGVcIjtcbiAgdmFyIFNUUklORyA9IFwiU3RyaW5nXCI7XG4gIHZhciBSRUdFWFAgPSBcIlJlZ0V4cFwiO1xuXG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICBcImlzTmFOXCI6ICAgIFwiaXNOYU5cIixcbiAgICBcImlzRmluaXRlXCI6IFwiaXNGaW5pdGVcIixcbiAgICBcImFic1wiOiAgICAgIFwiTWF0aC5hYnNcIixcbiAgICBcImFjb3NcIjogICAgIFwiTWF0aC5hY29zXCIsXG4gICAgXCJhc2luXCI6ICAgICBcIk1hdGguYXNpblwiLFxuICAgIFwiYXRhblwiOiAgICAgXCJNYXRoLmF0YW5cIixcbiAgICBcImF0YW4yXCI6ICAgIFwiTWF0aC5hdGFuMlwiLFxuICAgIFwiY2VpbFwiOiAgICAgXCJNYXRoLmNlaWxcIixcbiAgICBcImNvc1wiOiAgICAgIFwiTWF0aC5jb3NcIixcbiAgICBcImV4cFwiOiAgICAgIFwiTWF0aC5leHBcIixcbiAgICBcImZsb29yXCI6ICAgIFwiTWF0aC5mbG9vclwiLFxuICAgIFwibG9nXCI6ICAgICAgXCJNYXRoLmxvZ1wiLFxuICAgIFwibWF4XCI6ICAgICAgXCJNYXRoLm1heFwiLFxuICAgIFwibWluXCI6ICAgICAgXCJNYXRoLm1pblwiLFxuICAgIFwicG93XCI6ICAgICAgXCJNYXRoLnBvd1wiLFxuICAgIFwicmFuZG9tXCI6ICAgXCJNYXRoLnJhbmRvbVwiLFxuICAgIFwicm91bmRcIjogICAgXCJNYXRoLnJvdW5kXCIsXG4gICAgXCJzaW5cIjogICAgICBcIk1hdGguc2luXCIsXG4gICAgXCJzcXJ0XCI6ICAgICBcIk1hdGguc3FydFwiLFxuICAgIFwidGFuXCI6ICAgICAgXCJNYXRoLnRhblwiLFxuXG4gICAgLy8gREFURSBmdW5jdGlvbnNcbiAgICBcIm5vd1wiOiAgICAgIFwiRGF0ZS5ub3dcIixcbiAgICBcImRhdGV0aW1lXCI6IFwibmV3IERhdGVcIixcbiAgICBcImRhdGVcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0RGF0ZVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJkYXlcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0RGF5XCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInllYXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0RnVsbFllYXJcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwibW9udGhcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0TW9udGhcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwiaG91cnNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0SG91cnNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwibWludXRlc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRNaW51dGVzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInNlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0U2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJtaWxsaXNlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0TWlsbGlzZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInRpbWVcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VGltZVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ0aW1lem9uZW9mZnNldFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRUaW1lem9uZU9mZnNldFwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNkYXRlXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0RhdGVcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjZGF5XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0RheVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGN5ZWFyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0Z1bGxZZWFyXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y21vbnRoXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ01vbnRoXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y2hvdXJzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0hvdXJzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y21pbnV0ZXNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDTWludXRlc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ1NlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjbWlsbGlzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ01pbGxpc2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG5cbiAgICAvLyBzaGFyZWQgc2VxdWVuY2UgZnVuY3Rpb25zXG4gICAgXCJsZW5ndGhcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwibGVuZ3RoXCIsIGFyZ3MsIG51bGwsIC0xKTtcbiAgICAgIH0sXG4gICAgXCJpbmRleG9mXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImluZGV4T2ZcIiwgYXJncywgbnVsbCk7XG4gICAgICB9LFxuICAgIFwibGFzdGluZGV4b2ZcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwibGFzdEluZGV4T2ZcIiwgYXJncywgbnVsbCk7XG4gICAgICB9LFxuXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgIFwicGFyc2VGbG9hdFwiOiBcInBhcnNlRmxvYXRcIixcbiAgICBcInBhcnNlSW50XCI6IFwicGFyc2VJbnRcIixcbiAgICBcInVwcGVyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInRvVXBwZXJDYXNlXCIsIGFyZ3MsIFNUUklORywgMCk7XG4gICAgICB9LFxuICAgIFwibG93ZXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwidG9Mb3dlckNhc2VcIiwgYXJncywgU1RSSU5HLCAwKTtcbiAgICAgIH0sXG4gICAgXCJzbGljZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJzbGljZVwiLCBhcmdzLCBTVFJJTkcpO1xuICAgICAgfSxcbiAgICBcInN1YnN0cmluZ1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJzdWJzdHJpbmdcIiwgYXJncywgU1RSSU5HKTtcbiAgICAgIH0sXG5cbiAgICAvLyBSRUdFWFAgZnVuY3Rpb25zXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInRlc3RcIiwgYXJncywgUkVHRVhQKTtcbiAgICAgIH0sXG4gICAgXG4gICAgLy8gQ29udHJvbCBGbG93IGZ1bmN0aW9uc1xuICAgIFwiaWZcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG1hbnkgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgdmFyIGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgICAgcmV0dXJuIGFbMF0rXCI/XCIrYVsxXStcIjpcIithWzJdO1xuICAgICAgfVxuICB9O1xufTsiLCJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKSxcbiAgICBjb2RlZ2VuID0gcmVxdWlyZSgnLi9jb2RlZ2VuJyk7XG4gICAgXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBvcHQpIHsgcmV0dXJuIHBhcnNlci5wYXJzZShcIihcIitpbnB1dCtcIilcIiwgb3B0KTsgfSxcbiAgY29kZTogZnVuY3Rpb24ob3B0KSB7IHJldHVybiBjb2RlZ2VuKG9wdCk7IH1cbn07XG4iLCIvKlxuICBUaGUgZm9sbG93aW5nIGV4cHJlc3Npb24gcGFyc2VyIGlzIGJhc2VkIG9uIEVzcHJpbWEgKGh0dHA6Ly9lc3ByaW1hLm9yZy8pLlxuICBPcmlnaW5hbCBoZWFkZXIgY29tbWVudCBhbmQgbGljZW5zZSBmb3IgRXNwcmltYSBpcyBpbmNsdWRlZCBoZXJlOlxuXG4gIENvcHlyaWdodCAoQykgMjAxMyBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIFRoYWRkZWUgVHlsIDx0aGFkZGVlLnR5bEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRva2VuLFxuICAgICAgVG9rZW5OYW1lLFxuICAgICAgU3ludGF4LFxuICAgICAgUHJvcGVydHlLaW5kLFxuICAgICAgTWVzc2FnZXMsXG4gICAgICBSZWdleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHN0cmljdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGluZU51bWJlcixcbiAgICAgIGxpbmVTdGFydCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIGxvb2thaGVhZCxcbiAgICAgIHN0YXRlLFxuICAgICAgZXh0cmE7XG5cbiAgVG9rZW4gPSB7XG4gICAgICBCb29sZWFuTGl0ZXJhbDogMSxcbiAgICAgIEVPRjogMixcbiAgICAgIElkZW50aWZpZXI6IDMsXG4gICAgICBLZXl3b3JkOiA0LFxuICAgICAgTnVsbExpdGVyYWw6IDUsXG4gICAgICBOdW1lcmljTGl0ZXJhbDogNixcbiAgICAgIFB1bmN0dWF0b3I6IDcsXG4gICAgICBTdHJpbmdMaXRlcmFsOiA4LFxuICAgICAgUmVndWxhckV4cHJlc3Npb246IDlcbiAgfTtcblxuICBUb2tlbk5hbWUgPSB7fTtcbiAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgVG9rZW5OYW1lW1Rva2VuLkVPRl0gPSAnPGVuZD4nO1xuICBUb2tlbk5hbWVbVG9rZW4uSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG4gIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgVG9rZW5OYW1lW1Rva2VuLk51bGxMaXRlcmFsXSA9ICdOdWxsJztcbiAgVG9rZW5OYW1lW1Rva2VuLk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcbiAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICBUb2tlbk5hbWVbVG9rZW4uU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcbiAgVG9rZW5OYW1lW1Rva2VuLlJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG5cbiAgU3ludGF4ID0ge1xuICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbidcbiAgfTtcblxuICBQcm9wZXJ0eUtpbmQgPSB7XG4gICAgICBEYXRhOiAxLFxuICAgICAgR2V0OiAyLFxuICAgICAgU2V0OiA0XG4gIH07XG5cbiAgLy8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cbiAgTWVzc2FnZXMgPSB7XG4gICAgICBVbmV4cGVjdGVkVG9rZW46ICAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXG4gICAgICBVbmV4cGVjdGVkTnVtYmVyOiAgJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcbiAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgICAgVW5leHBlY3RlZEVPUzogICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxuICAgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgIFVudGVybWluYXRlZFJlZ0V4cDogICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJyxcbiAgICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgIEludmFsaWRMSFNJbkZvckluOiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXG4gICAgICBOb0NhdGNoT3JGaW5hbGx5OiAgJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcbiAgICAgIFJlZGVjbGFyYXRpb246ICclMCBcXCclMVxcJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkJyxcbiAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcbiAgICAgIElsbGVnYWxSZXR1cm46ICdJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnQnLFxuICAgICAgU3RyaWN0TW9kZVdpdGg6ICAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG4gICAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAgJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0VmFyTmFtZTogICdWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UGFyYW1OYW1lOiAgJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcbiAgICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAgJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgU3RyaWN0RGVsZXRlOiAgJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXG4gICAgICBTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eTogICdEdXBsaWNhdGUgZGF0YSBwcm9wZXJ0eSBpbiBvYmplY3QgbGl0ZXJhbCBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBBY2Nlc3NvckRhdGFQcm9wZXJ0eTogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgZGF0YSBhbmQgYWNjZXNzb3IgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgIEFjY2Vzc29yR2V0U2V0OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBtdWx0aXBsZSBnZXQvc2V0IGFjY2Vzc29ycyB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgU3RyaWN0TEhTQXNzaWdubWVudDogICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdExIU1Bvc3RmaXg6ICAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdExIU1ByZWZpeDogICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJ1xuICB9O1xuXG4gIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXgucHkuXG4gIFJlZ2V4ID0ge1xuICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCMlxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyksXG4gICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEIyXFx1MDhFNC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OURcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJylcbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gIC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuICAvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cbiAgLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpOyAgIC8vIDAuLjlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCkgPj0gMDtcbiAgfVxuXG4gIC8vIDcuMiBXaGl0ZSBTcGFjZVxuXG4gIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxuICAgICAgICAgIChjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNoKSA+PSAwKTtcbiAgfVxuXG4gIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpO1xuICB9XG5cbiAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KSB8fCAgICAgICAgIC8vIDAuLjlcbiAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgfVxuXG4gIC8vIDcuNi4xLjIgRnV0dXJlIFJlc2VydmVkIFdvcmRzXG5cbiAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgIGNhc2UgJ3N1cGVyJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICBjYXNlICdpbXBsZW1lbnRzJzpcbiAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gIGZ1bmN0aW9uIGlzS2V5d29yZChpZCkge1xuICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vICdjb25zdCcgaXMgc3BlY2lhbGl6ZWQgYXMgS2V5d29yZCBpbiBWOC5cbiAgICAgIC8vICd5aWVsZCcgYW5kICdsZXQnIGFyZSBmb3IgY29tcGF0aWJsaXR5IHdpdGggU3BpZGVyTW9ua2V5IGFuZCBFUy5uZXh0LlxuICAgICAgLy8gU29tZSBvdGhlcnMgYXJlIGZyb20gZnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuXG4gICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgICAgdmFyIGNoLCBzdGFydDtcblxuICAgICAgc3RhcnQgPSAoaW5kZXggPT09IDApO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgwQSkge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgICAgIHZhciBpLCBsZW4sIGNoLCBjb2RlID0gMDtcblxuICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgICAgIHZhciBjaCwgY29kZSwgY3UxLCBjdTI7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGNvZGUgPSAwO1xuXG4gICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cbiAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVVRGLTE2IEVuY29kaW5nXG4gICAgICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgIH1cbiAgICAgIGN1MSA9ICgoY29kZSAtIDB4MTAwMDApID4+IDEwKSArIDB4RDgwMDtcbiAgICAgIGN1MiA9ICgoY29kZSAtIDB4MTAwMDApICYgMTAyMykgKyAweERDMDA7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjdTEsIGN1Mik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFc2NhcGVkSWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBjaCwgaWQ7XG5cbiAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclN0YXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWQgPSBjaDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIHN0YXJ0LCBjaDtcblxuICAgICAgc3RhcnQgPSBpbmRleCsrO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFc2NhcGVkSWRlbnRpZmllcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xuXG4gICAgICAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXG4gICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIC8vIDcuNyBQdW5jdHVhdG9yc1xuXG4gIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gaW5kZXgsXG4gICAgICAgICAgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSxcbiAgICAgICAgICBjb2RlMixcbiAgICAgICAgICBjaDEgPSBzb3VyY2VbaW5kZXhdLFxuICAgICAgICAgIGNoMixcbiAgICAgICAgICBjaDMsXG4gICAgICAgICAgY2g0O1xuXG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcblxuICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICBjYXNlIDB4MkU6ICAvLyAuIGRvdFxuICAgICAgY2FzZSAweDI4OiAgLy8gKCBvcGVuIGJyYWNrZXRcbiAgICAgIGNhc2UgMHgyOTogIC8vICkgY2xvc2UgYnJhY2tldFxuICAgICAgY2FzZSAweDNCOiAgLy8gOyBzZW1pY29sb25cbiAgICAgIGNhc2UgMHgyQzogIC8vICwgY29tbWFcbiAgICAgIGNhc2UgMHg3QjogIC8vIHsgb3BlbiBjdXJseSBicmFjZVxuICAgICAgY2FzZSAweDdEOiAgLy8gfSBjbG9zZSBjdXJseSBicmFjZVxuICAgICAgY2FzZSAweDVCOiAgLy8gW1xuICAgICAgY2FzZSAweDVEOiAgLy8gXVxuICAgICAgY2FzZSAweDNBOiAgLy8gOlxuICAgICAgY2FzZSAweDNGOiAgLy8gP1xuICAgICAgY2FzZSAweDdFOiAgLy8gflxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlID09PSAweDI4KSB7XG4gICAgICAgICAgICAgICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg3Qikge1xuICAgICAgICAgICAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2RlMiA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICAgICAgICAvLyAnPScgKFUrMDAzRCkgbWFya3MgYW4gYXNzaWdubWVudCBvciBjb21wYXJpc29uIG9wZXJhdG9yLlxuICAgICAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAweDJCOiAgLy8gK1xuICAgICAgICAgICAgICBjYXNlIDB4MkQ6ICAvLyAtXG4gICAgICAgICAgICAgIGNhc2UgMHgyRjogIC8vIC9cbiAgICAgICAgICAgICAgY2FzZSAweDNDOiAgLy8gPFxuICAgICAgICAgICAgICBjYXNlIDB4M0U6ICAvLyA+XG4gICAgICAgICAgICAgIGNhc2UgMHg1RTogIC8vIF5cbiAgICAgICAgICAgICAgY2FzZSAweDdDOiAgLy8gfFxuICAgICAgICAgICAgICBjYXNlIDB4MjU6ICAvLyAlXG4gICAgICAgICAgICAgIGNhc2UgMHgyNjogIC8vICZcbiAgICAgICAgICAgICAgY2FzZSAweDJBOiAgLy8gKlxuICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgY2FzZSAweDIxOiAvLyAhXG4gICAgICAgICAgICAgIGNhc2UgMHgzRDogLy8gPVxuICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgICAgICAgICAgICAgLy8gIT09IGFuZCA9PT1cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cbiAgICAgIGNoNCA9IHNvdXJjZS5zdWJzdHIoaW5kZXgsIDQpO1xuXG4gICAgICBpZiAoY2g0ID09PSAnPj4+PScpIHtcbiAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDQsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPT09ICE9PSA+Pj4gPDw9ID4+PVxuXG4gICAgICBjaDMgPSBjaDQuc3Vic3RyKDAsIDMpO1xuXG4gICAgICBpZiAoY2gzID09PSAnPj4+JyB8fCBjaDMgPT09ICc8PD0nIHx8IGNoMyA9PT0gJz4+PScpIHtcbiAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDMsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlciAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogKysgLS0gPDwgPj4gJiYgfHxcbiAgICAgIGNoMiA9IGNoMy5zdWJzdHIoMCwgMik7XG5cbiAgICAgIGlmICgoY2gxID09PSBjaDJbMV0gJiYgKCcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwKSkgfHwgY2gyID09PSAnPT4nKSB7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gyLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6IDwgPiA9ICEgKyAtICogJSAmIHwgXiAvXG5cbiAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgfVxuXG4gIC8vIDcuOC4zIE51bWVyaWMgTGl0ZXJhbHNcblxuICBmdW5jdGlvbiBzY2FuSGV4TGl0ZXJhbChzdGFydCkge1xuICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bWJlciwgMTYpLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICB2YXIgbnVtYmVyID0gJzAnICsgc291cmNlW2luZGV4KytdO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgICAgICAgb2N0YWw6IHRydWUsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgICAgIHZhciBudW1iZXIsIHN0YXJ0LCBjaDtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSxcbiAgICAgICAgICAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICBudW1iZXIgPSAnJztcbiAgICAgIGlmIChjaCAhPT0gJy4nKSB7XG4gICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgICAgICAgIC8vIEhleCBudW1iZXIgc3RhcnRzIHdpdGggJzB4Jy5cbiAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZGVjaW1hbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnIHN1Y2ggYXMgJzA5JyBpcyBpbGxlZ2FsLlxuICAgICAgICAgICAgICBpZiAoY2ggJiYgaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG4gIGZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgc3RhcnQsIGNoLCBjb2RlLCB1bmVzY2FwZWQsIHJlc3RvcmUsIG9jdGFsID0gZmFsc2UsIHN0YXJ0TGluZU51bWJlciwgc3RhcnRMaW5lU3RhcnQ7XG4gICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSxcbiAgICAgICAgICAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICArK2luZGV4O1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhcnRMaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICB2YXIgdG1wID0gcGF0dGVybixcbiAgICAgICAgICB2YWx1ZTtcblxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0byBhdm9pZCB0aHJvd2luZyBvblxuICAgICAgICAgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZVxuICAgICAgICAgIC8vIGAvdWAgZmxhZy5cbiAgICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgICAgICAgIC8vIG5lZ2F0aXZlcyBpbiB1bmxpa2VseSBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXs2MX0tYl1gIGlzIGFcbiAgICAgICAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgICAgICAgLy8gd291bGQgYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgdG1wID0gdG1wXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludCgkMSwgMTYpIDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd4JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHRtcCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XG4gICAgICAvLyB1c2VzLlxuICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICAgICAgdmFyIGNoLCBzdHIsIGNsYXNzTWFya2VyLCB0ZXJtaW5hdGVkLCBib2R5O1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYm9keSxcbiAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gICAgICB2YXIgY2gsIHN0ciwgZmxhZ3MsIHJlc3RvcmU7XG5cbiAgICAgIHN0ciA9ICcnO1xuICAgICAgZmxhZ3MgPSAnJztcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgaW5kZXg7ICsrcmVzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc291cmNlW3Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gICAgICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcblxuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgICAgIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XG4gICAgICB2YWx1ZSA9IHRlc3RSZWdFeHAoYm9keS52YWx1ZSwgZmxhZ3MudmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgdmFyIHBvcywgbG9jLCByZWdleCwgdG9rZW47XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWdleCA9IHNjYW5SZWdFeHAoKTtcblxuICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgIH07XG5cbiAgICAgIGlmICghZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyBsaWtlbHkgJy8nIG9yICcvPSdcbiAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBpZiAodG9rZW4ucmFuZ2VbMF0gPT09IHBvcyAmJiB0b2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICB2YWx1ZTogcmVnZXgubGl0ZXJhbCxcbiAgICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LnJlZ2V4LFxuICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnZXg7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgdmFyIHByZXZUb2tlbixcbiAgICAgICAgICBjaGVja1Rva2VuO1xuICAgICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxuICAgICAgcHJldlRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghcHJldlRva2VuKSB7XG4gICAgICAgICAgLy8gTm90aGluZyBiZWZvcmUgdGhhdDogaXQgY2Fubm90IGJlIGEgZGl2aXNpb24uXG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnXScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICcpJykge1xuICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5QYXJlblRva2VuIC0gMV07XG4gICAgICAgICAgICAgIGlmIChjaGVja1Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2lmJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2hpbGUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICdmb3InIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aXRoJykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdICYmXG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF07XG4gICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiYgcHJldlRva2VuLnZhbHVlICE9PSAndGhpcycpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkdmFuY2UoKSB7XG4gICAgICB2YXIgY2g7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5FT0YsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogaW5kZXgsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuICAgICAgaWYgKGNoID09PSAweDI4IHx8IGNoID09PSAweDI5IHx8IGNoID09PSAweDNCKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXG4gICAgICBpZiAoY2ggPT09IDB4MjcgfHwgY2ggPT09IDB4MjIpIHtcbiAgICAgICAgICByZXR1cm4gc2NhblN0cmluZ0xpdGVyYWwoKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBEb3QgKC4pIFUrMDAyRSBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcbiAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaCA9PT0gMHgyRSkge1xuICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTbGFzaCAoLykgVSswMDJGIGNhbiBhbHNvIHN0YXJ0IGEgcmVnZXguXG4gICAgICBpZiAoZXh0cmEudG9rZW5pemUgJiYgY2ggPT09IDB4MkYpIHtcbiAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdFRva2VuKCkge1xuICAgICAgdmFyIGxvYywgdG9rZW4sIHZhbHVlLCBlbnRyeTtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGxvYyA9IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdG9rZW4gPSBhZHZhbmNlKCk7XG4gICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgfTtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHZhbHVlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbk5hbWVbdG9rZW4udHlwZV0sXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgcmFuZ2U6IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXSxcbiAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHRva2VuLnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBmbGFnczogdG9rZW4ucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goZW50cnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICB2YXIgdG9rZW47XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuXG4gICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQ7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcbiAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBzdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICAgICAgdGhpcy5saW5lID0gbGluZU51bWJlcjtcbiAgICAgIHRoaXMuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQ7XG4gIH1cblxuICBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyYXBwaW5nU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbikge1xuICAgICAgaWYgKHN0YXJ0VG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4uc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0VG9rZW4uc3RhcnQgLSBzdGFydFRva2VuLnN0YXJ0TGluZVN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgbGluZTogc3RhcnRUb2tlbi5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0VG9rZW4uc3RhcnQgLSBzdGFydFRva2VuLmxpbmVTdGFydFxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgLy8gU2tpcCBjb21tZW50LlxuICAgICAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBsb29rYWhlYWQuc3RhcnRMaW5lU3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQubGluZU51bWJlcjtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBsb29rYWhlYWQubGluZVN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgdGhpcy5yYW5nZSA9IFtpbmRleCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSB7XG4gICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlID0gW3N0YXJ0VG9rZW4uc3RhcnQsIDBdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgIHRoaXMubG9jID0gbmV3IFdyYXBwaW5nU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbik7XG4gICAgICB9XG4gIH1cblxuICBXcmFwcGluZ05vZGUucHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICB0aGlzLnJhbmdlWzFdID0gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2MuZW5kID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubG9jLnNvdXJjZSA9IGV4dHJhLnNvdXJjZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFycmF5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJykgPyBTeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xuICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoSWRlbnRpZmllcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWRlbnRpZmllcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hMaXRlcmFsOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTGl0ZXJhbDtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgdGhpcy5yYXcgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnJhdyA9PSAnLy8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXcgPSAnLyg/OikvJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnJlZ2V4ID0gdG9rZW4ucmVnZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmNvbXB1dGVkID0gYWNjZXNzb3IgPT09ICdbJztcbiAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoUHJvZ3JhbTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvZ3JhbTtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hQcm9wZXJ0eTogZnVuY3Rpb24gKGtpbmQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvcGVydHk7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IChvcGVyYXRvciA9PT0gJysrJyB8fCBvcGVyYXRvciA9PT0gJy0tJykgPyBTeW50YXguVXBkYXRlRXhwcmVzc2lvbiA6IFN5bnRheC5VbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICB0aGlzLnByZWZpeCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIGxpbmUgdGVybWluYXRvciBiZWZvcmUgdGhlIG5leHQgdG9rZW4uXG5cbiAgZnVuY3Rpb24gcGVla0xpbmVUZXJtaW5hdG9yKCkge1xuICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgZm91bmQgPSBsaW5lTnVtYmVyICE9PSBsaW5lO1xuICAgICAgaW5kZXggPSBwb3M7XG4gICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuXG4gICAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvLyBUaHJvdyBhbiBleGNlcHRpb25cblxuICBmdW5jdGlvbiB0aHJvd0Vycm9yKHRva2VuLCBtZXNzYWdlRm9ybWF0KSB7XG4gICAgICB2YXIgZXJyb3IsXG4gICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAvJShcXGQpL2csXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGFzc2VydChpbmRleCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyB0b2tlbi5saW5lTnVtYmVyICsgJzogJyArIG1zZyk7XG4gICAgICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5zdGFydDtcbiAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgICAgICBlcnJvci5jb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxpbmVTdGFydCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyBsaW5lTnVtYmVyICsgJzogJyArIG1zZyk7XG4gICAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICBlcnJvci5jb2x1bW4gPSBpbmRleCAtIGxpbmVTdGFydCArIDE7XG4gICAgICB9XG5cbiAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gbXNnO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiB0aHJvd0Vycm9yVG9sZXJhbnQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIHRocm93RXJyb3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG5cblxuICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXG5cbiAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZEVPUyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cbiAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICB9XG5cbiAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbiAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgZXhwZWN0VG9sZXJhbnRcbiAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IHRoZSBnaXZlbiB0b2tlbiB2YWx1ZSB3aGVuIGluIHRvbGVyYW50IG1vZGUsIG90aGVyd2lzZSBkZWxlZ2F0ZXNcbiAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB3ZSBhcmUgZXhwZWN0aW5nIHRoZSBsb29rYWhlYWQgdG9rZW4gdG8gaGF2ZVxuICAgKiBAc2luY2UgMi4wXG4gICAqL1xuICBmdW5jdGlvbiBleHBlY3RUb2xlcmFudCh2YWx1ZSkge1xuICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGVjdCh2YWx1ZSk7XG4gICAgICB9XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxuICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICBmdW5jdGlvbiBleHBlY3RLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG5cbiAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICBmdW5jdGlvbiBtYXRjaEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIGxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgICB2YXIgbGluZTtcblxuICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzQiB8fCBtYXRjaCgnOycpKSB7XG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YgJiYgIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuXG4gIGZ1bmN0aW9uIGlzTGVmdEhhbmRTaWRlKGV4cHIpIHtcbiAgICAgIHJldHVybiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyIHx8IGV4cHIudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG4gIH1cblxuICAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV4KCk7XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gIH1cblxuICAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwga2V5LCBpZCwgdmFsdWUsIHBhcmFtLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRiB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXSwgdG9rZW4sIHByb3BlcnR5LCBuYW1lLCBrZXksIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgPSB0b1N0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBraW5kID0gKHByb3BlcnR5LmtpbmQgPT09ICdpbml0JykgPyBQcm9wZXJ0eUtpbmQuRGF0YSA6IChwcm9wZXJ0eS5raW5kID09PSAnZ2V0JykgPyBQcm9wZXJ0eUtpbmQuR2V0IDogUHJvcGVydHlLaW5kLlNldDtcblxuICAgICAgICAgIGtleSA9ICckJyArIG5hbWU7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKG1hcFtrZXldID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0RHVwbGljYXRlUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kICE9PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcFtrZXldICYga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JHZXRTZXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hcFtrZXldIHw9IGtpbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFwW2tleV0gPSBraW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgZXhwZWN0VG9sZXJhbnQoJywnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpO1xuICB9XG5cbiAgLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICArK3N0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cblxuICAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuICB2YXIgbGVnYWxLZXl3b3JkcyA9IHtcImlmXCI6MSwgXCJ0aGlzXCI6MX07XG5cbiAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0eXBlLCB0b2tlbiwgZXhwciwgbm9kZTtcblxuICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VHcm91cEV4cHJlc3Npb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKTtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8IGxlZ2FsS2V5d29yZHNbbG9va2FoZWFkLnZhbHVlXSkge1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWwpIHtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGNvbGxlY3RSZWdleCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBlZWsoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cbiAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwZWN0VG9sZXJhbnQoJywnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICB2YXIgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcbiAgICAgIGFzc2VydChzdGF0ZS5hbGxvd0luLCAnY2FsbGVlIG9mIG5ldyBleHByZXNzaW9uIGFsd2F5cyBhbGxvdyBpbiBrZXl3b3JkLicpO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgZXhwciA9IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgdG9rZW4sIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCBtYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCBtYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgIHZhciBwcmVjID0gMDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgcHJlYyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICBwcmVjID0gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgcHJlYyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHByZWMgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgICBwcmVjID0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPT0nOlxuICAgICAgY2FzZSAnIT0nOlxuICAgICAgY2FzZSAnPT09JzpcbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgcHJlYyA9IDY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgY2FzZSAnPic6XG4gICAgICBjYXNlICc8PSc6XG4gICAgICBjYXNlICc+PSc6XG4gICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICBwcmVjID0gNztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHByZWMgPSBhbGxvd0luID8gNyA6IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw8JzpcbiAgICAgIGNhc2UgJz4+JzpcbiAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgcHJlYyA9IDg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcHJlYyA9IDk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnLyc6XG4gICAgICBjYXNlICclJzpcbiAgICAgICAgICBwcmVjID0gMTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVjO1xuICB9XG5cbiAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4gIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gIC8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuICAvLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcblxuICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgbGV4KCk7XG5cbiAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIGV4cHIgPSBzdGFja1tpXTtcbiAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICB3aGlsZSAoaSA+IDEpIHtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzLnBvcCgpKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICBpIC09IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTIgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgc3RhcnRUb2tlbjtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBvbGRQYXJlbnRoZXNpc0NvdW50LCB0b2tlbiwgZXhwciwgcmlnaHQsIGxpc3QsIHN0YXJ0VG9rZW47XG5cbiAgICAgIG9sZFBhcmVudGhlc2lzQ291bnQgPSBzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjE0IENvbW1hIE9wZXJhdG9yXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIGV4cHJlc3Npb25zO1xuXG4gICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gbm8gc2VxdWVuY2UgZXhwcmVzc2lvbnNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMi40IEV4cHJlc3Npb24gU3RhdGVtZW50XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICB9XG5cbiAgLy8gMTIgU3RhdGVtZW50c1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICBleHByLFxuICAgICAgICAgIGxhYmVsZWRCb2R5LFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBibG9jayBzdGF0ZW1lbnRcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBlbXB0eSBzdGF0ZW1lbnRcbiAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGtleXdvcmRcbiAgICAgIH1cblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDE0IFByb2dyYW1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50cygpIHtcbiAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHBlZWsoKTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgc3RyaWN0ID0gdHJ1ZTsgLy8gYXNzdW1lIHN0cmljdFxuXG4gICAgICBib2R5ID0gcGFyc2VTb3VyY2VFbGVtZW50cygpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvZ3JhbShib2R5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChlbnRyeS5yZWdleCkge1xuICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBmbGFnczogZW50cnkucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICB0b2tlbnM7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICB9O1xuXG4gICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBmaWVsZHMgYXJlIG5lY2Vzc2FyeSB0byBjb21wdXRlIHRoZSBSZWdleCB0b2tlbnMuXG4gICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IC0xO1xuICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2gobGV4RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGxleEVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIHBhcmVudGhlc2lzQ291bnQ6IDAsXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4dHJhLnNvdXJjZSA9IHRvU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplLFxuICAgIHBhcnNlOiBwYXJzZVxuICB9O1xuXG59KSgpOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBheHMgPSByZXF1aXJlKCcuLi9zY2VuZS9heGlzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKTtcblxudmFyIE9SSUVOVCA9IHtcbiAgXCJ4XCI6ICAgICAgXCJib3R0b21cIixcbiAgXCJ5XCI6ICAgICAgXCJsZWZ0XCIsXG4gIFwidG9wXCI6ICAgIFwidG9wXCIsXG4gIFwiYm90dG9tXCI6IFwiYm90dG9tXCIsXG4gIFwibGVmdFwiOiAgIFwibGVmdFwiLFxuICBcInJpZ2h0XCI6ICBcInJpZ2h0XCJcbn07XG5cbmZ1bmN0aW9uIGF4ZXMobW9kZWwsIHNwZWMsIGF4ZXMsIGdyb3VwKSB7XG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICBheGVzW2luZGV4XSA9IGF4ZXNbaW5kZXhdIHx8IGF4cyhtb2RlbCk7XG4gICAgYXhpcyhkZWYsIGluZGV4LCBheGVzW2luZGV4XSwgZ3JvdXApO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGF4aXMoZGVmLCBpbmRleCwgYXhpcywgZ3JvdXApIHtcbiAgLy8gYXhpcyBzY2FsZVxuICBpZiAoZGVmLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBheGlzLnNjYWxlKGdyb3VwLnNjYWxlKGRlZi5zY2FsZSkpO1xuICB9XG5cbiAgLy8gYXhpcyBvcmllbnRhdGlvblxuICBheGlzLm9yaWVudChkZWYub3JpZW50IHx8IE9SSUVOVFtkZWYudHlwZV0pO1xuICAvLyBheGlzIG9mZnNldFxuICBheGlzLm9mZnNldChkZWYub2Zmc2V0IHx8IDApO1xuICAvLyBheGlzIGxheWVyXG4gIGF4aXMubGF5ZXIoZGVmLmxheWVyIHx8IFwiZnJvbnRcIik7XG4gIC8vIGF4aXMgZ3JpZCBsaW5lc1xuICBheGlzLmdyaWQoZGVmLmdyaWQgfHwgZmFsc2UpO1xuICAvLyBheGlzIHRpdGxlXG4gIGF4aXMudGl0bGUoZGVmLnRpdGxlIHx8IG51bGwpO1xuICAvLyBheGlzIHRpdGxlIG9mZnNldFxuICBheGlzLnRpdGxlT2Zmc2V0KGRlZi50aXRsZU9mZnNldCAhPSBudWxsXG4gICAgPyBkZWYudGl0bGVPZmZzZXQgOiBjb25maWcuYXhpcy50aXRsZU9mZnNldCk7XG4gIC8vIGF4aXMgdmFsdWVzXG4gIGF4aXMudGlja1ZhbHVlcyhkZWYudmFsdWVzIHx8IG51bGwpO1xuICAvLyBheGlzIGxhYmVsIGZvcm1hdHRpbmdcbiAgYXhpcy50aWNrRm9ybWF0KGRlZi5mb3JtYXQgfHwgbnVsbCk7XG4gIC8vIGF4aXMgdGljayBzdWJkaXZpc2lvblxuICBheGlzLnRpY2tTdWJkaXZpZGUoZGVmLnN1YmRpdmlkZSB8fCAwKTtcbiAgLy8gYXhpcyB0aWNrIHBhZGRpbmdcbiAgYXhpcy50aWNrUGFkZGluZyhkZWYudGlja1BhZGRpbmcgfHwgY29uZmlnLmF4aXMucGFkZGluZyk7XG5cbiAgLy8gYXhpcyB0aWNrIHNpemUocylcbiAgdmFyIHNpemUgPSBbXTtcbiAgaWYgKGRlZi50aWNrU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPDM7ICsraSkgc2l6ZS5wdXNoKGRlZi50aWNrU2l6ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRzID0gY29uZmlnLmF4aXMudGlja1NpemU7XG4gICAgc2l6ZSA9IFt0cywgdHMsIHRzXTtcbiAgfVxuICBpZiAoZGVmLnRpY2tTaXplTWFqb3IgIT0gbnVsbCkgc2l6ZVswXSA9IGRlZi50aWNrU2l6ZU1ham9yO1xuICBpZiAoZGVmLnRpY2tTaXplTWlub3IgIT0gbnVsbCkgc2l6ZVsxXSA9IGRlZi50aWNrU2l6ZU1pbm9yO1xuICBpZiAoZGVmLnRpY2tTaXplRW5kICAgIT0gbnVsbCkgc2l6ZVsyXSA9IGRlZi50aWNrU2l6ZUVuZDtcbiAgaWYgKHNpemUubGVuZ3RoKSB7XG4gICAgYXhpcy50aWNrU2l6ZS5hcHBseShheGlzLCBzaXplKTtcbiAgfVxuXG4gIC8vIHRpY2sgYXJndW1lbnRzXG4gIGlmIChkZWYudGlja3MgIT0gbnVsbCkge1xuICAgIHZhciB0aWNrcyA9IGRsLmlzQXJyYXkoZGVmLnRpY2tzKSA/IGRlZi50aWNrcyA6IFtkZWYudGlja3NdO1xuICAgIGF4aXMudGlja3MuYXBwbHkoYXhpcywgdGlja3MpO1xuICB9IGVsc2Uge1xuICAgIGF4aXMudGlja3MoY29uZmlnLmF4aXMudGlja3MpO1xuICB9XG5cbiAgLy8gc3R5bGUgcHJvcGVydGllc1xuICB2YXIgcCA9IGRlZi5wcm9wZXJ0aWVzO1xuICBpZiAocCAmJiBwLnRpY2tzKSB7XG4gICAgYXhpcy5tYWpvclRpY2tQcm9wZXJ0aWVzKHAubWFqb3JUaWNrc1xuICAgICAgPyBkbC5leHRlbmQoe30sIHAudGlja3MsIHAubWFqb3JUaWNrcykgOiBwLnRpY2tzKTtcbiAgICBheGlzLm1pbm9yVGlja1Byb3BlcnRpZXMocC5taW5vclRpY2tzXG4gICAgICA/IGRsLmV4dGVuZCh7fSwgcC50aWNrcywgcC5taW5vclRpY2tzKSA6IHAudGlja3MpO1xuICB9IGVsc2Uge1xuICAgIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyhwICYmIHAubWFqb3JUaWNrcyB8fCB7fSk7XG4gICAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzKHAgJiYgcC5taW5vclRpY2tzIHx8IHt9KTtcbiAgfVxuICBheGlzLnRpY2tMYWJlbFByb3BlcnRpZXMocCAmJiBwLmxhYmVscyB8fCB7fSk7XG4gIGF4aXMudGl0bGVQcm9wZXJ0aWVzKHAgJiYgcC50aXRsZSB8fCB7fSk7XG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzKHAgJiYgcC5ncmlkIHx8IHt9KTtcbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzKHAgJiYgcC5heGlzIHx8IHt9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBheGVzOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIHBhcnNlVHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtcycpLFxuICAgIHBhcnNlTW9kaWZ5ID0gcmVxdWlyZSgnLi9tb2RpZnknKTtcblxudmFyIHBhcnNlRGF0YSA9IGZ1bmN0aW9uKG1vZGVsLCBzcGVjLCBjYWxsYmFjaykge1xuICB2YXIgY291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGxvYWRlZChkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZGwuZXJyb3IoXCJMT0FESU5HIEZBSUxFRDogXCIgKyBkLnVybCArIFwiIFwiICsgZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuZGF0YShkLm5hbWUpLnZhbHVlcyhkbC5yZWFkKGRhdGEsIGQuZm9ybWF0KSk7XG4gICAgICB9XG4gICAgICBpZiAoLS1jb3VudCA9PT0gMCkgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm9jZXNzIGVhY2ggZGF0YSBzZXQgZGVmaW5pdGlvblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgaWYgKGQudXJsKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgZGwubG9hZChkbC5leHRlbmQoe3VybDogZC51cmx9LCBjb25maWcubG9hZCksIGxvYWRlZChkKSk7XG4gICAgfVxuICAgIHBhcnNlRGF0YS5kYXRhc291cmNlKG1vZGVsLCBkKTtcbiAgfSk7XG5cbiAgaWYgKGNvdW50ID09PSAwKSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5wYXJzZURhdGEuZGF0YXNvdXJjZSA9IGZ1bmN0aW9uKG1vZGVsLCBkKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSAoZC50cmFuc2Zvcm18fFtdKS5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCB0KSB9KSxcbiAgICAgIG1vZCA9IChkLm1vZGlmeXx8W10pLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1vZGlmeShtb2RlbCwgbSwgZCkgfSksXG4gICAgICBkcyA9IG1vZGVsLmRhdGEoZC5uYW1lLCBtb2QuY29uY2F0KHRyYW5zZm9ybSkpO1xuXG4gIGlmIChkLnZhbHVlcykge1xuICAgIGRzLnZhbHVlcyhkbC5yZWFkKGQudmFsdWVzLCBkLmZvcm1hdCkpO1xuICB9IGVsc2UgaWYgKGQuc291cmNlKSB7XG4gICAgZHMuc291cmNlKGQuc291cmNlKVxuICAgICAgLnJldmlzZXMoZHMucmV2aXNlcygpKSAvLyBJZiBuZXcgZHMgcmV2aXNlcywgdGhlbiBpdCdzIG9yaWdpbiBtdXN0IHJldmlzZSB0b28uXG4gICAgICAuYWRkTGlzdGVuZXIoZHMpOyAgLy8gRGVyaXZlZCBkcyB3aWxsIGJlIHB1bHNlZCBieSBpdHMgc3JjIHJhdGhlciB0aGFuIHRoZSBtb2RlbC5cbiAgICBtb2RlbC5yZW1vdmVMaXN0ZW5lcihkcy5waXBlbGluZSgpWzBdKTsgXG4gIH1cblxuICByZXR1cm4gZHM7ICAgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZURhdGE7XG4iLCIvKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjguMC5cbiAqXG4gKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gKi9cblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICB0aGlzLmZvdW5kICAgID0gZm91bmQ7XG4gIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XG4gIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xuXG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG59XG5cbnBlZyRzdWJjbGFzcyhTeW50YXhFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgc3RhcnQ6IHBlZyRwYXJzZXN0YXJ0IH0sXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlc3RhcnQsXG5cbiAgICAgIHBlZyRjMCA9IHBlZyRGQUlMRUQsXG4gICAgICBwZWckYzEgPSBcIixcIixcbiAgICAgIHBlZyRjMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIixcIiwgZGVzY3JpcHRpb246IFwiXFxcIixcXFwiXCIgfSxcbiAgICAgIHBlZyRjMyA9IGZ1bmN0aW9uKG8sIG0pIHsgcmV0dXJuIFtvXS5jb25jYXQobSkgfSxcbiAgICAgIHBlZyRjNCA9IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFtvXSB9LFxuICAgICAgcGVnJGM1ID0gXCJbXCIsXG4gICAgICBwZWckYzYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJbXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJbXFxcIlwiIH0sXG4gICAgICBwZWckYzcgPSBcIl1cIixcbiAgICAgIHBlZyRjOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl1cIiwgZGVzY3JpcHRpb246IFwiXFxcIl1cXFwiXCIgfSxcbiAgICAgIHBlZyRjOSA9IFwiPlwiLFxuICAgICAgcGVnJGMxMCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj5cIiwgZGVzY3JpcHRpb246IFwiXFxcIj5cXFwiXCIgfSxcbiAgICAgIHBlZyRjMTEgPSBmdW5jdGlvbihmMSwgZjIsIG8pIHsgcmV0dXJuIHtzdGFydDogZjEsIGVuZDogZjIsIG1pZGRsZTogb319LFxuICAgICAgcGVnJGMxMiA9IFtdLFxuICAgICAgcGVnJGMxMyA9IGZ1bmN0aW9uKHMsIGYpIHsgcmV0dXJuIChzLmZpbHRlcnMgPSBmKSwgcyB9LFxuICAgICAgcGVnJGMxNCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgfSxcbiAgICAgIHBlZyRjMTUgPSBudWxsLFxuICAgICAgcGVnJGMxNiA9IGZ1bmN0aW9uKHQsIGUpIHsgcmV0dXJuIHsgZXZlbnQ6IGUsIHRhcmdldDogdCB9IH0sXG4gICAgICBwZWckYzE3ID0gL15bOmEtekEtejAtOV9cXC1dLyxcbiAgICAgIHBlZyRjMTggPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzphLXpBLXowLTlfXFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIls6YS16QS16MC05X1xcXFwtXVwiIH0sXG4gICAgICBwZWckYzE5ID0gZnVuY3Rpb24ocykgeyByZXR1cm4geyBzaWduYWw6IHMuam9pbihcIlwiKSB9fSxcbiAgICAgIHBlZyRjMjAgPSBcIihcIixcbiAgICAgIHBlZyRjMjEgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIoXFxcIlwiIH0sXG4gICAgICBwZWckYzIyID0gXCIpXCIsXG4gICAgICBwZWckYzIzID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKVxcXCJcIiB9LFxuICAgICAgcGVnJGMyNCA9IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHsgc3RyZWFtOiBtIH19LFxuICAgICAgcGVnJGMyNSA9IFwiLlwiLFxuICAgICAgcGVnJGMyNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgIHBlZyRjMjcgPSBcIjpcIixcbiAgICAgIHBlZyRjMjggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6XFxcIlwiIH0sXG4gICAgICBwZWckYzI5ID0gZnVuY3Rpb24oYykgeyByZXR1cm4geyB0eXBlOidjbGFzcycsIHZhbHVlOiBjIH0gfSxcbiAgICAgIHBlZyRjMzAgPSBcIiNcIixcbiAgICAgIHBlZyRjMzEgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIjXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIjXFxcIlwiIH0sXG4gICAgICBwZWckYzMyID0gZnVuY3Rpb24oaWQpIHsgcmV0dXJuIHsgdHlwZTonaWQnLCB2YWx1ZTogaWQgfSB9LFxuICAgICAgcGVnJGMzMyA9IFwibW91c2Vkb3duXCIsXG4gICAgICBwZWckYzM0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2Vkb3duXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZWRvd25cXFwiXCIgfSxcbiAgICAgIHBlZyRjMzUgPSBcIm1vdXNldXBcIixcbiAgICAgIHBlZyRjMzYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZXVwXFxcIlwiIH0sXG4gICAgICBwZWckYzM3ID0gXCJjbGlja1wiLFxuICAgICAgcGVnJGMzOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImNsaWNrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJjbGlja1xcXCJcIiB9LFxuICAgICAgcGVnJGMzOSA9IFwiZGJsY2xpY2tcIixcbiAgICAgIHBlZyRjNDAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJkYmxjbGlja1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiZGJsY2xpY2tcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDEgPSBcIndoZWVsXCIsXG4gICAgICBwZWckYzQyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwid2hlZWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIndoZWVsXFxcIlwiIH0sXG4gICAgICBwZWckYzQzID0gXCJrZXlkb3duXCIsXG4gICAgICBwZWckYzQ0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5ZG93blwiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5ZG93blxcXCJcIiB9LFxuICAgICAgcGVnJGM0NSA9IFwia2V5cHJlc3NcIixcbiAgICAgIHBlZyRjNDYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXlwcmVzc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5cHJlc3NcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDcgPSBcImtleXVwXCIsXG4gICAgICBwZWckYzQ4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5dXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImtleXVwXFxcIlwiIH0sXG4gICAgICBwZWckYzQ5ID0gXCJtb3VzZXdoZWVsXCIsXG4gICAgICBwZWckYzUwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2V3aGVlbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2V3aGVlbFxcXCJcIiB9LFxuICAgICAgcGVnJGM1MSA9IFwibW91c2Vtb3ZlXCIsXG4gICAgICBwZWckYzUyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2Vtb3ZlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW1vdmVcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTMgPSBcIm1vdXNlb3V0XCIsXG4gICAgICBwZWckYzU0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VvdXRcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlb3V0XFxcIlwiIH0sXG4gICAgICBwZWckYzU1ID0gXCJtb3VzZW92ZXJcIixcbiAgICAgIHBlZyRjNTYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW92ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlb3ZlclxcXCJcIiB9LFxuICAgICAgcGVnJGM1NyA9IFwibW91c2VlbnRlclwiLFxuICAgICAgcGVnJGM1OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlZW50ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlZW50ZXJcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTkgPSBcInRvdWNoc3RhcnRcIixcbiAgICAgIHBlZyRjNjAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaHN0YXJ0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaHN0YXJ0XFxcIlwiIH0sXG4gICAgICBwZWckYzYxID0gXCJ0b3VjaG1vdmVcIixcbiAgICAgIHBlZyRjNjIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaG1vdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNobW92ZVxcXCJcIiB9LFxuICAgICAgcGVnJGM2MyA9IFwidG91Y2hlbmRcIixcbiAgICAgIHBlZyRjNjQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaGVuZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidG91Y2hlbmRcXFwiXCIgfSxcbiAgICAgIHBlZyRjNjUgPSBmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGQgIH0sXG4gICAgICBwZWckYzY2ID0gL15bJ1wiYS16QS1aMC05Xy4+PD0hIFxcdFxcLV0vLFxuICAgICAgcGVnJGM2NyA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbJ1xcXCJhLXpBLVowLTlfLj48PSEgXFxcXHRcXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiWydcXFwiYS16QS1aMC05Xy4+PD0hIFxcXFx0XFxcXC1dXCIgfSxcbiAgICAgIHBlZyRjNjggPSBmdW5jdGlvbih2KSB7IHJldHVybiB2LmpvaW4oXCJcIikgfSxcbiAgICAgIHBlZyRjNjkgPSAvXlsgXFx0XFxyXFxuXS8sXG4gICAgICBwZWckYzcwID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsgXFxcXHRcXFxcclxcXFxuXVwiLCBkZXNjcmlwdGlvbjogXCJbIFxcXFx0XFxcXHJcXFxcbl1cIiB9LFxuXG4gICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXG4gICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXG4gICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICBwZWckcmVzdWx0O1xuXG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lKCkge1xuICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sdW1uKCkge1xuICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbikge1xuICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgIG51bGwsXG4gICAgICBbeyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9XSxcbiAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIG51bGwsIHBlZyRyZXBvcnRlZFBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgZnVuY3Rpb24gYWR2YW5jZShkZXRhaWxzLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICB2YXIgcCwgY2g7XG5cbiAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7XG4gICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7XG4gICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykge1xuICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgIH1cblxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgZXhwZWN0ZWQsIHBvcykge1xuICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB3aGlsZSAoaSA8IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICBpZiAoZXhwZWN0ZWRbaSAtIDFdID09PSBleHBlY3RlZFtpXSkge1xuICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykge1xuICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgICAgICByZXR1cm4gc1xuICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICAgJ1xcXFxcXFxcJylcbiAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAgICdcXFxcdCcpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAgICdcXFxccicpXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMTgwLVxcdTBGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdTAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW1xcdTEwODAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4cGVjdGVkRGVzY3MgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcbiAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdGVkRGVzY3NbaV0gPSBleHBlY3RlZFtpXS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICA/IGV4cGVjdGVkRGVzY3Muc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgIDogZXhwZWN0ZWREZXNjc1swXTtcblxuICAgICAgZm91bmREZXNjID0gZm91bmQgPyBcIlxcXCJcIiArIHN0cmluZ0VzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG5cbiAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgfVxuXG4gICAgdmFyIHBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSxcbiAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgIGlmIChleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKFxuICAgICAgbWVzc2FnZSAhPT0gbnVsbCA/IG1lc3NhZ2UgOiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgZm91bmQsXG4gICAgICBwb3MsXG4gICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICBwb3NEZXRhaWxzLmNvbHVtblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzdGFydCgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbWVyZ2VkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgIHMzID0gcGVnJGMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMyhzMSwgczUpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM0KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlb3JkZXJlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMCwgczExLCBzMTIsIHMxMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgczEgPSBwZWckYzU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckYzE7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJGM3O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJGM5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMyA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMShzMywgczcsIHMxMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZpbHRlcmVkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VzdHJlYW0oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcigpO1xuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTMoczEsIHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlc3RyZWFtKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXN0cmVhbSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlY2xhc3MoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlaWQoKTtcbiAgICB9XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRjMTU7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VldmVudFR5cGUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE2KHMxLCBzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBpZiAocGVnJGMxNy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTgpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE5KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkge1xuICAgICAgICAgIHMxID0gcGVnJGMyMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjEpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VtZXJnZWQoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckYzIyO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMyNChzMik7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlY2xhc3MoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICBzMSA9IHBlZyRjMjU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjYpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMjc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMyOShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWlkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNSkge1xuICAgICAgczEgPSBwZWckYzMwO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMxKTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMzIoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VldmVudFR5cGUoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjMzMpIHtcbiAgICAgIHMwID0gcGVnJGMzMztcbiAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNCk7IH1cbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGMzNSkge1xuICAgICAgICBzMCA9IHBlZyRjMzU7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGMzNykge1xuICAgICAgICAgIHMwID0gcGVnJGMzNztcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjMzkpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGMzOTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0MCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0MSkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjNDE7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Mik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGM0Mykge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0MztcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDQpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNDUpIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0NTtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Nik7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0Nykge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDc7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OCk7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1MCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM1MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzUxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Nik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzU5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM2MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjIpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmaWx0ZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICBzMSA9IHBlZyRjNTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgczMgPSBwZWckYzc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzY1KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgaWYgKHBlZyRjNjYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY3KTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgaWYgKHBlZyRjNjYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjcpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjNjgoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc2VwKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBzMCA9IFtdO1xuICAgIGlmIChwZWckYzY5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MCk7IH1cbiAgICB9XG4gICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMC5wdXNoKHMxKTtcbiAgICAgIGlmIChwZWckYzY5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgcGVnJHJlc3VsdCA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbigpO1xuXG4gIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTeW50YXhFcnJvcjogU3ludGF4RXJyb3IsXG4gIHBhcnNlOiAgICAgICBwYXJzZVxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL2V4cHJlc3Npb24nKTtcblxudmFyIGV4cHIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJzZSA9IGV4cHJlc3Npb24ucGFyc2U7XG4gIHZhciBjb2RlZ2VuID0gZXhwcmVzc2lvbi5jb2RlKHtcbiAgICBpZFdoaXRlTGlzdDogWydkJywgJ2UnLCAnaScsICdwJywgJ3NnJ11cbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGV4cHIpIHsgICAgXG4gICAgdmFyIHZhbHVlID0gY29kZWdlbihwYXJzZShleHByKSk7XG4gICAgdmFsdWUuZm4gPSBGdW5jdGlvbignZCcsICdlJywgJ2knLCAncCcsICdzZycsXG4gICAgICAnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIHZhbHVlLmZuICsgJyk7Jyk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSkoKTtcblxuZXhwci5ldmFsID0gZnVuY3Rpb24oZ3JhcGgsIGZuLCBkLCBlLCBpLCBwLCBzZykge1xuICBzZyA9IGdyYXBoLnNpZ25hbFZhbHVlcyhkbC5hcnJheShzZykpO1xuICByZXR1cm4gZm4uY2FsbChudWxsLCBkLCBlLCBpLCBwLCBzZyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cHI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VJbnRlcmFjdG9ycyhtb2RlbCwgc3BlYywgZGVmRmFjdG9yeSkge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgc2cgPSB7fSwgcGQgPSB7fSwgbWsgPSB7fSxcbiAgICAgIHNpZ25hbHMgPSBbXSwgcHJlZGljYXRlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGxvYWRlZChpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZGwuZXJyb3IoXCJMT0FESU5HIEZBSUxFRDogXCIgKyBpLnVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVmID0gZGwuaXNPYmplY3QoZGF0YSkgPyBkYXRhIDogSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgaW50ZXJhY3RvcihpLm5hbWUsIGRlZik7XG4gICAgICB9XG4gICAgICBpZiAoLS1jb3VudCA9PSAwKSBpbmplY3QoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcmFjdG9yKG5hbWUsIGRlZikge1xuICAgIHNnID0ge30sIHBkID0ge307XG4gICAgaWYgKGRlZi5zaWduYWxzKSAgICBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgbnNTaWduYWxzKG5hbWUsIGRlZi5zaWduYWxzKSk7XG4gICAgaWYgKGRlZi5wcmVkaWNhdGVzKSBwcmVkaWNhdGVzLnB1c2guYXBwbHkocHJlZGljYXRlcywgbnNQcmVkaWNhdGVzKG5hbWUsIGRlZi5wcmVkaWNhdGVzKSk7XG4gICAgbnNNYXJrcyhuYW1lLCBkZWYubWFya3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgIGlmIChkbC5rZXlzKG1rKS5sZW5ndGggPiAwKSBpbmplY3RNYXJrcyhzcGVjLm1hcmtzKTtcbiAgICBzcGVjLnNpZ25hbHMgPSBkbC5hcnJheShzcGVjLnNpZ25hbHMpO1xuICAgIHNwZWMucHJlZGljYXRlcyA9IGRsLmFycmF5KHNwZWMucHJlZGljYXRlcyk7XG4gICAgc3BlYy5zaWduYWxzLnVuc2hpZnQuYXBwbHkoc3BlYy5zaWduYWxzLCBzaWduYWxzKTtcbiAgICBzcGVjLnByZWRpY2F0ZXMudW5zaGlmdC5hcHBseShzcGVjLnByZWRpY2F0ZXMsIHByZWRpY2F0ZXMpO1xuICAgIGRlZkZhY3RvcnkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdE1hcmtzKG1hcmtzKSB7XG4gICAgdmFyIG0sIHIsIGksIGxlbjtcbiAgICBtYXJrcyA9IGRsLmFycmF5KG1hcmtzKTtcblxuICAgIGZvcihpID0gMCwgbGVuID0gbWFya3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG0gPSBtYXJrc1tpXTtcbiAgICAgIGlmIChyID0gbWtbbS50eXBlXSkge1xuICAgICAgICBtYXJrc1tpXSA9IGRsLmR1cGxpY2F0ZShyKTtcbiAgICAgICAgaWYgKG0uZnJvbSkgbWFya3NbaV0uZnJvbSA9IG0uZnJvbTtcbiAgICAgICAgaWYgKG0ucHJvcGVydGllcykge1xuICAgICAgICAgIFtDLkVOVEVSLCBDLlVQREFURSwgQy5FWElUXS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIG1hcmtzW2ldLnByb3BlcnRpZXNbcF0gPSBkbC5leHRlbmQoci5wcm9wZXJ0aWVzW3BdLCBtLnByb3BlcnRpZXNbcF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG0ubWFya3MpIHsgIC8vIFRPRE8gaG93IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgbmVzdGVkIG1hcmtzP1xuICAgICAgICBpbmplY3RNYXJrcyhtLm1hcmtzKTtcbiAgICAgIH1cbiAgICB9ICAgIFxuICB9XG5cbiAgZnVuY3Rpb24gbnMobiwgcykgeyBcbiAgICBpZiAoZGwuaXNTdHJpbmcocykpIHtcbiAgICAgIHJldHVybiBzICsgXCJfXCIgKyBuO1xuICAgIH0gZWxzZSB7XG4gICAgICBkbC5rZXlzKHMpLmZvckVhY2goZnVuY3Rpb24oeCkgeyBcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXGInK3grJ1xcXFxiJywgXCJnXCIpO1xuICAgICAgICBuID0gbi5yZXBsYWNlKHJlZ2V4LCBzW3hdKSBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbnNTaWduYWxzKG5hbWUsIHNpZ25hbHMpIHtcbiAgICBzaWduYWxzID0gZGwuYXJyYXkoc2lnbmFscyk7XG4gICAgLy8gVHdvIHBhc3NlcyB0byBucyBhbGwgc2lnbmFscywgYW5kIHRoZW4gb3ZlcndyaXRlIHRoZWlyIGRlZmluaXRpb25zXG4gICAgLy8gaW4gY2FzZSBzaWduYWwgb3JkZXIgaXMgaW1wb3J0YW50LlxuICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IHMubmFtZSA9IHNnW3MubmFtZV0gPSBucyhzLm5hbWUsIG5hbWUpOyB9KTtcbiAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgKHMuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIHQudHlwZSA9IG5zKHQudHlwZSwgc2cpO1xuICAgICAgICB0LmV4cHIgPSBucyh0LmV4cHIsIHNnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzaWduYWxzO1xuICB9XG5cbiAgZnVuY3Rpb24gbnNQcmVkaWNhdGVzKG5hbWUsIHByZWRpY2F0ZXMpIHtcbiAgICBwcmVkaWNhdGVzID0gZGwuYXJyYXkocHJlZGljYXRlcyk7XG4gICAgcHJlZGljYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHAubmFtZSA9IHBkW3AubmFtZV0gPSBucyhwLm5hbWUsIG5hbWUpO1xuXG4gICAgICBbcC5vcGVyYW5kcywgcC5yYW5nZV0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICh4IHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoby5zaWduYWwpIG8uc2lnbmFsID0gbnMoby5zaWduYWwsIHNnKTtcbiAgICAgICAgICBlbHNlIGlmIChvLnByZWRpY2F0ZSkgbnNPcGVyYW5kKG8pO1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICB9KTsgIFxuICAgIHJldHVybiBwcmVkaWNhdGVzOyBcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zT3BlcmFuZChvKSB7XG4gICAgby5wcmVkaWNhdGUgPSBwZFtvLnByZWRpY2F0ZV07XG4gICAgZGwua2V5cyhvLmlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBpID0gby5pbnB1dFtrXTtcbiAgICAgIGlmIChpLnNpZ25hbCkgaS5zaWduYWwgPSBucyhpLnNpZ25hbCwgc2cpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbnNNYXJrcyhuYW1lLCBtYXJrcykge1xuICAgIChtYXJrcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihtKSB7IFxuICAgICAgbnNQcm9wZXJ0aWVzKG0ucHJvcGVydGllcy5lbnRlcik7XG4gICAgICBuc1Byb3BlcnRpZXMobS5wcm9wZXJ0aWVzLnVwZGF0ZSk7XG4gICAgICBuc1Byb3BlcnRpZXMobS5wcm9wZXJ0aWVzLmV4aXQpO1xuICAgICAgbWtbbnMobS5uYW1lLCBuYW1lKV0gPSBtOyBcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zUHJvcGVydGllcyhwcm9wc2V0KSB7XG4gICAgZGwua2V5cyhwcm9wc2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBwID0gcHJvcHNldFtrXTtcbiAgICAgIGlmIChwLnNpZ25hbCkgcC5zaWduYWwgPSBucyhwLnNpZ25hbCwgc2cpO1xuICAgICAgZWxzZSBpZiAocC5ydWxlKSB7XG4gICAgICAgIHAucnVsZS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHsgXG4gICAgICAgICAgaWYgKHIuc2lnbmFsKSByLnNpZ25hbCA9IG5zKHIuc2lnbmFsLCBzZyk7XG4gICAgICAgICAgaWYgKHIucHJlZGljYXRlKSBuc09wZXJhbmQocik7IFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIChzcGVjLmludGVyYWN0b3JzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaS51cmwpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiBpLnVybH0sIGNvbmZpZy5sb2FkKSwgbG9hZGVkKGkpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCA9PT0gMCkgc2V0VGltZW91dChpbmplY3QsIDEpO1xuICByZXR1cm4gc3BlYztcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgcGFyc2VQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VNYXJrKG1vZGVsLCBtYXJrKSB7XG4gIHZhciBwcm9wcyA9IG1hcmsucHJvcGVydGllcyxcbiAgICAgIGdyb3VwID0gbWFyay5tYXJrcztcblxuICAvLyBwYXJzZSBtYXJrIHByb3BlcnR5IGRlZmluaXRpb25zXG4gIGRsLmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHByb3BzW2tdID0gcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLnR5cGUsIHByb3BzW2tdKTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgZGVsYXkgZnVuY3Rpb25cbiAgaWYgKG1hcmsuZGVsYXkpIHtcbiAgICBtYXJrLmRlbGF5ID0gcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLnR5cGUsIHtkZWxheTogbWFyay5kZWxheX0pO1xuICB9XG5cbiAgLy8gcmVjdXJzZSBpZiBncm91cCB0eXBlXG4gIGlmIChncm91cCkge1xuICAgIG1hcmsubWFya3MgPSBncm91cC5tYXAoZnVuY3Rpb24oZykgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBnKTsgfSk7XG4gIH1cbiAgICBcbiAgcmV0dXJuIG1hcms7XG59OyIsInZhciBwYXJzZU1hcmsgPSByZXF1aXJlKCcuL21hcmsnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2RlbCwgc3BlYywgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgc2NhbGVzOiBzcGVjLnNjYWxlcyB8fCBbXSxcbiAgICBheGVzOiBzcGVjLmF4ZXMgfHwgW10sXG4gICAgLy8gbGVnZW5kczogc3BlYy5sZWdlbmRzIHx8IFtdLFxuICAgIG1hcmtzOiAoc3BlYy5tYXJrcyB8fCBbXSkubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pXG4gIH07XG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgc3JjLCBkZXN0KSB7XG4gIGZvcih2YXIgaSA9IHNyYy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZihzcmNbaV1bZmllbGRdID09IHZhbHVlKVxuICAgICAgZGVzdC5wdXNoLmFwcGx5KGRlc3QsIHNyYy5zcGxpY2UoaSwgMSkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTW9kaWZ5KG1vZGVsLCBkZWYsIGRzKSB7XG4gIHZhciBzaWduYWwgPSBkZWYuc2lnbmFsID8gZGwuZmllbGQoZGVmLnNpZ25hbCkgOiBudWxsLCBcbiAgICAgIHNpZ25hbE5hbWUgPSBzaWduYWwgPyBzaWduYWxbMF0gOiBudWxsLFxuICAgICAgcHJlZGljYXRlID0gZGVmLnByZWRpY2F0ZSA/IG1vZGVsLnByZWRpY2F0ZShkZWYucHJlZGljYXRlKSA6IG51bGwsXG4gICAgICByZWV2YWwgPSAocHJlZGljYXRlID09PSBudWxsKSxcbiAgICAgIG5vZGUgPSBuZXcgTm9kZShtb2RlbCk7XG5cbiAgbm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYocHJlZGljYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGIgPSB7fTtcbiAgICAgIChwcmVkaWNhdGUuZGF0YXx8W10pLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkYltkXSA9IG1vZGVsLmRhdGEoZCkudmFsdWVzKCk7IH0pO1xuXG4gICAgICAvLyBUT0RPOiBpbnB1dFxuICAgICAgcmVldmFsID0gcHJlZGljYXRlLmNhbGwocHJlZGljYXRlLCB7fSwgZGIsIG1vZGVsLnNpZ25hbFZhbHVlcyhwcmVkaWNhdGUuc2lnbmFsc3x8W10pLCBtb2RlbC5fcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgZGVidWcoaW5wdXQsIFtkZWYudHlwZStcImluZ1wiLCByZWV2YWxdKTtcbiAgICBpZighcmVldmFsKSByZXR1cm4gaW5wdXQ7XG5cbiAgICB2YXIgZGF0dW0gPSB7fSwgXG4gICAgICAgIHZhbHVlID0gc2lnbmFsID8gbW9kZWwuc2lnbmFsUmVmKGRlZi5zaWduYWwpIDogbnVsbCxcbiAgICAgICAgZCA9IG1vZGVsLmRhdGEoZHMubmFtZSksXG4gICAgICAgIHByZXYgPSBkLnJldmlzZXMoKSA/IG51bGwgOiB1bmRlZmluZWQsXG4gICAgICAgIHQgPSBudWxsO1xuXG4gICAgZGF0dW1bZGVmLmZpZWxkXSA9IHZhbHVlO1xuXG4gICAgLy8gV2UgaGF2ZSB0byBtb2RpZnkgZHMuX2RhdGEgc28gdGhhdCBzdWJzZXF1ZW50IHB1bHNlcyBjb250YWluXG4gICAgLy8gb3VyIGR5bmFtaWMgZGF0YS4gVy9vIG1vZGlmeWluZyBkcy5fZGF0YSwgb25seSB0aGUgb3V0cHV0XG4gICAgLy8gY29sbGVjdG9yIHdpbGwgY29udGFpbiBkeW5hbWljIHR1cGxlcy4gXG4gICAgaWYoZGVmLnR5cGUgPT0gQy5BREQpIHtcbiAgICAgIHQgPSB0dXBsZS5pbmdlc3QoZGF0dW0sIHByZXYpO1xuICAgICAgaW5wdXQuYWRkLnB1c2godCk7XG4gICAgICBkLl9kYXRhLnB1c2godCk7XG4gICAgfSBlbHNlIGlmKGRlZi50eXBlID09IEMuUkVNT1ZFKSB7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQuYWRkLCBpbnB1dC5yZW0pO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0Lm1vZCwgaW5wdXQucmVtKTtcbiAgICAgIGQuX2RhdGEgPSBkLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4W2RlZi5maWVsZF0gIT09IHZhbHVlIH0pO1xuICAgIH0gZWxzZSBpZihkZWYudHlwZSA9PSBDLlRPR0dMRSkge1xuICAgICAgdmFyIGFkZCA9IFtdLCByZW0gPSBbXTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5yZW0sIGFkZCk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQuYWRkLCByZW0pO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0Lm1vZCwgcmVtKTtcbiAgICAgIGlmKGFkZC5sZW5ndGggPT0gMCAmJiByZW0ubGVuZ3RoID09IDApIGFkZC5wdXNoKHR1cGxlLmluZ2VzdChkYXR1bSkpO1xuXG4gICAgICBpbnB1dC5hZGQucHVzaC5hcHBseShpbnB1dC5hZGQsIGFkZCk7XG4gICAgICBkLl9kYXRhLnB1c2guYXBwbHkoZC5fZGF0YSwgYWRkKTtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgcmVtKTtcbiAgICAgIGQuX2RhdGEgPSBkLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW0uaW5kZXhPZih4KSA9PT0gLTEgfSk7XG4gICAgfSBlbHNlIGlmKGRlZi50eXBlID09IEMuQ0xFQVIpIHtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgaW5wdXQuYWRkKTtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgaW5wdXQubW9kKTtcbiAgICAgIGlucHV0LmFkZCA9IFtdO1xuICAgICAgaW5wdXQubW9kID0gW107XG4gICAgICBkLl9kYXRhICA9IFtdO1xuICAgIH0gXG5cbiAgICBpbnB1dC5maWVsZHNbZGVmLmZpZWxkXSA9IDE7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIGlmKHNpZ25hbE5hbWUpIG5vZGUuZGVwZW5kZW5jeShDLlNJR05BTFMsIHNpZ25hbE5hbWUpO1xuICBpZihwcmVkaWNhdGUpICBub2RlLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBwcmVkaWNhdGUuc2lnbmFscyk7XG4gIFxuICByZXR1cm4gbm9kZTtcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZCkge1xuICBpZiAocGFkID09IG51bGwpIHJldHVybiBcImF1dG9cIjtcbiAgZWxzZSBpZiAoZGwuaXNTdHJpbmcocGFkKSkgcmV0dXJuIHBhZD09PVwic3RyaWN0XCIgPyBcInN0cmljdFwiIDogXCJhdXRvXCI7XG4gIGVsc2UgaWYgKGRsLmlzT2JqZWN0KHBhZCkpIHJldHVybiBwYWQ7XG4gIHZhciBwID0gZGwuaXNOdW1iZXIocGFkKSA/IHBhZCA6IDIwO1xuICByZXR1cm4ge3RvcDpwLCBsZWZ0OnAsIHJpZ2h0OnAsIGJvdHRvbTpwfTtcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQcmVkaWNhdGUobW9kZWwsIHNwZWMpIHtcbiAgdmFyIHR5cGVzID0ge1xuICAgICc9JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPT0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJyE9JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICc+JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPj0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJzwnOiAgcGFyc2VDb21wYXJhdG9yLFxuICAgICc8PSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnYW5kJzogcGFyc2VMb2dpY2FsLFxuICAgICcmJic6ICBwYXJzZUxvZ2ljYWwsXG4gICAgJ29yJzogIHBhcnNlTG9naWNhbCxcbiAgICAnfHwnOiAgcGFyc2VMb2dpY2FsLFxuICAgICdpbic6IHBhcnNlSW5cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZVNpZ25hbChzaWduYWwsIHNpZ25hbHMpIHtcbiAgICB2YXIgcyA9IGRsLmZpZWxkKHNpZ25hbCksXG4gICAgICAgIGNvZGUgPSBcInNpZ25hbHNbXCIrcy5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCI7XG4gICAgc2lnbmFsc1tzLnNoaWZ0KCldID0gMTtcbiAgICByZXR1cm4gY29kZTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZU9wZXJhbmRzKG9wZXJhbmRzKSB7XG4gICAgdmFyIGRlY2wgPSBbXSwgZGVmcyA9IFtdLFxuICAgICAgICBzaWduYWxzID0ge30sIGRiID0ge307XG5cbiAgICBkbC5hcnJheShvcGVyYW5kcykuZm9yRWFjaChmdW5jdGlvbihvLCBpKSB7XG4gICAgICB2YXIgc2lnbmFsLCBuYW1lID0gXCJvXCIraSwgZGVmID0gXCJcIjtcbiAgICAgIFxuICAgICAgaWYoby52YWx1ZSAhPT0gdW5kZWZpbmVkKSBkZWYgPSBkbC5zdHIoby52YWx1ZSk7XG4gICAgICBlbHNlIGlmKG8uYXJnKSAgICBkZWYgPSBcImFyZ3NbXCIrZGwuc3RyKG8uYXJnKStcIl1cIjtcbiAgICAgIGVsc2UgaWYoby5zaWduYWwpIGRlZiA9IHBhcnNlU2lnbmFsKG8uc2lnbmFsLCBzaWduYWxzKTtcbiAgICAgIGVsc2UgaWYoby5wcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHByZWQgPSBtb2RlbC5wcmVkaWNhdGUoby5wcmVkaWNhdGUpLFxuICAgICAgICAgICAgcCA9IFwicHJlZGljYXRlc1tcIitkbC5zdHIoby5wcmVkaWNhdGUpK1wiXVwiO1xuXG4gICAgICAgIHByZWQuc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgc2lnbmFsc1tzXSA9IDE7IH0pO1xuICAgICAgICBwcmVkLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IGRiW2RdID0gMSB9KTtcblxuICAgICAgICBkbC5rZXlzKG8uaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgIHZhciBpID0gby5pbnB1dFtrXSwgc2lnbmFsO1xuICAgICAgICAgIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGspK1wiXSA9IFwiO1xuICAgICAgICAgIGlmKGkuc2lnbmFsKSAgIGRlZiArPSBwYXJzZVNpZ25hbChpLnNpZ25hbCwgc2lnbmFscyk7XG4gICAgICAgICAgZWxzZSBpZihpLmFyZykgZGVmICs9IFwiYXJnc1tcIitkbC5zdHIoaS5hcmcpK1wiXVwiO1xuICAgICAgICAgIGRlZis9XCIsIFwiO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWYrPSBwK1wiLmNhbGwoXCIrcCtcIiwgYXJncywgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpXCI7XG4gICAgICB9XG5cbiAgICAgIGRlY2wucHVzaChuYW1lKTtcbiAgICAgIGRlZnMucHVzaChuYW1lK1wiPShcIitkZWYrXCIpXCIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IFwidmFyIFwiICsgZGVjbC5qb2luKFwiLCBcIikgKyBcIjtcXG5cIiArIGRlZnMuam9pbihcIjtcXG5cIikgKyBcIjtcXG5cIixcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoc2lnbmFscyksXG4gICAgICBkYXRhOiBkbC5rZXlzKGRiKVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3Ioc3BlYykge1xuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKHNwZWMub3BlcmFuZHMpO1xuICAgIGlmKHNwZWMudHlwZSA9PSAnPScpIHNwZWMudHlwZSA9ICc9PSc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIFtcIm8wXCIsIFwibzFcIl0uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICAgIGRhdGE6IG9wcy5kYXRhXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWwoc3BlYykge1xuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKHNwZWMub3BlcmFuZHMpLFxuICAgICAgICBvID0gW10sIGkgPSAwLCBsZW4gPSBzcGVjLm9wZXJhbmRzLmxlbmd0aDtcblxuICAgIHdoaWxlKG8ucHVzaChcIm9cIitpKyspPGxlbik7XG4gICAgaWYoc3BlYy50eXBlID09ICdhbmQnKSBzcGVjLnR5cGUgPSAnJiYnO1xuICAgIGVsc2UgaWYoc3BlYy50eXBlID09ICdvcicpIHNwZWMudHlwZSA9ICd8fCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIG8uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICAgIGRhdGE6IG9wcy5kYXRhXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUluKHNwZWMpIHtcbiAgICB2YXIgbyA9IFtzcGVjLml0ZW1dLCBjb2RlID0gXCJcIjtcbiAgICBpZihzcGVjLnJhbmdlKSBvLnB1c2guYXBwbHkobywgc3BlYy5yYW5nZSk7XG4gICAgaWYoc3BlYy5zY2FsZSkge1xuICAgICAgY29kZSA9IHBhcnNlU2NhbGUoc3BlYy5zY2FsZSwgbyk7XG4gICAgfVxuXG4gICAgdmFyIG9wcyA9IHBhcnNlT3BlcmFuZHMobyk7XG4gICAgY29kZSA9IG9wcy5jb2RlICsgY29kZTtcblxuICAgIGlmKHNwZWMuZGF0YSkge1xuICAgICAgdmFyIGZpZWxkID0gZGwuZmllbGQoc3BlYy5maWVsZCkubWFwKGRsLnN0cik7XG4gICAgICBjb2RlICs9IFwidmFyIHdoZXJlID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZFtcIitmaWVsZC5qb2luKFwiXVtcIikrXCJdID09IG8wIH07XFxuXCI7XG4gICAgICBjb2RlICs9IFwicmV0dXJuIGRiW1wiK2RsLnN0cihzcGVjLmRhdGEpK1wiXS5maWx0ZXIod2hlcmUpLmxlbmd0aCA+IDA7XCI7XG4gICAgfSBlbHNlIGlmKHNwZWMucmFuZ2UpIHtcbiAgICAgIC8vIFRPRE86IGluY2x1c2l2ZS9leGNsdXNpdmUgcmFuZ2U/XG4gICAgICAvLyBUT0RPOiBpbnZlcnRpbmcgb3JkaW5hbCBzY2FsZXNcbiAgICAgIGlmKHNwZWMuc2NhbGUpIGNvZGUgKz0gXCJvMSA9IHNjYWxlKG8xKTtcXG5vMiA9IHNjYWxlKG8yKTtcXG5cIjtcbiAgICAgIGNvZGUgKz0gXCJyZXR1cm4gbzEgPCBvMiA/IG8xIDw9IG8wICYmIG8wIDw9IG8yIDogbzIgPD0gbzAgJiYgbzAgPD0gbzFcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogY29kZSwgXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscywgXG4gICAgICBkYXRhOiBvcHMuZGF0YS5jb25jYXQoc3BlYy5kYXRhID8gW3NwZWMuZGF0YV0gOiBbXSlcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBvcHVsYXRlIG9wcyBzdWNoIHRoYXQgdWx0aW1hdGUgc2NhbGUvaW52ZXJzaW9uIGZ1bmN0aW9uIHdpbGwgYmUgaW4gYHNjYWxlYCB2YXIuIFxuICBmdW5jdGlvbiBwYXJzZVNjYWxlKHNwZWMsIG9wcykge1xuICAgIHZhciBjb2RlID0gXCJ2YXIgc2NhbGUgPSBcIiwgXG4gICAgICAgIGlkeCAgPSBvcHMubGVuZ3RoO1xuXG4gICAgaWYoZGwuaXNTdHJpbmcoc3BlYykpIHtcbiAgICAgIG9wcy5wdXNoKHsgdmFsdWU6IHNwZWMgfSk7XG4gICAgICBjb2RlICs9IFwidGhpcy5yb290KCkuc2NhbGUob1wiK2lkeCtcIilcIjtcbiAgICB9IGVsc2UgaWYoc3BlYy5hcmcpIHsgIC8vIFNjYWxlIGZ1bmN0aW9uIGlzIGJlaW5nIHBhc3NlZCBhcyBhbiBhcmdcbiAgICAgIG9wcy5wdXNoKHNwZWMpO1xuICAgICAgY29kZSArPSBcIm9cIitpZHg7XG4gICAgfSBlbHNlIGlmKHNwZWMubmFtZSkgeyAvLyBGdWxsIHNjYWxlIHBhcmFtZXRlciB7bmFtZTogLi59XG4gICAgICBvcHMucHVzaChkbC5pc1N0cmluZyhzcGVjLm5hbWUpID8ge3ZhbHVlOiBzcGVjLm5hbWV9IDogc3BlYy5uYW1lKTtcbiAgICAgIGNvZGUgKz0gXCIodGhpcy5pc0Z1bmN0aW9uKG9cIitpZHgrXCIpID8gb1wiK2lkeCtcIiA6IFwiO1xuICAgICAgaWYoc3BlYy5zY29wZSkge1xuICAgICAgICBvcHMucHVzaChzcGVjLnNjb3BlKTtcbiAgICAgICAgY29kZSArPSBcIihvXCIrKGlkeCsxKStcIi5zY2FsZSB8fCB0aGlzLnJvb3QoKS5zY2FsZSkob1wiK2lkeCtcIilcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgKz0gXCJ0aGlzLnJvb3QoKS5zY2FsZShvXCIraWR4K1wiKVwiO1xuICAgICAgfVxuICAgICAgY29kZSArPSBcIilcIlxuICAgIH1cblxuICAgIGlmKHNwZWMuaW52ZXJ0ID09PSB0cnVlKSB7ICAvLyBBbGxvdyBzcGVjLmludmVydC5hcmc/XG4gICAgICBjb2RlICs9IFwiLmludmVydFwiXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGUrXCI7XFxuXCI7XG4gIH1cblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgdmFyIHBhcnNlID0gdHlwZXNbcy50eXBlXShzKSxcbiAgICAgICAgcHJlZCAgPSBGdW5jdGlvbihcImFyZ3NcIiwgXCJkYlwiLCBcInNpZ25hbHNcIiwgXCJwcmVkaWNhdGVzXCIsIHBhcnNlLmNvZGUpO1xuICAgIHByZWQucm9vdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kZWwuc2NlbmUoKS5pdGVtc1swXSB9OyAvLyBGb3IgZ2xvYmFsIHNjYWxlc1xuICAgIHByZWQuaXNGdW5jdGlvbiA9IGRsLmlzRnVuY3Rpb247XG4gICAgcHJlZC5zaWduYWxzID0gcGFyc2Uuc2lnbmFscztcbiAgICBwcmVkLmRhdGEgPSBwYXJzZS5kYXRhO1xuICAgIG1vZGVsLnByZWRpY2F0ZShzLm5hbWUsIHByZWQpO1xuICB9KTtcblxuICByZXR1cm4gc3BlYztcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKTtcblxudmFyIERFUFMgPSBbXCJzaWduYWxzXCIsIFwic2NhbGVzXCIsIFwiZGF0YVwiLCBcImZpZWxkc1wiXTtcblxuZnVuY3Rpb24gY29tcGlsZShtb2RlbCwgbWFyaywgc3BlYykge1xuICB2YXIgY29kZSA9IFwiXCIsXG4gICAgICBuYW1lcyA9IGRsLmtleXMoc3BlYyksXG4gICAgICBpLCBsZW4sIG5hbWUsIHJlZiwgdmFycyA9IHt9LCBcbiAgICAgIGRlcHMgPSB7XG4gICAgICAgIHNpZ25hbHM6IHt9LFxuICAgICAgICBzY2FsZXM6ICB7fSxcbiAgICAgICAgZGF0YTogICAge30sXG4gICAgICAgIGZpZWxkczogIHt9LFxuICAgICAgICByZWZsb3c6ICBmYWxzZVxuICAgICAgfTtcbiAgICAgIFxuICBjb2RlICs9IFwidmFyIG8gPSB0cmFucyA/IHt9IDogaXRlbTtcXG5cIlxuICBcbiAgZm9yIChpPTAsIGxlbj1uYW1lcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICByZWYgPSBzcGVjW25hbWUgPSBuYW1lc1tpXV07XG4gICAgY29kZSArPSAoaSA+IDApID8gXCJcXG4gIFwiIDogXCIgIFwiO1xuICAgIGlmKHJlZi5ydWxlKSB7XG4gICAgICByZWYgPSBydWxlKG1vZGVsLCBuYW1lLCByZWYucnVsZSk7XG4gICAgICBjb2RlICs9IFwiXFxuICBcIiArIHJlZi5jb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHZhbHVlUmVmKG5hbWUsIHJlZik7XG4gICAgICBjb2RlICs9IFwidGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XCI7XG4gICAgfVxuXG4gICAgdmFyc1tuYW1lXSA9IHRydWU7XG4gICAgREVQUy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIGlmKHJlZltwXSAhPSBudWxsKSBkbC5hcnJheShyZWZbcF0pLmZvckVhY2goZnVuY3Rpb24oaykgeyBkZXBzW3BdW2tdID0gMSB9KTtcbiAgICB9KTtcbiAgICBkZXBzLnJlZmxvdyA9IGRlcHMucmVmbG93IHx8IHJlZi5yZWZsb3c7XG4gIH1cblxuICBpZiAodmFycy54Mikge1xuICAgIGlmICh2YXJzLngpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGlmIChvLnggPiBvLngyKSB7IFwiXG4gICAgICAgICAgICArIFwidmFyIHQgPSBvLng7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3gnLCBvLngyKTtcIlxuICAgICAgICAgICAgKyBcInRoaXMudHBsLnNldChvLCAneDInLCB0KTsgXCJcbiAgICAgICAgICAgICsgXCJ9O1wiO1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd3aWR0aCcsIChvLngyIC0gby54KSk7XCI7XG4gICAgfSBlbHNlIGlmICh2YXJzLndpZHRoKSB7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3gnLCAoby54MiAtIG8ud2lkdGgpKTtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd4Jywgby54Mik7XCJcbiAgICB9XG4gIH1cblxuICBpZiAodmFycy55Mikge1xuICAgIGlmICh2YXJzLnkpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGlmIChvLnkgPiBvLnkyKSB7IFwiXG4gICAgICAgICAgICArIFwidmFyIHQgPSBvLnk7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3knLCBvLnkyKTtcIlxuICAgICAgICAgICAgKyBcInRoaXMudHBsLnNldChvLCAneTInLCB0KTtcIlxuICAgICAgICAgICAgKyBcIn07XCI7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ2hlaWdodCcsIChvLnkyIC0gby55KSk7XCI7XG4gICAgfSBlbHNlIGlmICh2YXJzLmhlaWdodCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd5JywgKG8ueTIgLSBvLmhlaWdodCkpO1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3knLCBvLnkyKTtcIlxuICAgIH1cbiAgfVxuICBcbiAgaWYgKGhhc1BhdGgobWFyaywgdmFycykpIGNvZGUgKz0gXCJcXG4gIGl0ZW0udG91Y2goKTtcIjtcbiAgY29kZSArPSBcIlxcbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcIjtcblxuICB0cnkge1xuICAgIHZhciBlbmNvZGVyID0gRnVuY3Rpb24oXCJpdGVtXCIsIFwiZ3JvdXBcIiwgXCJ0cmFuc1wiLCBcImRiXCIsIFxuICAgICAgXCJzaWduYWxzXCIsIFwicHJlZGljYXRlc1wiLCBjb2RlKTtcbiAgICBlbmNvZGVyLnRwbCAgPSB0dXBsZTtcbiAgICBlbmNvZGVyLnV0aWwgPSBkbDtcbiAgICBlbmNvZGVyLmQzICAgPSBkMzsgLy8gRm9yIGNvbG9yIHNwYWNlc1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6ICBlbmNvZGVyLFxuICAgICAgc2lnbmFsczogZGwua2V5cyhkZXBzLnNpZ25hbHMpLFxuICAgICAgc2NhbGVzOiAgZGwua2V5cyhkZXBzLnNjYWxlcyksXG4gICAgICBkYXRhOiAgICBkbC5rZXlzKGRlcHMuZGF0YSksXG4gICAgICBmaWVsZHM6ICBkbC5rZXlzKGRlcHMuZmllbGRzKSxcbiAgICAgIHJlZmxvdzogIGRlcHMucmVmbG93XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGwuZXJyb3IoZSk7XG4gICAgZGwubG9nKGNvZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhdGgobWFyaywgdmFycykge1xuICByZXR1cm4gdmFycy5wYXRoIHx8XG4gICAgKChtYXJrPT09XCJhcmVhXCIgfHwgbWFyaz09PVwibGluZVwiKSAmJlxuICAgICAgKHZhcnMueCB8fCB2YXJzLngyIHx8IHZhcnMud2lkdGggfHxcbiAgICAgICB2YXJzLnkgfHwgdmFycy55MiB8fCB2YXJzLmhlaWdodCB8fFxuICAgICAgIHZhcnMudGVuc2lvbiB8fCB2YXJzLmludGVycG9sYXRlKSk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobW9kZWwsIG5hbWUsIHJ1bGVzKSB7XG4gIHZhciBzaWduYWxzID0gW10sIHNjYWxlcyA9IFtdLCBkYiA9IFtdLFxuICAgICAgaW5wdXRzID0gW10sIGNvZGUgPSBcIlwiO1xuXG4gIChydWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ociwgaSkge1xuICAgIHZhciBwcmVkTmFtZSA9IHIucHJlZGljYXRlLFxuICAgICAgICBwcmVkID0gbW9kZWwucHJlZGljYXRlKHByZWROYW1lKSxcbiAgICAgICAgcCA9IFwicHJlZGljYXRlc1tcIitkbC5zdHIocHJlZE5hbWUpK1wiXVwiLFxuICAgICAgICBpbnB1dCA9IFtdLCBhcmdzID0gbmFtZStcIl9hcmdcIitpLFxuICAgICAgICByZWY7XG5cbiAgICBkbC5rZXlzKHIuaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHJlZiA9IHZhbHVlUmVmKGksIHIuaW5wdXRba10pO1xuICAgICAgaW5wdXQucHVzaChkbC5zdHIoaykrXCI6IFwiK3JlZi52YWwpO1xuICAgICAgaWYocmVmLnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBkbC5hcnJheShyZWYuc2lnbmFscykpO1xuICAgICAgaWYocmVmLnNjYWxlcykgIHNjYWxlcy5wdXNoLmFwcGx5KHNjYWxlcywgZGwuYXJyYXkocmVmLnNjYWxlcykpO1xuICAgIH0pO1xuXG4gICAgcmVmID0gdmFsdWVSZWYobmFtZSwgcik7XG4gICAgaWYocmVmLnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBkbC5hcnJheShyZWYuc2lnbmFscykpO1xuICAgIGlmKHJlZi5zY2FsZXMpICBzY2FsZXMucHVzaC5hcHBseShzY2FsZXMsIGRsLmFycmF5KHJlZi5zY2FsZXMpKTtcblxuICAgIGlmKHByZWROYW1lKSB7XG4gICAgICBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgcHJlZC5zaWduYWxzKTtcbiAgICAgIGRiLnB1c2guYXBwbHkoZGIsIHByZWQuZGF0YSk7XG4gICAgICBpbnB1dHMucHVzaChhcmdzK1wiID0ge1wiK2lucHV0LmpvaW4oJywgJykrXCJ9XCIpO1xuICAgICAgY29kZSArPSBcImlmKFwiK3ArXCIuY2FsbChcIitwK1wiLFwiK2FyZ3MrXCIsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSkge1xcblwiICtcbiAgICAgICAgXCIgICAgdGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XFxuXCI7XG4gICAgICBjb2RlICs9IHJ1bGVzW2krMV0gPyBcIiAgfSBlbHNlIFwiIDogXCIgIH1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIntcXG5cIiArIFxuICAgICAgICBcIiAgICB0aGlzLnRwbC5zZXQobywgXCIrZGwuc3RyKG5hbWUpK1wiLCBcIityZWYudmFsK1wiKTtcXG5cIitcbiAgICAgICAgXCIgIH1cIjtcbiAgICB9XG4gIH0pO1xuXG4gIGNvZGUgPSBcInZhciBcIiArIGlucHV0cy5qb2luKFwiLFxcbiAgICAgIFwiKSArIFwiO1xcbiAgXCIgKyBjb2RlO1xuICByZXR1cm4ge2NvZGU6IGNvZGUsIHNpZ25hbHM6IHNpZ25hbHMsIHNjYWxlczogc2NhbGVzLCBkYXRhOiBkYn07XG59XG5cbmZ1bmN0aW9uIHZhbHVlUmVmKG5hbWUsIHJlZikge1xuICBpZiAocmVmID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGlmIChuYW1lPT09XCJmaWxsXCIgfHwgbmFtZT09PVwic3Ryb2tlXCIpIHtcbiAgICBpZiAocmVmLmMpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcImhjbFwiLCByZWYuaCwgcmVmLmMsIHJlZi5sKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5oIHx8IHJlZi5zKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJoc2xcIiwgcmVmLmgsIHJlZi5zLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYubCB8fCByZWYuYSkge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwibGFiXCIsIHJlZi5sLCByZWYuYSwgcmVmLmIpO1xuICAgIH0gZWxzZSBpZiAocmVmLnIgfHwgcmVmLmcgfHwgcmVmLmIpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcInJnYlwiLCByZWYuciwgcmVmLmcsIHJlZi5iKTtcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHZhbHVlXG4gIHZhciB2YWwgPSBudWxsLCBzY2FsZSA9IG51bGwsIFxuICAgICAgc2dSZWYgPSB7fSwgZlJlZiA9IHt9LCBzUmVmID0ge30sXG4gICAgICBzaWduYWxzID0gW10sIGZpZWxkcyA9IFtdLCByZWZsb3cgPSBmYWxzZTtcblxuICBpZiAocmVmLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBkbC5zdHIocmVmLnZhbHVlKTtcbiAgfVxuXG4gIGlmIChyZWYuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZ1JlZiA9IGRsLmZpZWxkKHJlZi5zaWduYWwpO1xuICAgIHZhbCA9IFwic2lnbmFsc1tcIitzZ1JlZi5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCI7IFxuICAgIHNpZ25hbHMucHVzaChzZ1JlZi5zaGlmdCgpKTtcbiAgfVxuXG4gIGlmKHJlZi5maWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmLmZpZWxkID0gZGwuaXNTdHJpbmcocmVmLmZpZWxkKSA/IHtkYXR1bTogcmVmLmZpZWxkfSA6IHJlZi5maWVsZDtcbiAgICBmUmVmICA9IGZpZWxkUmVmKHJlZi5maWVsZCk7XG4gICAgdmFsID0gZlJlZi52YWw7XG4gIH1cblxuICBpZiAocmVmLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzUmVmID0gc2NhbGVSZWYocmVmLnNjYWxlKTtcbiAgICBzY2FsZSA9IHNSZWYudmFsO1xuXG4gICAgLy8gcnVuIHRocm91Z2ggc2NhbGUgZnVuY3Rpb24gaWYgdmFsIHNwZWNpZmllZC5cbiAgICAvLyBpZiBubyB2YWwsIHNjYWxlIGZ1bmN0aW9uIGlzIHByZWRpY2F0ZSBhcmcuXG4gICAgaWYodmFsICE9PSBudWxsIHx8IHJlZi5iYW5kIHx8IHJlZi5tdWx0IHx8IHJlZi5vZmZzZXQpIHtcbiAgICAgIHZhbCA9IHNjYWxlICsgKHJlZi5iYW5kID8gXCIucmFuZ2VCYW5kKClcIiA6IFxuICAgICAgICBcIihcIisodmFsICE9PSBudWxsID8gdmFsIDogXCJpdGVtLmRhdHVtLmRhdGFcIikrXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBzY2FsZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIG11bHRpcGx5LCBvZmZzZXQsIHJldHVybiB2YWx1ZVxuICB2YWwgPSBcIihcIiArIChyZWYubXVsdD8oZGwubnVtYmVyKHJlZi5tdWx0KStcIiAqIFwiKTpcIlwiKSArIHZhbCArIFwiKVwiXG4gICAgKyAocmVmLm9mZnNldCA/IFwiICsgXCIgKyBkbC5udW1iZXIocmVmLm9mZnNldCkgOiBcIlwiKTtcblxuICAvLyBDb2xsYXRlIGRlcGVuZGVuY2llc1xuICByZXR1cm4ge1xuICAgIHZhbDogdmFsLFxuICAgIHNpZ25hbHM6IHNpZ25hbHMuY29uY2F0KGRsLmFycmF5KGZSZWYuc2lnbmFscykpLmNvbmNhdChkbC5hcnJheShzUmVmLnNpZ25hbHMpKSxcbiAgICBmaWVsZHM6ICBmaWVsZHMuY29uY2F0KGRsLmFycmF5KGZSZWYuZmllbGRzKSkuY29uY2F0KGRsLmFycmF5KHNSZWYuZmllbGRzKSksXG4gICAgc2NhbGVzOiAgcmVmLnNjYWxlID8gKHJlZi5zY2FsZS5uYW1lIHx8IHJlZi5zY2FsZSkgOiBudWxsLCAvLyBUT0RPOiBjb25uZWN0IHNSZWYnZCBzY2FsZT9cbiAgICByZWZsb3c6ICByZWZsb3cgfHwgZlJlZi5yZWZsb3cgfHwgc1JlZi5yZWZsb3dcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29sb3JSZWYodHlwZSwgeCwgeSwgeikge1xuICB2YXIgeHggPSB4ID8gdmFsdWVSZWYoXCJcIiwgeCkgOiBjb25maWcuY29sb3JbdHlwZV1bMF0sXG4gICAgICB5eSA9IHkgPyB2YWx1ZVJlZihcIlwiLCB5KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsxXSxcbiAgICAgIHp6ID0geiA/IHZhbHVlUmVmKFwiXCIsIHopIDogY29uZmlnLmNvbG9yW3R5cGVdWzJdXG4gICAgICBzaWduYWxzID0gW10sIHNjYWxlcyA9IFtdO1xuXG4gIFt4eCwgeXksIHp6XS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZih2LnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCB2LnNpZ25hbHMpO1xuICAgIGlmKHYuc2NhbGVzKSAgc2NhbGVzLnB1c2godi5zY2FsZXMpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHZhbDogXCIodGhpcy5kMy5cIiArIHR5cGUgKyBcIihcIiArIFt4eC52YWwsIHl5LnZhbCwgenoudmFsXS5qb2luKFwiLFwiKSArICcpICsgXCJcIiknLFxuICAgIHNpZ25hbHM6IHNpZ25hbHMsXG4gICAgc2NhbGVzOiBzY2FsZXNcbiAgfTtcbn1cblxuLy8ge2ZpZWxkOiB7ZGF0dW06IFwiZm9vXCJ9IH0gIC0+IGl0ZW0uZGF0dW0uZm9vXG4vLyB7ZmllbGQ6IHtncm91cDogXCJmb29cIn0gfSAgLT4gZ3JvdXAuZm9vXG4vLyB7ZmllbGQ6IHtwYXJlbnQ6IFwiZm9vXCJ9IH0gLT4gZ3JvdXAuZGF0dW0uZm9vXG5mdW5jdGlvbiBmaWVsZFJlZihyZWYpIHtcbiAgaWYoZGwuaXNTdHJpbmcocmVmKSkge1xuICAgIHJldHVybiB7dmFsOiBkbC5maWVsZChyZWYpLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKX07XG4gIH0gXG5cbiAgLy8gUmVzb2x2ZSBuZXN0aW5nL3BhcmVudCBsb29rdXBzXG4gIHZhciBsID0gcmVmLmxldmVsLFxuICAgICAgbmVzdGVkID0gKHJlZi5ncm91cCB8fCByZWYucGFyZW50KSAmJiBsLFxuICAgICAgc2NvcGUgPSBuZXN0ZWQgPyBBcnJheShsKS5qb2luKFwiZ3JvdXAubWFyay5cIikgOiBcIlwiLFxuICAgICAgciA9IGZpZWxkUmVmKHJlZi5kYXR1bSB8fCByZWYuZ3JvdXAgfHwgcmVmLnBhcmVudCB8fCByZWYuc2lnbmFsKSxcbiAgICAgIHZhbCA9IHIudmFsLFxuICAgICAgZmllbGRzICA9IHIuZmllbGRzICB8fCBbXSxcbiAgICAgIHNpZ25hbHMgPSByLnNpZ25hbHMgfHwgW10sXG4gICAgICByZWZsb3cgID0gci5yZWZsb3cgIHx8IGZhbHNlOyAvLyBOZXN0ZWQgZmllbGRyZWZzIHRyaWdnZXIgZnVsbCByZWV2YWwgb2YgRW5jb2Rlci5cblxuICBpZihyZWYuZGF0dW0pIHtcbiAgICB2YWwgPSBcIml0ZW0uZGF0dW1bXCIrdmFsK1wiXVwiO1xuICAgIGZpZWxkcy5wdXNoKHJlZi5kYXR1bSk7XG4gIH0gZWxzZSBpZihyZWYuZ3JvdXApIHtcbiAgICB2YWwgPSBzY29wZStcImdyb3VwW1wiK3ZhbCtcIl1cIjtcbiAgICByZWZsb3cgPSB0cnVlO1xuICB9IGVsc2UgaWYocmVmLnBhcmVudCkge1xuICAgIHZhbCA9IHNjb3BlK1wiZ3JvdXAuZGF0dW1bXCIrdmFsK1wiXVwiO1xuICAgIHJlZmxvdyA9IHRydWU7XG4gIH0gZWxzZSBpZihyZWYuc2lnbmFsKSB7XG4gICAgdmFsID0gXCJzaWduYWxzW1wiK3ZhbCtcIl1cIjtcbiAgICBzaWduYWxzLnB1c2goZGwuZmllbGQocmVmLnNpZ25hbClbMF0pO1xuICAgIHJlZmxvdyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4ge3ZhbDogdmFsLCBmaWVsZHM6IGZpZWxkcywgc2lnbmFsczogc2lnbmFscywgcmVmbG93OiByZWZsb3d9O1xufVxuXG4vLyB7c2NhbGU6IFwieFwifVxuLy8ge3NjYWxlOiB7bmFtZTogXCJ4XCJ9fSxcbi8vIHtzY2FsZTogZmllbGRSZWZ9XG5mdW5jdGlvbiBzY2FsZVJlZihyZWYpIHtcbiAgdmFyIHNjYWxlID0gbnVsbCxcbiAgICAgIGZyID0gbnVsbDtcblxuICBpZihkbC5pc1N0cmluZyhyZWYpKSB7XG4gICAgc2NhbGUgPSBkbC5zdHIocmVmKTtcbiAgfSBlbHNlIGlmKHJlZi5uYW1lKSB7XG4gICAgc2NhbGUgPSBkbC5pc1N0cmluZyhyZWYubmFtZSkgPyBkbC5zdHIocmVmLm5hbWUpIDogKGZyID0gZmllbGRSZWYocmVmLm5hbWUpKS52YWw7XG4gIH0gZWxzZSB7XG4gICAgc2NhbGUgPSAoZnIgPSBmaWVsZFJlZihyZWYpKS52YWw7XG4gIH1cblxuICBzY2FsZSA9IFwiZ3JvdXAuc2NhbGUoXCIrc2NhbGUrXCIpXCI7XG4gIGlmKHJlZi5pbnZlcnQpIHNjYWxlICs9IFwiLmludmVydFwiOyAgLy8gVE9ETzogb3JkaW5hbCBzY2FsZXNcblxuICByZXR1cm4gZnIgPyAoZnIudmFsID0gc2NhbGUsIGZyKSA6IHt2YWw6IHNjYWxlfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlOyIsInZhciBleHByID0gcmVxdWlyZSgnLi9leHByJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VTaWduYWxzKG1vZGVsLCBzcGVjKSB7XG4gIC8vIHByb2Nlc3MgZWFjaCBzaWduYWwgZGVmaW5pdGlvblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgdmFyIHNpZ25hbCA9IG1vZGVsLnNpZ25hbChzLm5hbWUsIHMuaW5pdCksXG4gICAgICAgIGV4cDtcblxuICAgIGlmKHMuZXhwcikge1xuICAgICAgZXhwID0gZXhwcihzLmV4cHIpO1xuICAgICAgc2lnbmFsLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwci5ldmFsKG1vZGVsLCBleHAuZm4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGV4cC5zaWduYWxzKTtcbiAgICAgICAgaWYoc3BlYy5zY2FsZSkgdmFsdWUgPSBtb2RlbC5zY2FsZShzcGVjLCB2YWx1ZSk7XG4gICAgICAgIHNpZ25hbC52YWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlucHV0LnNpZ25hbHNbcy5uYW1lXSA9IDE7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH07XG4gICAgICBzaWduYWwuZGVwZW5kZW5jeShDLlNJR05BTFMsIGV4cC5zaWduYWxzKTtcbiAgICAgIGV4cC5zaWduYWxzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7IG1vZGVsLnNpZ25hbChkZXApLmFkZExpc3RlbmVyKHNpZ25hbCk7IH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4uL2NvcmUvTW9kZWwnKSwgXG4gICAgVmlldyA9IHJlcXVpcmUoJy4uL2NvcmUvVmlldycpLCBcbiAgICBwYXJzZVBhZGRpbmcgPSByZXF1aXJlKCcuLi9wYXJzZS9wYWRkaW5nJyksXG4gICAgcGFyc2VNYXJrcyA9IHJlcXVpcmUoJy4uL3BhcnNlL21hcmtzJyksXG4gICAgcGFyc2VTaWduYWxzID0gcmVxdWlyZSgnLi4vcGFyc2Uvc2lnbmFscycpLFxuICAgIHBhcnNlUHJlZGljYXRlcyA9IHJlcXVpcmUoJy4uL3BhcnNlL3ByZWRpY2F0ZXMnKSxcbiAgICBwYXJzZURhdGEgPSByZXF1aXJlKCcuLi9wYXJzZS9kYXRhJyksXG4gICAgcGFyc2VJbnRlcmFjdG9ycyA9IHJlcXVpcmUoJy4uL3BhcnNlL2ludGVyYWN0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VTcGVjKHNwZWMsIGNhbGxiYWNrLCB2aWV3RmFjdG9yeSkge1xuICAvLyBwcm90ZWN0IGFnYWluc3Qgc3Vic2VxdWVudCBzcGVjIG1vZGlmaWNhdGlvblxuICBzcGVjID0gZGwuZHVwbGljYXRlKHNwZWMpO1xuXG4gIHZpZXdGYWN0b3J5ID0gdmlld0ZhY3RvcnkgfHwgVmlldy5mYWN0b3J5O1xuXG4gIHZhciB3aWR0aCA9IHNwZWMud2lkdGggfHwgNTAwLFxuICAgICAgaGVpZ2h0ID0gc3BlYy5oZWlnaHQgfHwgNTAwLFxuICAgICAgdmlld3BvcnQgPSBzcGVjLnZpZXdwb3J0IHx8IG51bGwsXG4gICAgICBtb2RlbCA9IG5ldyBNb2RlbCgpO1xuXG4gIHBhcnNlSW50ZXJhY3RvcnMobW9kZWwsIHNwZWMsIGZ1bmN0aW9uKCkge1xuICAgIG1vZGVsLmRlZnMoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBwYWRkaW5nOiBwYXJzZVBhZGRpbmcoc3BlYy5wYWRkaW5nKSxcbiAgICAgIHNpZ25hbHM6IHBhcnNlU2lnbmFscyhtb2RlbCwgc3BlYy5zaWduYWxzKSxcbiAgICAgIHByZWRpY2F0ZXM6IHBhcnNlUHJlZGljYXRlcyhtb2RlbCwgc3BlYy5wcmVkaWNhdGVzKSxcbiAgICAgIG1hcmtzOiBwYXJzZU1hcmtzKG1vZGVsLCBzcGVjLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgIGRhdGE6IHBhcnNlRGF0YShtb2RlbCwgc3BlYy5kYXRhLCBmdW5jdGlvbigpIHsgY2FsbGJhY2sodmlld0ZhY3RvcnkobW9kZWwpKTsgfSlcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGNoYW5nc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgc2VsZWN0b3IgPSByZXF1aXJlKCcuL2V2ZW50cycpLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuL2V4cHInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIFNUQVJUID0gXCJzdGFydFwiLCBNSURETEUgPSBcIm1pZGRsZVwiLCBFTkQgPSBcImVuZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIG1vZGVsID0gdmlldy5tb2RlbCgpLFxuICAgICAgc3BlYyAgPSBtb2RlbC5kZWZzKCkuc2lnbmFscyxcbiAgICAgIHJlZ2lzdGVyID0ge30sIG5vZGVzID0ge307XG5cbiAgZnVuY3Rpb24gc2NhbGUoc3BlYywgdmFsdWUpIHtcbiAgICB2YXIgZGVmID0gc3BlYy5zY2FsZSxcbiAgICAgICAgbmFtZSAgPSBkZWYubmFtZSB8fCBkZWYuc2lnbmFsIHx8IGRlZixcbiAgICAgICAgc2NvcGUgPSBkZWYuc2NvcGUgPyBtb2RlbC5zaWduYWxSZWYoZGVmLnNjb3BlLnNpZ25hbCkgOiBudWxsO1xuXG4gICAgaWYoIXNjb3BlIHx8ICFzY29wZS5zY2FsZSkge1xuICAgICAgc2NvcGUgPSAoc2NvcGUgJiYgc2NvcGUubWFyaykgPyBzY29wZS5tYXJrLmdyb3VwIDogbW9kZWwuc2NlbmUoKS5pdGVtc1swXTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGUgPSBzY29wZS5zY2FsZShuYW1lKTtcbiAgICBpZighc2NhbGUpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gZGVmLmludmVydCA/IHNjYWxlLmludmVydCh2YWx1ZSkgOiBzY2FsZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaWduYWwoc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgdmFyIG4gPSBuZXcgTm9kZShtb2RlbCk7XG4gICAgbi5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZighaW5wdXQuc2lnbmFsc1tzZWxlY3Rvci5zaWduYWxdKSByZXR1cm4gbW9kZWwuZG9Ob3RQcm9wYWdhdGU7XG4gICAgICB2YXIgdmFsID0gZXhwci5ldmFsKG1vZGVsLCBleHAuZm4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGV4cC5zaWduYWxzKTtcbiAgICAgIGlmKHNwZWMuc2NhbGUpIHZhbCA9IHNjYWxlKHNwZWMsIHZhbCk7XG4gICAgICBzaWcudmFsdWUodmFsKTtcbiAgICAgIGlucHV0LnNpZ25hbHNbc2lnLm5hbWUoKV0gPSAxO1xuICAgICAgaW5wdXQucmVmbG93ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpbnB1dDsgIFxuICAgIH07XG4gICAgbi5kZXBlbmRlbmN5KEMuU0lHTkFMUywgc2VsZWN0b3Iuc2lnbmFsKTtcbiAgICBuLmFkZExpc3RlbmVyKHNpZyk7XG4gICAgbW9kZWwuc2lnbmFsKHNlbGVjdG9yLnNpZ25hbCkuYWRkTGlzdGVuZXIobik7XG4gIH07XG5cbiAgZnVuY3Rpb24gZXZlbnQoc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgdmFyIGZpbHRlcnMgPSBzZWxlY3Rvci5maWx0ZXJzIHx8IFtdLFxuICAgICAgICB0YXJnZXQgPSBzZWxlY3Rvci50YXJnZXQ7XG5cbiAgICBpZih0YXJnZXQpIGZpbHRlcnMucHVzaChcImkuXCIrdGFyZ2V0LnR5cGUrXCI9PVwiK2RsLnN0cih0YXJnZXQudmFsdWUpKTtcblxuICAgIHJlZ2lzdGVyW3NlbGVjdG9yLmV2ZW50XSA9IHJlZ2lzdGVyW3NlbGVjdG9yLmV2ZW50XSB8fCBbXTtcbiAgICByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0ucHVzaCh7XG4gICAgICBzaWduYWw6IHNpZyxcbiAgICAgIGV4cDogZXhwLFxuICAgICAgZmlsdGVyczogZmlsdGVycy5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gZXhwcihmKTsgfSksXG4gICAgICBzcGVjOiBzcGVjXG4gICAgfSk7XG5cbiAgICBub2Rlc1tzZWxlY3Rvci5ldmVudF0gPSBub2Rlc1tzZWxlY3Rvci5ldmVudF0gfHwgbmV3IE5vZGUobW9kZWwpO1xuICAgIG5vZGVzW3NlbGVjdG9yLmV2ZW50XS5hZGRMaXN0ZW5lcihzaWcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9yZGVyZWRTdHJlYW0oc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgdmFyIG5hbWUgPSBzaWcubmFtZSgpLCBcbiAgICAgICAgdHJ1ZUZuID0gZXhwcihcInRydWVcIiksXG4gICAgICAgIHMgPSB7fTtcblxuICAgIHNbU1RBUlRdICA9IG1vZGVsLnNpZ25hbChuYW1lICsgU1RBUlQsICBmYWxzZSk7XG4gICAgc1tNSURETEVdID0gbW9kZWwuc2lnbmFsKG5hbWUgKyBNSURETEUsIGZhbHNlKTtcbiAgICBzW0VORF0gICAgPSBtb2RlbC5zaWduYWwobmFtZSArIEVORCwgICAgZmFsc2UpO1xuXG4gICAgdmFyIHJvdXRlciA9IG5ldyBOb2RlKG1vZGVsKTtcbiAgICByb3V0ZXIuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoc1tTVEFSVF0udmFsdWUoKSA9PT0gdHJ1ZSAmJiBzW0VORF0udmFsdWUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVE9ETzogRXhwYW5kIHNlbGVjdG9yIHN5bnRheCB0byBhbGxvdyBzdGFydC9lbmQgc2lnbmFscyBpbnRvIHN0cmVhbS5cbiAgICAgICAgLy8gVW50aWwgdGhlbiwgcHJldmVudCBvbGQgbWlkZGxlcyBlbnRlcmluZyBzdHJlYW0gb24gbmV3IHN0YXJ0LlxuICAgICAgICBpZihpbnB1dC5zaWduYWxzW25hbWUrU1RBUlRdKSByZXR1cm4gbW9kZWwuZG9Ob3RQcm9wYWdhdGU7XG5cbiAgICAgICAgc2lnLnZhbHVlKHNbTUlERExFXS52YWx1ZSgpKTtcbiAgICAgICAgaW5wdXQuc2lnbmFsc1tuYW1lXSA9IDE7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH1cblxuICAgICAgaWYoc1tFTkRdLnZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgc1tTVEFSVF0udmFsdWUoZmFsc2UpO1xuICAgICAgICBzW0VORF0udmFsdWUoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW9kZWwuZG9Ob3RQcm9wYWdhdGU7XG4gICAgfTtcbiAgICByb3V0ZXIuYWRkTGlzdGVuZXIoc2lnKTtcblxuICAgIFtTVEFSVCwgTUlERExFLCBFTkRdLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHZhbCA9ICh4ID09IE1JRERMRSkgPyBleHAgOiB0cnVlRm4sXG4gICAgICAgICAgc3AgPSAoeCA9PSBNSURETEUpID8gc3BlYyA6IHt9O1xuXG4gICAgICBpZihzZWxlY3Rvclt4XS5ldmVudCkgZXZlbnQoc1t4XSwgc2VsZWN0b3JbeF0sIHZhbCwgc3ApO1xuICAgICAgZWxzZSBpZihzZWxlY3Rvclt4XS5zaWduYWwpIHNpZ25hbChzW3hdLCBzZWxlY3Rvclt4XSwgdmFsLCBzcCk7XG4gICAgICBlbHNlIGlmKHNlbGVjdG9yW3hdLnN0cmVhbSkgbWVyZ2VkU3RyZWFtKHNbeF0sIHNlbGVjdG9yW3hdLnN0cmVhbSwgdmFsLCBzcCk7XG4gICAgICBzW3hdLmFkZExpc3RlbmVyKHJvdXRlcik7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWVyZ2VkU3RyZWFtKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHNlbGVjdG9yLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgaWYocy5ldmVudCkgICAgICAgZXZlbnQoc2lnLCBzLCBleHAsIHNwZWMpO1xuICAgICAgZWxzZSBpZihzLnNpZ25hbCkgc2lnbmFsKHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zdGFydCkgIG9yZGVyZWRTdHJlYW0oc2lnLCBzLCBleHAsIHNwZWMpO1xuICAgICAgZWxzZSBpZihzLnN0cmVhbSkgbWVyZ2VkU3RyZWFtKHNpZywgcy5zdHJlYW0sIGV4cCwgc3BlYyk7XG4gICAgfSk7XG4gIH07XG5cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZ25hbCA9IG1vZGVsLnNpZ25hbChzaWcubmFtZSk7XG4gICAgaWYoc2lnLmV4cHIpIHJldHVybjsgIC8vIENhbm5vdCBoYXZlIGFuIGV4cHIgYW5kIHN0cmVhbSBkZWZpbml0aW9uLlxuXG4gICAgKHNpZy5zdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgdmFyIHNlbCA9IHNlbGVjdG9yLnBhcnNlKHN0cmVhbS50eXBlKSxcbiAgICAgICAgICBleHAgPSBleHByKHN0cmVhbS5leHByKTtcbiAgICAgIG1lcmdlZFN0cmVhbShzaWduYWwsIHNlbCwgZXhwLCBzdHJlYW0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBXZSByZWdpc3RlciB0aGUgZXZlbnQgbGlzdGVuZXJzIGFsbCB0b2dldGhlciBzbyB0aGF0IGlmIG11bHRpcGxlXG4gIC8vIHNpZ25hbHMgYXJlIHJlZ2lzdGVyZWQgb24gdGhlIHNhbWUgZXZlbnQsIHRoZXkgd2lsbCByZWNlaXZlIHRoZVxuICAvLyBuZXcgdmFsdWUgb24gdGhlIHNhbWUgcHVsc2UuIFxuXG4gIC8vIFRPRE86IEZpbHRlcnMsIHRpbWUgaW50ZXJ2YWxzLCB0YXJnZXQgc2VsZWN0b3JzXG4gIGRsLmtleXMocmVnaXN0ZXIpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgIHZhciBoYW5kbGVycyA9IHJlZ2lzdGVyW3JdLCBcbiAgICAgICAgbm9kZSA9IG5vZGVzW3JdO1xuXG4gICAgdmlldy5vbihyLCBmdW5jdGlvbihldnQsIGl0ZW0pIHtcbiAgICAgIHZhciBjcyA9IGNoYW5nc2V0LmNyZWF0ZShudWxsLCB0cnVlKSxcbiAgICAgICAgICBwYWQgPSB2aWV3LnBhZGRpbmcoKSxcbiAgICAgICAgICBmaWx0ZXJlZCA9IGZhbHNlLFxuICAgICAgICAgIHZhbCwgaCwgaSwgbSwgZDtcblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIFN0b3AgdGV4dCBzZWxlY3Rpb25cbiAgICAgIG0gPSBkMy5tb3VzZSgoZDMuZXZlbnQ9ZXZ0LCB2aWV3Ll9lbCkpOyAvLyBSZWxhdGl2ZSBwb3NpdGlvbiB3aXRoaW4gY29udGFpbmVyXG4gICAgICBpdGVtID0gaXRlbXx8e307XG4gICAgICBkID0gaXRlbS5kYXR1bXx8e307XG4gICAgICB2YXIgcCA9IHt4OiBtWzBdIC0gcGFkLmxlZnQsIHk6IG1bMV0gLSBwYWQudG9wfTtcblxuICAgICAgZm9yKGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaCA9IGhhbmRsZXJzW2ldO1xuICAgICAgICBmaWx0ZXJlZCA9IGguZmlsdGVycy5zb21lKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gIWV4cHIuZXZhbChtb2RlbCwgZi5mbiwgZCwgZXZ0LCBpdGVtLCBwLCBmLnNpZ25hbHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoZmlsdGVyZWQpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFsID0gZXhwci5ldmFsKG1vZGVsLCBoLmV4cC5mbiwgZCwgZXZ0LCBpdGVtLCBwLCBoLmV4cC5zaWduYWxzKTsgXG4gICAgICAgIGlmKGguc3BlYy5zY2FsZSkgdmFsID0gc2NhbGUoaC5zcGVjLCB2YWwsIGl0ZW0pO1xuICAgICAgICBoLnNpZ25hbC52YWx1ZSh2YWwpO1xuICAgICAgICBjcy5zaWduYWxzW2guc2lnbmFsLm5hbWUoKV0gPSAxO1xuICAgICAgfVxuXG4gICAgICBtb2RlbC5wcm9wYWdhdGUoY3MsIG5vZGUpO1xuICAgIH0pO1xuICB9KVxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgdHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvaW5kZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVRyYW5zZm9ybXMobW9kZWwsIGRlZikge1xuICB2YXIgdHggPSBuZXcgdHJhbnNmb3Jtc1tkZWYudHlwZV0obW9kZWwpO1xuICBpZihkZWYudHlwZSA9PSAnZmFjZXQnKSB7XG4gICAgdmFyIHBpcGVsaW5lID0gKGRlZi50cmFuc2Zvcm18fFtdKVxuICAgICAgLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBwYXJzZVRyYW5zZm9ybXMobW9kZWwsIHQpOyB9KTtcbiAgICB0eC5waXBlbGluZShwaXBlbGluZSk7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIHJlbmFtZSBvdXRwdXQgZmllbGRzIGJlZm9yZSBzZXR0aW5nIGFueSBvdGhlciBwcm9wZXJ0aWVzLFxuICAvLyBhcyBzdWJzZXF1ZW50IHByb3BlcnRpZXMgbWF5IHJlcXVpcmUgb3V0cHV0IHRvIGJlIHNldCAoZS5nLiBncm91cCBieSkuXG4gIGlmKGRlZi5vdXRwdXQpIHR4Lm91dHB1dChkZWYub3V0cHV0KTtcblxuICBkbC5rZXlzKGRlZikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYoayA9PT0gJ3R5cGUnIHx8IGsgPT09ICdvdXRwdXQnKSByZXR1cm47XG4gICAgaWYoayA9PT0gJ3RyYW5zZm9ybScgJiYgZGVmLnR5cGUgPT09ICdmYWNldCcpIHJldHVybjtcbiAgICAodHhba10pLnNldCh0eCwgZGVmW2tdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHR4O1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlbCwgbW9kZWwpIHtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaWYgKGVsKSB0aGlzLmluaXRpYWxpemUoZWwpO1xuICBpZiAobW9kZWwpIHRoaXMubW9kZWwobW9kZWwpO1xufTtcblxudmFyIHByb3RvdHlwZSA9IGhhbmRsZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCBwYWQsIG9iaikge1xuICB0aGlzLl9lbCA9IGQzLnNlbGVjdChlbCkubm9kZSgpO1xuICB0aGlzLl9jYW52YXMgPSBkMy5zZWxlY3QoZWwpLnNlbGVjdChcImNhbnZhcy5tYXJrc1wiKS5ub2RlKCk7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHRoaXMuX29iaiA9IG9iaiB8fCBudWxsO1xuICBcbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzLCB0aGF0ID0gdGhpcztcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcHJvdG90eXBlW3R5cGVdLmNhbGwodGhhdCwgZXZ0KTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoID0gdGhpcy5faGFuZGxlcnM7XG4gIHJldHVybiBkbC5rZXlzKGgpLnJlZHVjZShmdW5jdGlvbihhLCBrKSB7XG4gICAgcmV0dXJuIGhba10ucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHsgcmV0dXJuIChhLnB1c2goeCksIGEpOyB9LCBhKTtcbiAgfSwgW10pO1xufTtcblxuLy8gc2V0dXAgZXZlbnRzXG52YXIgZXZlbnRzID0gW1xuICBcIm1vdXNlZG93blwiLFxuICBcIm1vdXNldXBcIixcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwid2hlZWxcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5cHJlc3NcIixcbiAgXCJrZXl1cFwiLFxuICBcIm1vdXNld2hlZWxcIixcbiAgXCJ0b3VjaHN0YXJ0XCJcbl07XG5ldmVudHMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gIHByb3RvdHlwZVt0eXBlXSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHRoaXMuZmlyZSh0eXBlLCBldnQpO1xuICB9O1xufSk7XG5ldmVudHMucHVzaChcIm1vdXNlbW92ZVwiKTtcbmV2ZW50cy5wdXNoKFwibW91c2VvdXRcIik7XG5ldmVudHMucHVzaChcInRvdWNobW92ZVwiKTtcbmV2ZW50cy5wdXNoKFwidG91Y2hlbmRcIik7XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZShuYW1lKSB7XG4gIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLlwiKTtcbiAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCxpKTtcbn1cblxucHJvdG90eXBlLnRvdWNobW92ZSA9IHByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbihldnQpIHtcbiAgdmFyIHBhZCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICBiID0gZXZ0LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHggPSBldnQuY2xpZW50WCAtIGIubGVmdCxcbiAgICAgIHkgPSBldnQuY2xpZW50WSAtIGIudG9wLFxuICAgICAgYSA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgIHAgPSB0aGlzLnBpY2sodGhpcy5fbW9kZWwuc2NlbmUoKSwgeCwgeSwgeC1wYWQubGVmdCwgeS1wYWQudG9wKTtcblxuICBpZiAocCA9PT0gYSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlbW92ZVwiLCBldnQpO1xuICAgIGlmKGV2dC50eXBlID09IFwidG91Y2htb3ZlXCIpIHRoaXMuZmlyZShcInRvdWNobW92ZVwiLCBldnQpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChhKSB7XG4gICAgdGhpcy5maXJlKFwibW91c2VvdXRcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNoZW5kXCIpIHRoaXMuZmlyZShcInRvdWNoZW5kXCIsIGV2dCk7XG4gIH1cbiAgdGhpcy5fYWN0aXZlID0gcDtcbiAgaWYgKHApIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW92ZXJcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNoc3RhcnRcIikgdGhpcy5maXJlKFwidG91Y2hzdGFydFwiLCBldnQpO1xuICB9XG59O1xuXG5wcm90b3R5cGUudG91Y2hlbmQgPSBwcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIGV2dCk7XG4gICAgdGhpcy5maXJlKFwidG91Y2hlbmRcIiwgZXZ0KTtcbiAgfVxuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xufTtcblxuLy8gdG8ga2VlcCBmaXJlZm94IGhhcHB5XG5wcm90b3R5cGUuRE9NTW91c2VTY3JvbGwgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKFwibW91c2V3aGVlbFwiLCBldnQpO1xufTtcblxuLy8gZmlyZSBhbiBldmVudFxucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbih0eXBlLCBldnQpIHtcbiAgdmFyIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbdHlwZV07XG4gIGlmIChoKSB7XG4gICAgZm9yICh2YXIgaT0wLCBsZW49aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGhbaV0uaGFuZGxlci5jYWxsKHRoaXMuX29iaiwgZXZ0LCBhKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICBoID0gaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKTtcbiAgaC5wdXNoKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yICh2YXIgaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmIChoW2ldLnR5cGUgIT09IHR5cGUpIGNvbnRpbnVlO1xuICAgIGlmICghaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIGguc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmV0cmlldmUgdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRleHRcbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xufTtcblxuLy8gZmluZCB0aGUgc2NlbmVncmFwaCBpdGVtIGF0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4vLyB4LCB5IC0tIHRoZSBhYnNvbHV0ZSB4LCB5IG1vdXNlIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMgZWxlbWVudFxuLy8gZ3gsIGd5IC0tIHRoZSByZWxhdGl2ZSBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbnByb3RvdHlwZS5waWNrID0gZnVuY3Rpb24oc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgZyA9IHRoaXMuY29udGV4dCgpLFxuICAgICAgbWFya3R5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIHBpY2tlciA9IG1hcmtzLnBpY2tbbWFya3R5cGVdO1xuICByZXR1cm4gcGlja2VyLmNhbGwodGhpcywgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZXI7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Cb3VuZHMnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3R4ID0gbnVsbDtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9pbWdsb2FkID0gMDtcbn07XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl9lbCA9IGVsO1xuICBcbiAgaWYgKCFlbCkgcmV0dXJuIHRoaXM7IC8vIGVhcmx5IGV4aXQgaWYgbm8gRE9NIGVsZW1lbnRcblxuICAvLyBzZWxlY3QgY2FudmFzIGVsZW1lbnRcbiAgdmFyIGNhbnZhcyA9IGQzLnNlbGVjdChlbClcbiAgICAuc2VsZWN0QWxsKFwiY2FudmFzLm1hcmtzXCIpXG4gICAgLmRhdGEoWzFdKTtcbiAgXG4gIC8vIGNyZWF0ZSBuZXcgY2FudmFzIGVsZW1lbnQgaWYgbmVlZGVkXG4gIGNhbnZhcy5lbnRlcigpXG4gICAgLmFwcGVuZChcImNhbnZhc1wiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrc1wiKTtcbiAgXG4gIC8vIHJlbW92ZSBleHRyYW5lb3VzIGNhbnZhcyBpZiBuZWVkZWRcbiAgY2FudmFzLmV4aXQoKS5yZW1vdmUoKTtcbiAgXG4gIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwYWQpO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIFxuICBpZiAodGhpcy5fZWwpIHtcbiAgICB2YXIgY2FudmFzID0gZDMuc2VsZWN0KHRoaXMuX2VsKS5zZWxlY3QoXCJjYW52YXMubWFya3NcIik7XG5cbiAgICAvLyBpbml0aWFsaXplIGNhbnZhcyBhdHRyaWJ1dGVzXG4gICAgY2FudmFzXG4gICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgcGFkLmxlZnQgKyBwYWQucmlnaHQpXG4gICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBwYWQudG9wICsgcGFkLmJvdHRvbSk7XG5cbiAgICAvLyBnZXQgdGhlIGNhbnZhcyBncmFwaGljcyBjb250ZXh0XG4gICAgdmFyIHM7XG4gICAgdGhpcy5fY3R4ID0gY2FudmFzLm5vZGUoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdGhpcy5fY3R4Ll9yYXRpbyA9IChzID0gc2NhbGVDYW52YXMoY2FudmFzLm5vZGUoKSwgdGhpcy5fY3R4KSB8fCAxKTtcbiAgICB0aGlzLl9jdHguc2V0VHJhbnNmb3JtKHMsIDAsIDAsIHMsIHMqcGFkLmxlZnQsIHMqcGFkLnRvcCk7XG4gIH1cbiAgXG4gIGluaXRpYWxpemVMaW5lRGFzaCh0aGlzLl9jdHgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHNjYWxlQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIC8vIGdldCBjYW52YXMgcGl4ZWwgZGF0YVxuICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IChcbiAgICAgICAgY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8pIHx8IDEsXG4gICAgICByYXRpbyA9IGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblxuICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyAhPT0gYmFja2luZ1N0b3JlUmF0aW8pIHtcbiAgICB2YXIgdyA9IGNhbnZhcy53aWR0aCwgaCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgLy8gc2V0IGFjdHVhbCBhbmQgdmlzaWJsZSBjYW52YXMgc2l6ZVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3ICogcmF0aW8pO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaCAqIHJhdGlvKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gIH1cbiAgcmV0dXJuIHJhdGlvO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTGluZURhc2goY3R4KSB7XG4gIGlmIChjdHgudmdMaW5lRGFzaCkgcmV0dXJuOyAvLyBhbHJlYWR5IHNldFxuXG4gIHZhciBOT0RBU0ggPSBbXTtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICAgIGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLnNldExpbmVEYXNoKGRhc2ggfHwgTk9EQVNIKTsgfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gb2ZmOyB9O1xuICB9IGVsc2UgaWYgKGN0eC53ZWJraXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0Y3R4LnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMud2Via2l0TGluZURhc2ggPSBkYXNoIHx8IE5PREFTSDsgfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyB0aGlzLndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gb2ZmOyB9O1xuICB9IGVsc2UgaWYgKGN0eC5tb3pEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5tb3pEYXNoID0gZGFzaDsgfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICB9IGVsc2Uge1xuICAgIGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICAgIGN0eC52Z0xpbmVEYXNoT2Zmc2V0ID0gZnVuY3Rpb24ob2ZmKSB7IC8qIHVuc3VwcG9ydGVkICovIH07XG4gIH1cbn1cblxucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgaWYgKGN0eCkgeyB0aGlzLl9jdHggPSBjdHg7IHJldHVybiB0aGlzOyB9XG4gIGVsc2UgcmV0dXJuIHRoaXMuX2N0eDtcbn07XG5cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbnByb3RvdHlwZS5wZW5kaW5nSW1hZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbWdsb2FkO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlZEJvdW5kcyhpdGVtLCBib3VuZHMpIHtcbiAgdmFyIGIgPSBuZXcgQm91bmRzKGJvdW5kcyk7XG4gIHdoaWxlICgoaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkgIT0gbnVsbCkge1xuICAgIGIudHJhbnNsYXRlKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCk7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG4gIFxuZnVuY3Rpb24gZ2V0Qm91bmRzKGl0ZW1zKSB7XG4gIHJldHVybiAhaXRlbXMgPyBudWxsIDpcbiAgICBkbC5hcnJheShpdGVtcykucmVkdWNlKGZ1bmN0aW9uKGIsIGl0ZW0pIHtcbiAgICAgIHJldHVybiBiLnVuaW9uKHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgaXRlbS5ib3VuZHMpKVxuICAgICAgICAgICAgICAudW5pb24odHJhbnNsYXRlZEJvdW5kcyhpdGVtLCBpdGVtWydib3VuZHM6cHJldiddKSk7XG4gICAgfSwgbmV3IEJvdW5kcygpKTsgIFxufVxuXG5mdW5jdGlvbiBzZXRCb3VuZHMoZywgYm91bmRzKSB7XG4gIHZhciBiYm94ID0gbnVsbDtcbiAgaWYgKGJvdW5kcykge1xuICAgIGJib3ggPSAobmV3IEJvdW5kcyhib3VuZHMpKS5yb3VuZCgpO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5yZWN0KGJib3gueDEsIGJib3gueTEsIGJib3gud2lkdGgoKSwgYmJveC5oZWlnaHQoKSk7XG4gICAgZy5jbGlwKCk7XG4gIH1cbiAgcmV0dXJuIGJib3g7XG59XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgdmFyIGcgPSB0aGlzLl9jdHgsXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgdyA9IHRoaXMuX3dpZHRoICsgcGFkLmxlZnQgKyBwYWQucmlnaHQsXG4gICAgICBoID0gdGhpcy5faGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20sXG4gICAgICBiYiA9IG51bGwsIGJiMjtcblxuICAvLyBzZXR1cFxuICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICBnLnNhdmUoKTtcbiAgYmIgPSBzZXRCb3VuZHMoZywgZ2V0Qm91bmRzKGl0ZW1zKSk7XG4gIGcuY2xlYXJSZWN0KC1wYWQubGVmdCwgLXBhZC50b3AsIHcsIGgpO1xuXG4gIC8vIHJlbmRlclxuICB0aGlzLmRyYXcoZywgc2NlbmUsIGJiKTtcblxuICAvLyByZW5kZXIgYWdhaW4gdG8gaGFuZGxlIHBvc3NpYmxlIGJvdW5kcyBjaGFuZ2VcbiAgaWYgKGl0ZW1zKSB7XG4gICAgZy5yZXN0b3JlKCk7XG4gICAgZy5zYXZlKCk7XG4gICAgYmIyID0gc2V0Qm91bmRzKGcsIGdldEJvdW5kcyhpdGVtcykpO1xuICAgIGlmICghYmIuZW5jbG9zZXMoYmIyKSkge1xuICAgICAgZy5jbGVhclJlY3QoLXBhZC5sZWZ0LCAtcGFkLnRvcCwgdywgaCk7XG4gICAgICB0aGlzLmRyYXcoZywgc2NlbmUsIGJiMik7XG4gICAgfVxuICB9XG4gIFxuICAvLyB0YWtlZG93blxuICBnLnJlc3RvcmUoKTtcbiAgdGhpcy5fc2NlbmUgPSBudWxsO1xufTtcblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmFyIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICByZW5kZXJlciA9IG1hcmtzLmRyYXdbbWFya3R5cGVdO1xuICByZW5kZXJlci5jYWxsKHRoaXMsIGN0eCwgc2NlbmUsIGJvdW5kcyk7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyQXN5bmMgPSBmdW5jdGlvbihzY2VuZSkge1xuICAvLyBUT0RPIG1ha2Ugc2FmZSBmb3IgbXVsdGlwbGUgc2NlbmUgcmVuZGVyaW5nP1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICBpZiAocmVuZGVyZXIuX2FzeW5jX2lkKSB7XG4gICAgY2xlYXJUaW1lb3V0KHJlbmRlcmVyLl9hc3luY19pZCk7XG4gIH1cbiAgcmVuZGVyZXIuX2FzeW5jX2lkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUpO1xuICAgIGRlbGV0ZSByZW5kZXJlci5fYXN5bmNfaWQ7XG4gIH0sIDUwKTtcbn07XG5cbnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcyxcbiAgICAgIHNjZW5lID0gcmVuZGVyZXIuX3NjZW5lLFxuICAgICAgaW1hZ2UgPSBudWxsLCB1cmw7XG5cbiAgcmVuZGVyZXIuX2ltZ2xvYWQgKz0gMTtcbiAgaWYgKGRsLmlzTm9kZSkge1xuICAgIGltYWdlID0gbmV3ICgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5jYW52YXMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmNhbnZhcyA6IG51bGwpLkltYWdlKSgpO1xuICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IHVyaX0sIGNvbmZpZy5sb2FkKSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7IGRsLmVycm9yKGVycik7IHJldHVybjsgfVxuICAgICAgaW1hZ2Uuc3JjID0gZGF0YTtcbiAgICAgIGltYWdlLmxvYWRlZCA9IHRydWU7XG4gICAgICByZW5kZXJlci5faW1nbG9hZCAtPSAxO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdXJsID0gY29uZmlnLmJhc2VVUkwgKyB1cmk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuX2ltZ2xvYWQgLT0gMTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlckFzeW5jKHNjZW5lKTtcbiAgICB9O1xuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgfVxuXG4gIHJldHVybiBpbWFnZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhhbmRsZXI6ICByZXF1aXJlKCcuL0hhbmRsZXInKSxcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vUmVuZGVyZXInKVxufTsiLCJ2YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Cb3VuZHMnKSxcbiAgICBib3VuZHNDYWxjID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ib3VuZHMnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpLFxuICAgIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxudmFyIHBhcnNlUGF0aCA9IHBhdGgucGFyc2UsXG4gICAgcmVuZGVyUGF0aCA9IHBhdGgucmVuZGVyLFxuICAgIGhhbGZwaSA9IE1hdGguUEkgLyAyLFxuICAgIHNxcnQzID0gTWF0aC5zcXJ0KDMpLFxuICAgIHRhbjMwID0gTWF0aC50YW4oMzAgKiBNYXRoLlBJIC8gMTgwKSxcbiAgICB0bXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICByZXR1cm4gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbn1cblxuLy8gcGF0aCBnZW5lcmF0b3JzXG5cbmZ1bmN0aW9uIGFyY1BhdGgoZywgbykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgaXIgPSBvLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IG8ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIHNhID0gKG8uc3RhcnRBbmdsZSB8fCAwKSAtIE1hdGguUEkvMixcbiAgICAgIGVhID0gKG8uZW5kQW5nbGUgfHwgMCkgLSBNYXRoLlBJLzI7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIGlmIChpciA9PT0gMCkgZy5tb3ZlVG8oeCwgeSk7XG4gIGVsc2UgZy5hcmMoeCwgeSwgaXIsIHNhLCBlYSwgMCk7XG4gIGcuYXJjKHgsIHksIG9yLCBlYSwgc2EsIDEpO1xuICBnLmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBhcmVhUGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgbSA9IG8ubWFyayxcbiAgICAgIHAgPSBtLnBhdGhDYWNoZSB8fCAobS5wYXRoQ2FjaGUgPSBwYXJzZVBhdGgocGF0aC5hcmVhKGl0ZW1zKSkpO1xuICByZW5kZXJQYXRoKGcsIHApO1xufVxuXG5mdW5jdGlvbiBsaW5lUGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgbSA9IG8ubWFyayxcbiAgICAgIHAgPSBtLnBhdGhDYWNoZSB8fCAobS5wYXRoQ2FjaGUgPSBwYXJzZVBhdGgocGF0aC5saW5lKGl0ZW1zKSkpO1xuICByZW5kZXJQYXRoKGcsIHApO1xufVxuXG5mdW5jdGlvbiBwYXRoUGF0aChnLCBvKSB7XG4gIGlmIChvLnBhdGggPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlUGF0aChvLnBhdGgpKTtcbiAgcmV0dXJuIHJlbmRlclBhdGgoZywgcCwgby54LCBvLnkpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2xQYXRoKGcsIG8pIHtcbiAgZy5iZWdpblBhdGgoKTtcbiAgdmFyIHNpemUgPSBvLnNpemUgIT0gbnVsbCA/IG8uc2l6ZSA6IDEwMCxcbiAgICAgIHggPSBvLngsIHkgPSBvLnksIHIsIHQsIHJ4LCByeTtcblxuICBpZiAoby5zaGFwZSA9PSBudWxsIHx8IG8uc2hhcGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICByID0gTWF0aC5zcXJ0KHNpemUvTWF0aC5QSSk7XG4gICAgZy5hcmMoeCwgeSwgciwgMCwgMipNYXRoLlBJLCAwKTtcbiAgICBnLmNsb3NlUGF0aCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoby5zaGFwZSkge1xuICAgIGNhc2UgXCJjcm9zc1wiOlxuICAgICAgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgdCA9IDMqcjtcbiAgICAgIGcubW92ZVRvKHgtdCwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgtciwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgtciwgeS10KTtcbiAgICAgIGcubGluZVRvKHgrciwgeS10KTtcbiAgICAgIGcubGluZVRvKHgrciwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgrdCwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgrdCwgeStyKTtcbiAgICAgIGcubGluZVRvKHgrciwgeStyKTtcbiAgICAgIGcubGluZVRvKHgrciwgeSt0KTtcbiAgICAgIGcubGluZVRvKHgtciwgeSt0KTtcbiAgICAgIGcubGluZVRvKHgtciwgeStyKTtcbiAgICAgIGcubGluZVRvKHgtdCwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIHRhbjMwKSk7XG4gICAgICByeCA9IHJ5ICogdGFuMzA7XG4gICAgICBnLm1vdmVUbyh4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHkpO1xuICAgICAgZy5saW5lVG8oeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGcucmVjdCh4LXIsIHktciwgdCwgdCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS1kb3duXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGcubW92ZVRvKHgsIHkrcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5LXJ5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLXVwXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5K3J5KTtcbiAgfVxuICBnLmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBsaW5lU3Ryb2tlKGcsIGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBsdyA9IG8uc3Ryb2tlV2lkdGgsXG4gICAgICBsYyA9IG8uc3Ryb2tlQ2FwO1xuICBnLmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgbGluZVBhdGgoZywgaXRlbXMpO1xufVxuXG5mdW5jdGlvbiBydWxlU3Ryb2tlKGcsIG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwLFxuICAgICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MSxcbiAgICAgIGx3ID0gby5zdHJva2VXaWR0aCxcbiAgICAgIGxjID0gby5zdHJva2VDYXA7XG5cbiAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgZy5saW5lQ2FwICAgPSBsYyAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIGcubW92ZVRvKHgxLCB5MSk7XG4gIGcubGluZVRvKHgyLCB5Mik7XG59XG5cbi8vIGRyYXdpbmcgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGRyYXdQYXRoT25lKHBhdGgsIGcsIG8sIGl0ZW1zKSB7XG4gIHZhciBmaWxsID0gby5maWxsLCBzdHJva2UgPSBvLnN0cm9rZSwgb3BhYywgbGMsIGx3O1xuXG4gIHBhdGgoZywgaXRlbXMpO1xuXG4gIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gIGlmIChvcGFjID09IDAgfHwgIWZpbGwgJiYgIXN0cm9rZSkgcmV0dXJuO1xuXG4gIGlmIChmaWxsKSB7XG4gICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5maWxsT3BhY2l0eT09bnVsbCA/IDEgOiBvLmZpbGxPcGFjaXR5KTtcbiAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIGZpbGwpO1xuICAgIGcuZmlsbCgpO1xuICB9XG5cbiAgaWYgKHN0cm9rZSkge1xuICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gICAgaWYgKGx3ID4gMCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgc3Ryb2tlKTtcbiAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICAgICAgZy52Z0xpbmVEYXNoKG8uc3Ryb2tlRGFzaCB8fCBudWxsKTtcbiAgICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UGF0aEFsbChwYXRoLCBnLCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBpLCBsZW4sIGl0ZW07XG4gIGZvciAoaT0wLCBsZW49c2NlbmUuaXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHNjZW5lLml0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcbiAgICBkcmF3UGF0aE9uZShwYXRoLCBnLCBpdGVtLCBpdGVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmVjdChnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgZmlsbCwgc3Ryb2tlLCBvcGFjLCBsYywgbHcsIHgsIHksIHcsIGg7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIHggPSBvLnggfHwgMDtcbiAgICB5ID0gby55IHx8IDA7XG4gICAgdyA9IG8ud2lkdGggfHwgMDtcbiAgICBoID0gby5oZWlnaHQgfHwgMDtcblxuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT0gMCkgY29udGludWU7XG5cbiAgICBpZiAoZmlsbCA9IG8uZmlsbCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5maWxsT3BhY2l0eT09bnVsbCA/IDEgOiBvLmZpbGxPcGFjaXR5KTtcbiAgICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgZmlsbCk7XG4gICAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UgPSBvLnN0cm9rZSkge1xuICAgICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBzdHJva2UpO1xuICAgICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICAgICAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgICAgICBnLnZnTGluZURhc2hPZmZzZXQoby5zdHJva2VEYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgICBnLnN0cm9rZVJlY3QoeCwgeSwgdywgaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSdWxlKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBzdHJva2UsIG9wYWMsIGxjLCBsdywgeDEsIHkxLCB4MiwgeTI7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIHgxID0gby54IHx8IDA7XG4gICAgeTEgPSBvLnkgfHwgMDtcbiAgICB4MiA9IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MTtcbiAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MTtcblxuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT0gMCkgY29udGludWU7XG4gICAgXG4gICAgaWYgKHN0cm9rZSA9IG8uc3Ryb2tlKSB7XG4gICAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICAgICAgaWYgKGx3ID4gMCkge1xuICAgICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKGcsIG8sIHN0cm9rZSk7XG4gICAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGcubGluZUNhcCA9IChsYyA9IG8uc3Ryb2tlQ2FwKSAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gICAgICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGcubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGcubGluZVRvKHgyLCB5Mik7XG4gICAgICAgIGcuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdJbWFnZShnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLCBvO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBpZiAoIShvLmltYWdlICYmIG8uaW1hZ2UudXJsID09PSBvLnVybCkpIHtcbiAgICAgIG8uaW1hZ2UgPSByZW5kZXJlci5sb2FkSW1hZ2Uoby51cmwpO1xuICAgICAgby5pbWFnZS51cmwgPSBvLnVybDtcbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgdywgaCwgb3BhYztcbiAgICB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwO1xuICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMDtcbiAgICB4ID0gKG8ueHx8MCkgLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKTtcbiAgICB5ID0gKG8ueXx8MCkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSk7XG5cbiAgICBpZiAoby5pbWFnZS5sb2FkZWQpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSAob3BhYyA9IG8ub3BhY2l0eSkgIT0gbnVsbCA/IG9wYWMgOiAxO1xuICAgICAgZy5kcmF3SW1hZ2Uoby5pbWFnZSwgeCwgeSwgdywgaCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBmaWxsLCBzdHJva2UsIG9wYWMsIGx3LCB4LCB5LCByLCB0O1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBnLmZvbnQgPSBmb250U3RyaW5nKG8pO1xuICAgIGcudGV4dEFsaWduID0gby5hbGlnbiB8fCBcImxlZnRcIjtcbiAgICBnLnRleHRCYXNlbGluZSA9IG8uYmFzZWxpbmUgfHwgXCJhbHBoYWJldGljXCI7XG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09IDApIGNvbnRpbnVlO1xuXG4gICAgeCA9IG8ueCB8fCAwO1xuICAgIHkgPSBvLnkgfHwgMDtcbiAgICBpZiAociA9IG8ucmFkaXVzKSB7XG4gICAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICAgIH1cblxuICAgIGlmIChvLmFuZ2xlKSB7XG4gICAgICBnLnNhdmUoKTtcbiAgICAgIGcudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgZy5yb3RhdGUoby5hbmdsZSAqIE1hdGguUEkvMTgwKTtcbiAgICAgIHggPSBvLmR4IHx8IDA7XG4gICAgICB5ID0gby5keSB8fCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IChvLmR4IHx8IDApO1xuICAgICAgeSArPSAoby5keSB8fCAwKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsbCA9IG8uZmlsbCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5maWxsT3BhY2l0eT09bnVsbCA/IDEgOiBvLmZpbGxPcGFjaXR5KTtcbiAgICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgZmlsbCk7XG4gICAgICBnLmZpbGxUZXh0KG8udGV4dCwgeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSA9IG8uc3Ryb2tlKSB7XG4gICAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IDE7XG4gICAgICBpZiAobHcgPiAwKSB7XG4gICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3Iobywgc3Ryb2tlKTtcbiAgICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgICAgZy5zdHJva2VUZXh0KG8udGV4dCwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG8uYW5nbGUpIGcucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdBbGwocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBkcmF3UGF0aEFsbChwYXRoRnVuYywgZywgc2NlbmUsIGJvdW5kcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd09uZShwYXRoRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oZywgc2NlbmUsIGJvdW5kcykge1xuICAgIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoc2NlbmUuaXRlbXNbMF0uYm91bmRzKSlcbiAgICAgIHJldHVybjsgLy8gYm91bmRzIGNoZWNrXG4gICAgZHJhd1BhdGhPbmUocGF0aEZ1bmMsIGcsIHNjZW5lLml0ZW1zWzBdLCBzY2VuZS5pdGVtcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0dyb3VwKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsIGdyb3VwLCBheGVzLCBsZWdlbmRzLFxuICAgICAgcmVuZGVyZXIgPSB0aGlzLCBneCwgZ3ksIGdiLCBpLCBuLCBqLCBtO1xuXG4gIGRyYXdSZWN0KGcsIHNjZW5lLCBib3VuZHMpO1xuXG4gIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncm91cCA9IGl0ZW1zW2ldO1xuICAgIGF4ZXMgPSBncm91cC5heGlzSXRlbXMgfHwgW107XG4gICAgbGVnZW5kcyA9IGdyb3VwLmxlZ2VuZEl0ZW1zIHx8IFtdO1xuICAgIGd4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGd5ID0gZ3JvdXAueSB8fCAwO1xuXG4gICAgLy8gcmVuZGVyIGdyb3VwIGNvbnRlbnRzXG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBpZiAoZ3JvdXAuY2xpcCkge1xuICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgIGcucmVjdCgwLCAwLCBncm91cC53aWR0aCB8fCAwLCBncm91cC5oZWlnaHQgfHwgMCk7XG4gICAgICBnLmNsaXAoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gICAgXG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIHJlbmRlcmVyLmRyYXcoZywgYXhlc1tqXSwgYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09Z3JvdXAuaXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgcmVuZGVyZXIuZHJhdyhnLCBncm91cC5pdGVtc1tqXSwgYm91bmRzKTtcbiAgICB9XG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgIT09IFwiYmFja1wiKSB7XG4gICAgICAgIHJlbmRlcmVyLmRyYXcoZywgYXhlc1tqXSwgYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICByZW5kZXJlci5kcmF3KGcsIGxlZ2VuZHNbal0sIGJvdW5kcyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBnLnJlc3RvcmUoKTtcbiAgfSAgICBcbn1cblxuZnVuY3Rpb24gY29sb3IoZywgbywgdmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZS5pZClcbiAgICA/IGdyYWRpZW50KGcsIHZhbHVlLCBvLmJvdW5kcylcbiAgICA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBncmFkaWVudChnLCBwLCBiKSB7XG4gIHZhciB3ID0gYi53aWR0aCgpLFxuICAgICAgaCA9IGIuaGVpZ2h0KCksXG4gICAgICB4MSA9IGIueDEgKyBwLngxICogdyxcbiAgICAgIHkxID0gYi55MSArIHAueTEgKiBoLFxuICAgICAgeDIgPSBiLngxICsgcC54MiAqIHcsXG4gICAgICB5MiA9IGIueTEgKyBwLnkyICogaCxcbiAgICAgIGdyYWQgPSBnLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSxcbiAgICAgIHN0b3AgPSBwLnN0b3BzLFxuICAgICAgaSwgbjtcblxuICBmb3IgKGk9MCwgbj1zdG9wLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncmFkLmFkZENvbG9yU3RvcChzdG9wW2ldLm9mZnNldCwgc3RvcFtpXS5jb2xvcik7XG4gIH1cbiAgcmV0dXJuIGdyYWQ7XG59XG5cbi8vIGhpdCB0ZXN0aW5nXG5cbmZ1bmN0aW9uIHBpY2tHcm91cChnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChzY2VuZS5pdGVtcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIHNjZW5lLmJvdW5kcyAmJiAhc2NlbmUuYm91bmRzLmNvbnRhaW5zKGd4LCBneSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsIHN1YnNjZW5lLCBncm91cCwgaGl0LCBkeCwgZHksXG4gICAgICBoYW5kbGVyID0gdGhpcywgaSwgajtcblxuICBmb3IgKGk9aXRlbXMubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgZ3JvdXAgPSBpdGVtc1tpXTtcbiAgICBkeCA9IGdyb3VwLnggfHwgMDtcbiAgICBkeSA9IGdyb3VwLnkgfHwgMDtcblxuICAgIGcuc2F2ZSgpO1xuICAgIGcudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgZm9yIChqPWdyb3VwLml0ZW1zLmxlbmd0aDsgLS1qID49IDA7KSB7XG4gICAgICBzdWJzY2VuZSA9IGdyb3VwLml0ZW1zW2pdO1xuICAgICAgaWYgKHN1YnNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSkgY29udGludWU7XG4gICAgICBoaXQgPSBoYW5kbGVyLnBpY2soc3Vic2NlbmUsIHgsIHksIGd4LWR4LCBneS1keSk7XG4gICAgICBpZiAoaGl0KSB7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgfVxuICAgIH1cbiAgICBnLnJlc3RvcmUoKTtcbiAgfVxuXG4gIHJldHVybiBzY2VuZS5pbnRlcmFjdGl2ZVxuICAgID8gcGlja0FsbChoaXRUZXN0cy5ncm91cCwgZywgc2NlbmUsIHgsIHksIGd4LCBneSlcbiAgICA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwaWNrQWxsKHRlc3QsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIG8sIGIsIGk7XG5cbiAgaWYgKGcuX3JhdGlvICE9PSAxKSB7XG4gICAgeCAqPSBnLl9yYXRpbztcbiAgICB5ICo9IGcuX3JhdGlvO1xuICB9XG5cbiAgZm9yIChpPXNjZW5lLml0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgbyA9IHNjZW5lLml0ZW1zW2ldOyBiID0gby5ib3VuZHM7XG4gICAgLy8gZmlyc3QgaGl0IHRlc3QgYWdhaW5zdCBib3VuZGluZyBib3hcbiAgICBpZiAoKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgfHwgIWIpIGNvbnRpbnVlO1xuICAgIC8vIGlmIGluIGJvdW5kaW5nIGJveCwgcGVyZm9ybSBtb3JlIGNhcmVmdWwgdGVzdFxuICAgIGlmICh0ZXN0KGcsIG8sIHgsIHksIGd4LCBneSkpIHJldHVybiBvO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGlja0FyZWEoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGIsIGksIGRpLCBkZCwgb2QsIGR4LCBkeTtcblxuICBiID0gaXRlbXNbMF0uYm91bmRzO1xuICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChnLl9yYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5fcmF0aW87XG4gICAgeSAqPSBnLl9yYXRpbztcbiAgfVxuICBpZiAoIWhpdFRlc3RzLmFyZWEoZywgaXRlbXMsIHgsIHkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVtc1swXTtcbn1cblxuZnVuY3Rpb24gcGlja0xpbmUoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGIsIGksIGRpLCBkZCwgb2QsIGR4LCBkeTtcblxuICBiID0gaXRlbXNbMF0uYm91bmRzO1xuICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChnLl9yYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5fcmF0aW87XG4gICAgeSAqPSBnLl9yYXRpbztcbiAgfVxuICBpZiAoIWhpdFRlc3RzLmxpbmUoZywgaXRlbXMsIHgsIHkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVtc1swXTtcbn1cblxuZnVuY3Rpb24gcGljayh0ZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICAgIHJldHVybiBwaWNrQWxsKHRlc3QsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0SGl0KGcsIG8sIHgsIHksIGd4LCBneSkge1xuICBpZiAoIW8uZm9udFNpemUpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFvLmFuZ2xlKSByZXR1cm4gdHJ1ZTsgLy8gYm91bmRzIHN1ZmZpY2llbnQgaWYgbm8gcm90YXRpb25cblxuICB2YXIgYiA9IGJvdW5kc0NhbGMudGV4dChvLCB0bXBCb3VuZHMsIHRydWUpLFxuICAgICAgYSA9IC1vLmFuZ2xlICogTWF0aC5QSSAvIDE4MCxcbiAgICAgIGNvcyA9IE1hdGguY29zKGEpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYSksXG4gICAgICB4ID0gby54LFxuICAgICAgeSA9IG8ueSxcbiAgICAgIHB4ID0gY29zKmd4IC0gc2luKmd5ICsgKHggLSB4KmNvcyArIHkqc2luKSxcbiAgICAgIHB5ID0gc2luKmd4ICsgY29zKmd5ICsgKHkgLSB4KnNpbiAtIHkqY29zKTtcblxuICByZXR1cm4gYi5jb250YWlucyhweCwgcHkpO1xufVxuXG52YXIgaGl0VGVzdHMgPSB7XG4gIHRleHQ6ICAgdGV4dEhpdCxcbiAgcmVjdDogICBmdW5jdGlvbihnLG8seCx5KSB7IHJldHVybiB0cnVlOyB9LCAvLyBib3VuZHMgdGVzdCBpcyBzdWZmaWNpZW50XG4gIGltYWdlOiAgZnVuY3Rpb24oZyxvLHgseSkgeyByZXR1cm4gdHJ1ZTsgfSwgLy8gYm91bmRzIHRlc3QgaXMgc3VmZmljaWVudFxuICBncm91cDogIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcmV0dXJuIG8uZmlsbCB8fCBvLnN0cm9rZTsgfSxcbiAgcnVsZTogICBmdW5jdGlvbihnLG8seCx5KSB7XG4gICAgICAgICAgICBpZiAoIWcuaXNQb2ludEluU3Ryb2tlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBydWxlU3Ryb2tlKGcsbyk7IHJldHVybiBnLmlzUG9pbnRJblN0cm9rZSh4LHkpO1xuICAgICAgICAgIH0sXG4gIGxpbmU6ICAgZnVuY3Rpb24oZyxzLHgseSkge1xuICAgICAgICAgICAgaWYgKCFnLmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGluZVN0cm9rZShnLHMpOyByZXR1cm4gZy5pc1BvaW50SW5TdHJva2UoeCx5KTtcbiAgICAgICAgICB9LFxuICBhcmM6ICAgIGZ1bmN0aW9uKGcsbyx4LHkpIHsgYXJjUGF0aChnLG8pOyAgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9LFxuICBhcmVhOiAgIGZ1bmN0aW9uKGcscyx4LHkpIHsgYXJlYVBhdGgoZyxzKTsgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9LFxuICBwYXRoOiAgIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcGF0aFBhdGgoZyxvKTsgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9LFxuICBzeW1ib2w6IGZ1bmN0aW9uKGcsbyx4LHkpIHsgc3ltYm9sUGF0aChnLG8pOyByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB7XG4gICAgZ3JvdXA6ICAgZHJhd0dyb3VwLFxuICAgIGFyZWE6ICAgIGRyYXdPbmUoYXJlYVBhdGgpLFxuICAgIGxpbmU6ICAgIGRyYXdPbmUobGluZVBhdGgpLFxuICAgIGFyYzogICAgIGRyYXdBbGwoYXJjUGF0aCksXG4gICAgcGF0aDogICAgZHJhd0FsbChwYXRoUGF0aCksXG4gICAgc3ltYm9sOiAgZHJhd0FsbChzeW1ib2xQYXRoKSxcbiAgICByZWN0OiAgICBkcmF3UmVjdCxcbiAgICBydWxlOiAgICBkcmF3UnVsZSxcbiAgICB0ZXh0OiAgICBkcmF3VGV4dCxcbiAgICBpbWFnZTogICBkcmF3SW1hZ2UsXG4gICAgZHJhd09uZTogZHJhd09uZSwgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gICAgZHJhd0FsbDogZHJhd0FsbCAgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gIH0sXG4gIHBpY2s6IHtcbiAgICBncm91cDogICBwaWNrR3JvdXAsXG4gICAgYXJlYTogICAgcGlja0FyZWEsXG4gICAgbGluZTogICAgcGlja0xpbmUsXG4gICAgYXJjOiAgICAgcGljayhoaXRUZXN0cy5hcmMpLFxuICAgIHBhdGg6ICAgIHBpY2soaGl0VGVzdHMucGF0aCksXG4gICAgc3ltYm9sOiAgcGljayhoaXRUZXN0cy5zeW1ib2wpLFxuICAgIHJlY3Q6ICAgIHBpY2soaGl0VGVzdHMucmVjdCksXG4gICAgcnVsZTogICAgcGljayhoaXRUZXN0cy5ydWxlKSxcbiAgICB0ZXh0OiAgICBwaWNrKGhpdFRlc3RzLnRleHQpLFxuICAgIGltYWdlOiAgIHBpY2soaGl0VGVzdHMuaW1hZ2UpLFxuICAgIHBpY2tBbGw6IHBpY2tBbGwgIC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICB9XG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRzJyk7XG5cbi8vIFBhdGggcGFyc2luZyBhbmQgcmVuZGVyaW5nIGNvZGUgdGFrZW4gZnJvbSBmYWJyaWMuanMgLS0gVGhhbmtzIVxudmFyIGNtZExlbmd0aCA9IHsgbToyLCBsOjIsIGg6MSwgdjoxLCBjOjYsIHM6NCwgcTo0LCB0OjIsIGE6NyB9LFxuICAgIHJlID0gWy8oW01MSFZDU1FUQVptbGh2Y3NxdGF6XSkvZywgLyMjIy8sIC8oXFxkKS0vZywgL1xcc3wsfCMjIy9dO1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGN1cnJlbnRQYXRoLFxuICAgICAgY2h1bmtzLFxuICAgICAgcGFyc2VkO1xuXG4gIC8vIEZpcnN0LCBicmVhayBwYXRoIGludG8gY29tbWFuZCBzZXF1ZW5jZVxuICBwYXRoID0gcGF0aC5zbGljZSgpLnJlcGxhY2UocmVbMF0sICcjIyMkMScpLnNwbGl0KHJlWzFdKS5zbGljZSgxKTtcblxuICAvLyBOZXh0LCBwYXJzZSBlYWNoIGNvbW1hbmQgaW4gdHVyblxuICBmb3IgKHZhciBpPTAsIGosIGNodW5rc1BhcnNlZCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgY3VycmVudFBhdGggPSBwYXRoW2ldO1xuICAgIGNodW5rcyA9IGN1cnJlbnRQYXRoLnNsaWNlKDEpLnRyaW0oKS5yZXBsYWNlKHJlWzJdLCckMSMjIy0nKS5zcGxpdChyZVszXSk7XG4gICAgY2h1bmtzUGFyc2VkID0gW2N1cnJlbnRQYXRoLmNoYXJBdCgwKV07XG5cbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNodW5rcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY2h1bmtzW2pdKTtcbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICBjaHVua3NQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21tYW5kID0gY2h1bmtzUGFyc2VkWzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbW1hbmRMZW5ndGggPSBjbWRMZW5ndGhbY29tbWFuZF07XG5cbiAgICBpZiAoY2h1bmtzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMSwga2xlbiA9IGNodW5rc1BhcnNlZC5sZW5ndGg7IGsgPCBrbGVuOyBrICs9IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goWyBjaHVua3NQYXJzZWRbMF0gXS5jb25jYXQoY2h1bmtzUGFyc2VkLnNsaWNlKGssIGsgKyBjb21tYW5kTGVuZ3RoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNodW5rc1BhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyYyhnLCB4LCB5LCBjb29yZHMsIGJvdW5kcywgbCwgdCkge1xuICB2YXIgcnggPSBjb29yZHNbMF07XG4gIHZhciByeSA9IGNvb3Jkc1sxXTtcbiAgdmFyIHJvdCA9IGNvb3Jkc1syXTtcbiAgdmFyIGxhcmdlID0gY29vcmRzWzNdO1xuICB2YXIgc3dlZXAgPSBjb29yZHNbNF07XG4gIHZhciBleCA9IGNvb3Jkc1s1XTtcbiAgdmFyIGV5ID0gY29vcmRzWzZdO1xuICB2YXIgc2VncyA9IGFyY1RvU2VnbWVudHMoZXgsIGV5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90LCB4LCB5KTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmV6ID0gc2VnbWVudFRvQmV6aWVyLmFwcGx5KG51bGwsIHNlZ3NbaV0pO1xuICAgIGcuYmV6aWVyQ3VydmVUby5hcHBseShnLCBiZXopO1xuICAgIGJvdW5kcy5hZGQoYmV6WzBdLWwsIGJlelsxXS10KTtcbiAgICBib3VuZHMuYWRkKGJlelsyXS1sLCBiZXpbM10tdCk7XG4gICAgYm91bmRzLmFkZChiZXpbNF0tbCwgYmV6WzVdLXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kQXJjKHgsIHksIGNvb3JkcywgYm91bmRzKSB7XG4gIHZhciByeCA9IGNvb3Jkc1swXTtcbiAgdmFyIHJ5ID0gY29vcmRzWzFdO1xuICB2YXIgcm90ID0gY29vcmRzWzJdO1xuICB2YXIgbGFyZ2UgPSBjb29yZHNbM107XG4gIHZhciBzd2VlcCA9IGNvb3Jkc1s0XTtcbiAgdmFyIGV4ID0gY29vcmRzWzVdO1xuICB2YXIgZXkgPSBjb29yZHNbNl07XG4gIHZhciBzZWdzID0gYXJjVG9TZWdtZW50cyhleCwgZXksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QsIHgsIHkpO1xuICBmb3IgKHZhciBpPTA7IGk8c2Vncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiZXogPSBzZWdtZW50VG9CZXppZXIuYXBwbHkobnVsbCwgc2Vnc1tpXSk7XG4gICAgYm91bmRzLmFkZChiZXpbMF0sIGJlelsxXSk7XG4gICAgYm91bmRzLmFkZChiZXpbMl0sIGJlelszXSk7XG4gICAgYm91bmRzLmFkZChiZXpbNF0sIGJlels1XSk7XG4gIH1cbn1cblxudmFyIGFyY1RvU2VnbWVudHNDYWNoZSA9IHsgfSxcbiAgICBzZWdtZW50VG9CZXppZXJDYWNoZSA9IHsgfSxcbiAgICBqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW4sXG4gICAgYXJnc1N0cjtcblxuLy8gQ29waWVkIGZyb20gSW5rc2NhcGUgc3ZndG9wZGYsIHRoYW5rcyFcbmZ1bmN0aW9uIGFyY1RvU2VnbWVudHMoeCwgeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgsIG94LCBveSkge1xuICBhcmdzU3RyID0gam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cl0pIHtcbiAgICByZXR1cm4gYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJdO1xuICB9XG5cbiAgdmFyIHRoID0gcm90YXRlWCAqIChNYXRoLlBJLzE4MCk7XG4gIHZhciBzaW5fdGggPSBNYXRoLnNpbih0aCk7XG4gIHZhciBjb3NfdGggPSBNYXRoLmNvcyh0aCk7XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgdmFyIHB4ID0gY29zX3RoICogKG94IC0geCkgKiAwLjUgKyBzaW5fdGggKiAob3kgLSB5KSAqIDAuNTtcbiAgdmFyIHB5ID0gY29zX3RoICogKG95IC0geSkgKiAwLjUgLSBzaW5fdGggKiAob3ggLSB4KSAqIDAuNTtcbiAgdmFyIHBsID0gKHB4KnB4KSAvIChyeCpyeCkgKyAocHkqcHkpIC8gKHJ5KnJ5KTtcbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuXG4gIHZhciBhMDAgPSBjb3NfdGggLyByeDtcbiAgdmFyIGEwMSA9IHNpbl90aCAvIHJ4O1xuICB2YXIgYTEwID0gKC1zaW5fdGgpIC8gcnk7XG4gIHZhciBhMTEgPSAoY29zX3RoKSAvIHJ5O1xuICB2YXIgeDAgPSBhMDAgKiBveCArIGEwMSAqIG95O1xuICB2YXIgeTAgPSBhMTAgKiBveCArIGExMSAqIG95O1xuICB2YXIgeDEgPSBhMDAgKiB4ICsgYTAxICogeTtcbiAgdmFyIHkxID0gYTEwICogeCArIGExMSAqIHk7XG5cbiAgdmFyIGQgPSAoeDEteDApICogKHgxLXgwKSArICh5MS15MCkgKiAoeTEteTApO1xuICB2YXIgc2ZhY3Rvcl9zcSA9IDEgLyBkIC0gMC4yNTtcbiAgaWYgKHNmYWN0b3Jfc3EgPCAwKSBzZmFjdG9yX3NxID0gMDtcbiAgdmFyIHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG4gIGlmIChzd2VlcCA9PSBsYXJnZSkgc2ZhY3RvciA9IC1zZmFjdG9yO1xuICB2YXIgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxLXkwKTtcbiAgdmFyIHljID0gMC41ICogKHkwICsgeTEpICsgc2ZhY3RvciAqICh4MS14MCk7XG5cbiAgdmFyIHRoMCA9IE1hdGguYXRhbjIoeTAteWMsIHgwLXhjKTtcbiAgdmFyIHRoMSA9IE1hdGguYXRhbjIoeTEteWMsIHgxLXhjKTtcblxuICB2YXIgdGhfYXJjID0gdGgxLXRoMDtcbiAgaWYgKHRoX2FyYyA8IDAgJiYgc3dlZXAgPT0gMSl7XG4gICAgdGhfYXJjICs9IDIqTWF0aC5QSTtcbiAgfSBlbHNlIGlmICh0aF9hcmMgPiAwICYmIHN3ZWVwID09IDApIHtcbiAgICB0aF9hcmMgLT0gMiAqIE1hdGguUEk7XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhfYXJjIC8gKE1hdGguUEkgKiAwLjUgKyAwLjAwMSkpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpPTA7IGk8c2VnbWVudHM7IGkrKykge1xuICAgIHZhciB0aDIgPSB0aDAgKyBpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgdmFyIHRoMyA9IHRoMCArIChpKzEpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG5cbiAgcmV0dXJuIChhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cl0gPSByZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBzZWdtZW50VG9CZXppZXIoY3gsIGN5LCB0aDAsIHRoMSwgcngsIHJ5LCBzaW5fdGgsIGNvc190aCkge1xuICBhcmdzU3RyID0gam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyXSkge1xuICAgIHJldHVybiBzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyXTtcbiAgfVxuXG4gIHZhciBhMDAgPSBjb3NfdGggKiByeDtcbiAgdmFyIGEwMSA9IC1zaW5fdGggKiByeTtcbiAgdmFyIGExMCA9IHNpbl90aCAqIHJ4O1xuICB2YXIgYTExID0gY29zX3RoICogcnk7XG5cbiAgdmFyIGNvc190aDAgPSBNYXRoLmNvcyh0aDApO1xuICB2YXIgc2luX3RoMCA9IE1hdGguc2luKHRoMCk7XG4gIHZhciBjb3NfdGgxID0gTWF0aC5jb3ModGgxKTtcbiAgdmFyIHNpbl90aDEgPSBNYXRoLnNpbih0aDEpO1xuXG4gIHZhciB0aF9oYWxmID0gMC41ICogKHRoMSAtIHRoMCk7XG4gIHZhciBzaW5fdGhfaDIgPSBNYXRoLnNpbih0aF9oYWxmICogMC41KTtcbiAgdmFyIHQgPSAoOC8zKSAqIHNpbl90aF9oMiAqIHNpbl90aF9oMiAvIE1hdGguc2luKHRoX2hhbGYpO1xuICB2YXIgeDEgPSBjeCArIGNvc190aDAgLSB0ICogc2luX3RoMDtcbiAgdmFyIHkxID0gY3kgKyBzaW5fdGgwICsgdCAqIGNvc190aDA7XG4gIHZhciB4MyA9IGN4ICsgY29zX3RoMTtcbiAgdmFyIHkzID0gY3kgKyBzaW5fdGgxO1xuICB2YXIgeDIgPSB4MyArIHQgKiBzaW5fdGgxO1xuICB2YXIgeTIgPSB5MyAtIHQgKiBjb3NfdGgxO1xuXG4gIHJldHVybiAoc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cl0gPSBbXG4gICAgYTAwICogeDEgKyBhMDEgKiB5MSwgIGExMCAqIHgxICsgYTExICogeTEsXG4gICAgYTAwICogeDIgKyBhMDEgKiB5MiwgIGExMCAqIHgyICsgYTExICogeTIsXG4gICAgYTAwICogeDMgKyBhMDEgKiB5MywgIGExMCAqIHgzICsgYTExICogeTNcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcihnLCBwYXRoLCBsLCB0KSB7XG4gIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICBwcmV2aW91cyA9IG51bGwsXG4gICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICB0ZW1wWCxcbiAgICAgIHRlbXBZLFxuICAgICAgdGVtcENvbnRyb2xYLFxuICAgICAgdGVtcENvbnRyb2xZLFxuICAgICAgYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICBpZiAobCA9PSB1bmRlZmluZWQpIGwgPSAwO1xuICBpZiAodCA9PSB1bmRlZmluZWQpIHQgPSAwO1xuXG4gIGcuYmVnaW5QYXRoKCk7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsIC8vIHkxXG4gICAgICAgICAgY29udHJvbFggKyBsLCAvLyB4MlxuICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBsLFxuICAgICAgICAgIHkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgeCArIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMip4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMip5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGRyYXdBcmMoZywgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0gKyB4ICsgbCxcbiAgICAgICAgICBjdXJyZW50WzddICsgeSArIHRcbiAgICAgICAgXSwgYm91bmRzLCBsLCB0KTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgZHJhd0FyYyhnLCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHRcbiAgICAgICAgXSwgYm91bmRzLCBsLCB0KTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuICByZXR1cm4gYm91bmRzLnRyYW5zbGF0ZShsLCB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmRzKHBhdGgsIGJvdW5kcykge1xuICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgY29udHJvbFkgPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICAgICAgdGVtcFgsXG4gICAgICB0ZW1wWSxcbiAgICAgIHRlbXBDb250cm9sWCxcbiAgICAgIHRlbXBDb250cm9sWTtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuXG4gICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnSCc6IC8vIGhvcml6b250YWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHkgKz0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMip4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMip5IC0gY29udHJvbFk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3QnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHRcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gdGVtcENvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSB0ZW1wQ29udHJvbFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICdxJykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciBxXG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBDb250cm9sWCA9IGNvbnRyb2xYO1xuICAgICAgICB0ZW1wQ29udHJvbFkgPSBjb250cm9sWTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGJvdW5kQXJjKHgsIHksIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIHgsXG4gICAgICAgICAgY3VycmVudFs3XSArIHlcbiAgICAgICAgXSwgYm91bmRzKTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgYm91bmRBcmMoeCwgeSwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdLFxuICAgICAgICAgIGN1cnJlbnRbN11cbiAgICAgICAgXSwgYm91bmRzKTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBhcmVhKGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgIC54KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueDsgfSlcbiAgICAueTEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55OyB9KVxuICAgIC55MChmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgKyBkLmhlaWdodDsgfSk7XG4gIGlmIChvLmludGVycG9sYXRlKSBhcmVhLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUpO1xuICBpZiAoby50ZW5zaW9uICE9IG51bGwpIGFyZWEudGVuc2lvbihvLnRlbnNpb24pO1xuICByZXR1cm4gYXJlYShpdGVtcyk7XG59XG5cbmZ1bmN0aW9uIGxpbmUoaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAueChmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pXG4gICAueShmdW5jdGlvbihkKSB7IHJldHVybiBkLnk7IH0pO1xuICBpZiAoby5pbnRlcnBvbGF0ZSkgbGluZS5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlKTtcbiAgaWYgKG8udGVuc2lvbiAhPSBudWxsKSBsaW5lLnRlbnNpb24oby50ZW5zaW9uKTtcbiAgcmV0dXJuIGxpbmUoaXRlbXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6ICBwYXJzZSxcbiAgcmVuZGVyOiByZW5kZXIsXG4gIGJvdW5kczogYm91bmRzLFxuICBhcmVhOiAgIGFyZWEsXG4gIGxpbmU6ICAgbGluZVxufTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpLFxuICAgIFNWR0J1aWxkZXIgPSByZXF1aXJlKCcuL3N2ZycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYnVpbGRlciA9IG51bGw7XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fYnVpbGRlciA9IG5ldyBTVkdCdWlsZGVyKCk7XG4gIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwYWQpO1xufVxuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZCB8fCB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICB0aGlzLl9hdXRvcGFkID0gZGwuaXNTdHJpbmcodGhpcy5fcGFkZGluZykgPyAxIDogMDtcblxuICB2YXIgdyA9IHRoaXMuX3dpZHRoLCBoID0gdGhpcy5faGVpZ2h0LCBwYWQgPSB0aGlzLl9wYWRkaW5nO1xuICBcbiAgLy8gKHJlLSljb25maWd1cmUgYnVpbGRlciBzaXplXG4gIHRoaXMuX2J1aWxkZXIuaW5pdGlhbGl6ZShudWxsLCB3LCBoLCBwYWQpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lLCBpdGVtcykge1xuICAvLyBoZWFkbGVzcyBhbHdheXMgZHJhd3MgdGhlIGVudGlyZSBzY2VuZSwgaWdub3JpbmcgaXRlbXNcbiAgdGhpcy5fYnVpbGRlci5yZW5kZXIoc2NlbmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkZXIuc3ZnKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1JlbmRlcmVyJylcbn07XG4iLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZ2lkID0gMDsgLy8gZ3JvdXAgaWQgY291bnRlciBmb3IgZDMgZG9tIGNvbXBhdFxuICB0aGlzLl90ZXh0ID0ge1xuICAgIGhlYWQ6IFwiXCIsXG4gICAgcm9vdDogXCJcIixcbiAgICBmb290OiBcIlwiLFxuICAgIGRlZnM6IFwiXCIsXG4gICAgYm9keTogXCJcIlxuICB9O1xuICB0aGlzLl9kZWZzID0ge1xuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG9wZW4odGFnLCBhdHRyLCByYXcpIHtcbiAgdmFyIHMgPSBcIjxcIiArIHRhZztcbiAgaWYgKGF0dHIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXR0cikge1xuICAgICAgdmFyIHZhbCA9IGF0dHJba2V5XTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICBzICs9IFwiIFwiICsga2V5ICsgJz1cIicgKyB2YWwgKyAnXCInO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmF3KSBzICs9IFwiIFwiICsgcmF3O1xuICByZXR1cm4gcyArIFwiPlwiO1xufVxuXG5mdW5jdGlvbiBjbG9zZSh0YWcpIHtcbiAgcmV0dXJuIFwiPC9cIiArIHRhZyArIFwiPlwiO1xufVxuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3LCBoLCBwYWQpIHtcbiAgdmFyIHQgPSB0aGlzLl90ZXh0O1xuXG4gIHQuaGVhZCA9IG9wZW4oJ3N2ZycsIHtcbiAgICBcImNsYXNzXCI6ICdtYXJrcycsXG4gICAgd2lkdGg6IHcgKyBwYWQubGVmdCArIHBhZC5yaWdodCxcbiAgICBoZWlnaHQ6IGggKyBwYWQudG9wICsgcGFkLmJvdHRvbSxcbiAgfSwgY29uZmlnLnN2Z05hbWVzcGFjZSk7XG5cbiAgdC5yb290ID0gb3BlbignZycsIHtcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHBhZC5sZWZ0ICsgJywnICsgcGFkLnRvcCArICcpJ1xuICB9KTtcblxuICB0LmZvb3QgPSBjbG9zZSgnZycpICsgY2xvc2UoJ3N2ZycpO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuX3RleHQ7XG4gIHJldHVybiB0LmhlYWQgKyB0LmRlZnMgKyB0LnJvb3QgKyB0LmJvZHkgKyB0LmZvb3Q7XG59O1xuXG5wcm90b3R5cGUuYnVpbGREZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbGwgPSB0aGlzLl9kZWZzLFxuICAgICAgZGdyYWQgPSBkbC5rZXlzKGFsbC5ncmFkaWVudCksXG4gICAgICBkY2xpcCA9IGRsLmtleXMoYWxsLmNsaXBwaW5nKSxcbiAgICAgIGRlZnMgPSBcIlwiLCBncmFkLCBjbGlwLCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPGRncmFkLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGlkID0gZGdyYWRbaV0sXG4gICAgICAgIGRlZiA9IGFsbC5ncmFkaWVudFtpZF0sXG4gICAgICAgIHN0b3BzID0gZGVmLnN0b3BzO1xuXG4gICAgZGVmcyArPSBvcGVuKFwibGluZWFyR3JhZGllbnRcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDE6IGRlZi54MSxcbiAgICAgIHgyOiBkZWYueDIsXG4gICAgICB5MTogZGVmLnkxLFxuICAgICAgeTI6IGRlZi55MlxuICAgIH0pO1xuICAgIFxuICAgIGZvciAoaj0wOyBqPHN0b3BzLmxlbmd0aDsgKytqKSB7XG4gICAgICBkZWZzICs9IG9wZW4oXCJzdG9wXCIsIHtcbiAgICAgICAgb2Zmc2V0OiBzdG9wc1tqXS5vZmZzZXQsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBzdG9wc1tqXS5jb2xvclxuICAgICAgfSkgKyBjbG9zZShcInN0b3BcIik7XG4gICAgfVxuICAgIFxuICAgIGRlZnMgKz0gY2xvc2UoXCJsaW5lYXJHcmFkaWVudFwiKTtcbiAgfVxuICBcbiAgZm9yIChpPTA7IGk8ZGNsaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaWQgPSBkY2xpcFtpXSxcbiAgICAgICAgZGVmID0gYWxsLmNsaXBwaW5nW2lkXTtcblxuICAgIGRlZnMgKz0gb3BlbihcImNsaXBQYXRoXCIsIHtpZDogaWR9KTtcblxuICAgIGRlZnMgKz0gb3BlbihcInJlY3RcIiwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZGVmLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkZWYuaGVpZ2h0XG4gICAgfSkgKyBjbG9zZShcInJlY3RcIik7XG5cbiAgICBkZWZzICs9IGNsb3NlKFwiY2xpcFBhdGhcIik7XG4gIH1cbiAgXG4gIGlmIChkZWZzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gb3BlbihcImRlZnNcIikgKyBkZWZzICsgY2xvc2UoXCJkZWZzXCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiXG4gIH1cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdGhpcy5fZ2lkID0gMDsgLy8gcmVzZXQgdGhlIGdyb3VwIGNvdW50ZXJcbiAgdGhpcy5fdGV4dC5ib2R5ID0gdGhpcy5kcmF3KHNjZW5lKTtcbiAgdGhpcy5fdGV4dC5kZWZzID0gdGhpcy5idWlsZERlZnMoKTtcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIG1ldGEgPSBNQVJLU1tzY2VuZS5tYXJrdHlwZV07XG4gIGlmICghbWV0YSkge1xuICAgIHJldHVybjsgLy8gbm8ga25vd24gbWFya3R5cGUgKGUuZy4sIGFuIGludGVyYWN0b3IpXG4gIH1cbiAgdmFyIHRhZyAgPSBtZXRhWzBdLFxuICAgICAgYXR0ciA9IG1ldGFbMV0sXG4gICAgICBuZXN0ID0gbWV0YVsyXSB8fCBmYWxzZSxcbiAgICAgIGRhdGEgPSBuZXN0ID8gW3NjZW5lLml0ZW1zXSA6IHNjZW5lLml0ZW1zLFxuICAgICAgZGVmcyA9IHRoaXMuX2RlZnMsXG4gICAgICBzdmcgPSBcIlwiLCBpLCBzdHk7XG5cbiAgdmFyIGNscyA9IGNzc0NsYXNzKHNjZW5lLmRlZik7XG5cbiAgLy8gc3R5bGUgbGl0ZXJhbHMgdG8gZXhhY3RseSBtYXRjaCB0aGUgZDMgZG9tXG4gIHZhciBzdHlsID0gbnVsbDtcbiAgaWYgKGNscyA9PT0gJ3R5cGUtcnVsZScgfHwgY2xzID09PSAndHlwZS1wYXRoJylcbiAgICBzdHlsID0gJ3N0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCInO1xuICBlbHNlIGlmIChjbHMgIT09ICd0eXBlLWdyb3VwJylcbiAgICBzdHlsID0gJ3N0eWxlPVwiXCInO1xuXG4gIHN2ZyArPSBvcGVuKCdnJywge1xuICAgICdpZCc6ICdnJyArICsrdGhpcy5fZ2lkLCAvLyBkMyBkb20gY29tcGF0XG4gICAgJ2NsYXNzJzogY3NzQ2xhc3Moc2NlbmUuZGVmKVxuICB9LCBzdHlsKTtcblxuICBmb3IgKGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0eSA9IHRhZyA9PT0gJ2cnID8gbnVsbCA6IHN0eWxlKGRhdGFbaV0sIHRhZywgZGVmcyk7XG4gICAgc3ZnICs9IG9wZW4odGFnLCBhdHRyKGRhdGFbaV0sIGRlZnMpLCBzdHkpO1xuICAgIGlmICh0YWcgPT09ICd0ZXh0Jykgc3ZnICs9IGVzY2FwZV90ZXh0KGRhdGFbaV0udGV4dCk7XG4gICAgaWYgKHRhZyA9PT0gJ2cnKSBzdmcgKz0gdGhpcy5kcmF3R3JvdXAoZGF0YVtpXSk7XG4gICAgc3ZnICs9IGNsb3NlKHRhZyk7XG4gIH1cblxuICByZXR1cm4gc3ZnICsgY2xvc2UoJ2cnKTtcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZV90ZXh0KHMpIHtcbiAgcyA9IChzID09IG51bGwgPyBcIlwiIDogU3RyaW5nKHMpKTtcbiAgcmV0dXJuIHMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVfZm9udChzKSB7XG4gIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvXFxcIi9nLCBcIidcIik7XG59XG5cbnZhciBNQVJLUyA9IHtcbiAgZ3JvdXA6ICBbJ2cnLCBncm91cF0sXG4gIGFyZWE6ICAgWydwYXRoJywgYXJlYSwgdHJ1ZV0sXG4gIGxpbmU6ICAgWydwYXRoJywgbGluZSwgdHJ1ZV0sXG4gIGFyYzogICAgWydwYXRoJywgYXJjXSxcbiAgcGF0aDogICBbJ3BhdGgnLCBwYXRoXSxcbiAgc3ltYm9sOiBbJ3BhdGgnLCBzeW1ib2xdLFxuICByZWN0OiAgIFsncmVjdCcsIHJlY3RdLFxuICBydWxlOiAgIFsnbGluZScsIHJ1bGVdLFxuICB0ZXh0OiAgIFsndGV4dCcsIHRleHRdLFxuICBpbWFnZTogIFsnaW1hZ2UnLCBpbWFnZV1cbn07XG5cbnByb3RvdHlwZS5kcmF3R3JvdXAgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgc3ZnID0gXCJcIixcbiAgICAgIGF4ZXMgPSBzY2VuZS5heGlzSXRlbXMgfHwgW10sXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbGVnZW5kcyA9IHNjZW5lLmxlZ2VuZEl0ZW1zIHx8IFtdLFxuICAgICAgaSwgaiwgbTtcblxuICBzdmcgKz0gZ3JvdXBfYmcoc2NlbmUpO1xuXG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmRlZi5sYXllciA9PT0gXCJiYWNrXCIpIHtcbiAgICAgIHN2ZyArPSB0aGlzLmRyYXcoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdmcgKz0gdGhpcy5kcmF3KGl0ZW1zW2pdKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgIT09IFwiYmFja1wiKSB7XG4gICAgICBzdmcgKz0gdGhpcy5kcmF3KGF4ZXNbal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdmcgKz0gdGhpcy5kcmF3KGxlZ2VuZHNbal0pO1xuICB9XG5cbiAgcmV0dXJuIHN2Zztcbn07XG5cbi8vL1xuXG5mdW5jdGlvbiBncm91cF9iZyhvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG5cbiAgdmFyIHN0eWwgPSBvLm1hcmsuaW50ZXJhY3RpdmUgPT09IGZhbHNlID9cbiAgICAnc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIicgOiBcbiAgICAnc3R5bGU9XCJcIic7XG5cbiAgcmV0dXJuIG9wZW4oJ3JlY3QnLCB7XG4gICAgJ2NsYXNzJzogJ2JhY2tncm91bmQnXG4gIH0sIHN0eWwpICsgY2xvc2UoJ3JlY3QnKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAobywgZGVmcykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgYXR0ciA9IHt0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIn07XG5cbiAgaWYgKG8uY2xpcCkge1xuICAgIHZhciBjID0ge3dpZHRoOiBvLndpZHRoIHx8IDAsIGhlaWdodDogby5oZWlnaHQgfHwgMH0sXG4gICAgICAgIGlkID0gby5jbGlwX2lkIHx8IChvLmNsaXBfaWQgPSBcImNsaXBcIiArIGNsaXBfaWQrKyk7XG4gICAgZGVmcy5jbGlwcGluZ1tpZF0gPSBjO1xuICAgIGF0dHJbXCJjbGlwLXBhdGhcIl0gPSBcInVybCgjXCIraWQrXCIpXCI7XG4gIH1cblxuICByZXR1cm4gYXR0cjtcbn1cblxuZnVuY3Rpb24gYXJjKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIixcbiAgICBkOiBhcmNfcGF0aChvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBhcmVhKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBwYXRoID0gby5vcmllbnQgPT09IFwiaG9yaXpvbnRhbFwiID8gYXJlYV9wYXRoX2ggOiBhcmVhX3BhdGhfdjtcbiAgcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICByZXR1cm4ge2Q6IHBhdGgoaXRlbXMpfTtcbn1cblxuZnVuY3Rpb24gbGluZShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICBsaW5lX3BhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgcmV0dXJuIHtkOiBsaW5lX3BhdGgoaXRlbXMpfTtcbn1cblxuZnVuY3Rpb24gcGF0aChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIsXG4gICAgZDogby5wYXRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY3Qobykge1xuICByZXR1cm4ge1xuICAgIHg6IG8ueCB8fCAwLFxuICAgIHk6IG8ueSB8fCAwLFxuICAgIHdpZHRoOiBvLndpZHRoIHx8IDAsXG4gICAgaGVpZ2h0OiBvLmhlaWdodCB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJ1bGUobykge1xuICB2YXIgeDEgPSBvLnggfHwgMCxcbiAgICAgIHkxID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4Mjogby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgIHkyOiBvLnkyICE9IG51bGwgPyBvLnkyIDogeTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIixcbiAgICBkOiBzeW1ib2xfcGF0aChvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbWFnZShvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IChvLmltYWdlICYmIG8uaW1hZ2UuaGVpZ2h0KSB8fCAwLFxuICAgICAgeCA9IG8ueCAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSksXG4gICAgICB5ID0gby55IC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSksXG4gICAgICB1cmwgPSBjb25maWcuYmFzZVVSTCArIG8udXJsO1xuICBcbiAgcmV0dXJuIHtcbiAgICBcInhsaW5rOmhyZWZcIjogdXJsLFxuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBkeCA9IG8uZHggfHwgMCxcbiAgICAgIGR5ID0gby5keSB8fCAwLFxuICAgICAgYSA9IG8uYW5nbGUgfHwgMCxcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgYWxpZ24gPSB0ZXh0QWxpZ25bby5hbGlnbiB8fCBcImxlZnRcIl0sXG4gICAgICBiYXNlID0gby5iYXNlbGluZT09PVwidG9wXCIgPyBcIi45ZW1cIlxuICAgICAgICAgICA6IG8uYmFzZWxpbmU9PT1cIm1pZGRsZVwiID8gXCIuMzVlbVwiIDogMDtcblxuICBpZiAocikge1xuICAgIHZhciB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHggKyBkeCxcbiAgICB5OiB5ICsgZHksXG4gICAgJ3RleHQtYW5jaG9yJzogYWxpZ24sXG4gICAgdHJhbnNmb3JtOiBhID8gXCJyb3RhdGUoXCIrYStcIiBcIit4K1wiLFwiK3krXCIpXCIgOiBudWxsLFxuICAgIGR5OiBiYXNlID8gYmFzZSA6IG51bGxcbiAgfTtcbn1cblxuLy8vXG5cbmZ1bmN0aW9uIGNzc0NsYXNzKGRlZikge1xuICB2YXIgY2xzID0gXCJ0eXBlLVwiICsgZGVmLnR5cGU7XG4gIGlmIChkZWYubmFtZSkgY2xzICs9IFwiIFwiICsgZGVmLm5hbWU7XG4gIHJldHVybiBjbHM7XG59XG5cbmZ1bmN0aW9uIHgobykgICAgIHsgcmV0dXJuIG8ueCB8fCAwOyB9XG5mdW5jdGlvbiB5KG8pICAgICB7IHJldHVybiBvLnkgfHwgMDsgfVxuZnVuY3Rpb24geHcobykgICAgeyByZXR1cm4gby54ICsgby53aWR0aCB8fCAwOyB9XG5mdW5jdGlvbiB5aChvKSAgICB7IHJldHVybiBvLnkgKyBvLmhlaWdodCB8fCAwOyB9XG5mdW5jdGlvbiBrZXkobykgICB7IHJldHVybiBvLmtleTsgfVxuZnVuY3Rpb24gc2l6ZShvKSAgeyByZXR1cm4gby5zaXplPT1udWxsID8gMTAwIDogby5zaXplOyB9XG5mdW5jdGlvbiBzaGFwZShvKSB7IHJldHVybiBvLnNoYXBlIHx8IFwiY2lyY2xlXCI7IH1cblxudmFyIGFyY19wYXRoICAgID0gZDMuc3ZnLmFyYygpLFxuICAgIGFyZWFfcGF0aF92ID0gZDMuc3ZnLmFyZWEoKS54KHgpLnkxKHkpLnkwKHloKSxcbiAgICBhcmVhX3BhdGhfaCA9IGQzLnN2Zy5hcmVhKCkueSh5KS54MCh4dykueDEoeCksXG4gICAgbGluZV9wYXRoICAgPSBkMy5zdmcubGluZSgpLngoeCkueSh5KSxcbiAgICBzeW1ib2xfcGF0aCA9IGQzLnN2Zy5zeW1ib2woKS50eXBlKHNoYXBlKS5zaXplKHNpemUpO1xuXG52YXIgbWFya19pZCA9IDAsXG4gICAgY2xpcF9pZCA9IDA7XG5cbnZhciB0ZXh0QWxpZ24gPSB7XG4gIFwibGVmdFwiOiAgIFwic3RhcnRcIixcbiAgXCJjZW50ZXJcIjogXCJtaWRkbGVcIixcbiAgXCJyaWdodFwiOiAgXCJlbmRcIlxufTtcblxudmFyIHN0eWxlcyA9IHtcbiAgXCJmaWxsXCI6ICAgICAgICAgICAgIFwiZmlsbFwiLFxuICBcImZpbGxPcGFjaXR5XCI6ICAgICAgXCJmaWxsLW9wYWNpdHlcIixcbiAgXCJzdHJva2VcIjogICAgICAgICAgIFwic3Ryb2tlXCIsXG4gIFwic3Ryb2tlV2lkdGhcIjogICAgICBcInN0cm9rZS13aWR0aFwiLFxuICBcInN0cm9rZU9wYWNpdHlcIjogICAgXCJzdHJva2Utb3BhY2l0eVwiLFxuICBcInN0cm9rZUNhcFwiOiAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZURhc2hcIjogICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCIsXG4gIFwic3Ryb2tlRGFzaE9mZnNldFwiOiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gIFwib3BhY2l0eVwiOiAgICAgICAgICBcIm9wYWNpdHlcIlxufTtcblxudmFyIHN0eWxlUHJvcHMgPSBkbC5rZXlzKHN0eWxlcyk7XG5cbmZ1bmN0aW9uIHN0eWxlKGQsIHRhZywgZGVmcykge1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWUsXG4gICAgICBvID0gZC5tYXJrID8gZCA6IGQubGVuZ3RoID8gZFswXSA6IG51bGw7XG4gIGlmIChvID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcyA9IFwiXCI7XG5cbiAgaWYgKHRhZyA9PT0gJ3RleHQnKSB7XG4gICAgcyArPSAnZm9udDogJyArIGZvbnRTdHJpbmcobykgKyAnOyc7XG4gIH1cbiAgXG4gIGZvciAoaT0wLCBuPXN0eWxlUHJvcHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHByb3AgPSBzdHlsZVByb3BzW2ldO1xuICAgIG5hbWUgPSBzdHlsZXNbcHJvcF07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSBcImZpbGxcIikgcyArPSAnZmlsbDogbm9uZTsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBcInVybChcIiArIHdpbmRvdy5sb2NhdGlvbi5ocmVmICsgXCIjXCIgKyB2YWx1ZS5pZCArIFwiKVwiO1xuICAgICAgfVxuICAgICAgcyArPSAocy5sZW5ndGggPyAnICcgOiAnJykgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJzsnXG4gICAgfVxuICB9XG4gIFxuICAvLyBub3QgdGhhdCB3ZSBkb24ndCBleGNsdWRlIGJsYW5rIHN0eWxlcyBmb3IgZDMgZG9tIGNvbXBhdFxuICByZXR1cm4gJ3N0eWxlPVwiJytzKydcIic7XG59XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICB2YXIgZiA9IChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250ICYmIGVzY2FwZV9mb250KG8uZm9udCkgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbiAgcmV0dXJuIGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbnZhciBoYW5kbGVyID0gZnVuY3Rpb24oZWwsIG1vZGVsKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGlmIChlbCkgdGhpcy5pbml0aWFsaXplKGVsKTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsKG1vZGVsKTtcbn07XG5cbmZ1bmN0aW9uIHN2Z0hhbmRsZXIoaGFuZGxlcikge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldCxcbiAgICAgICAgaXRlbSA9IHRhcmdldC5fX2RhdGFfXztcblxuICAgIGlmIChpdGVtKSBpdGVtID0gaXRlbS5tYXJrID8gaXRlbSA6IGl0ZW1bMF07XG4gICAgaGFuZGxlci5jYWxsKHRoYXQuX29iaiwgZXZ0LCBpdGVtKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZlbnROYW1lKG5hbWUpIHtcbiAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCIuXCIpO1xuICByZXR1cm4gaSA8IDAgPyBuYW1lIDogbmFtZS5zbGljZSgwLGkpO1xufVxuXG52YXIgcHJvdG90eXBlID0gaGFuZGxlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHBhZCwgb2JqKSB7XG4gIHRoaXMuX2VsID0gZDMuc2VsZWN0KGVsKS5ub2RlKCk7XG4gIHRoaXMuX3N2ZyA9IGQzLnNlbGVjdChlbCkuc2VsZWN0KFwic3ZnLm1hcmtzXCIpLm5vZGUoKTtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgdGhpcy5fb2JqID0gb2JqIHx8IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnBhZGRpbmcgPSBmdW5jdGlvbihwYWQpIHtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihtb2RlbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGggPSB0aGlzLl9oYW5kbGVycztcbiAgcmV0dXJuIGRsLmtleXMoaCkucmVkdWNlKGZ1bmN0aW9uKGEsIGspIHtcbiAgICByZXR1cm4gaFtrXS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkgeyByZXR1cm4gKGEucHVzaCh4KSwgYSk7IH0sIGEpO1xuICB9LCBbXSk7XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgIGRvbSA9IGQzLnNlbGVjdCh0aGlzLl9zdmcpLm5vZGUoKTtcbiAgICAgIFxuICB2YXIgeCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgc3ZnOiBzdmdIYW5kbGVyLmNhbGwodGhpcywgaGFuZGxlcilcbiAgfTtcbiAgaCA9IGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSk7XG4gIGgucHVzaCh4KTtcblxuICBkb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCB4LnN2Zyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLFxuICAgICAgZG9tID0gZDMuc2VsZWN0KHRoaXMuX3N2Zykubm9kZSgpO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yICh2YXIgaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmIChoW2ldLnR5cGUgIT09IHR5cGUpIGNvbnRpbnVlO1xuICAgIGlmICghaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhbaV0uc3ZnKTtcbiAgICAgIGguc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlcjsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N2ZyA9IG51bGw7XG4gIHRoaXMuX2N0eCA9IG51bGw7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fZWwgPSBlbDtcblxuICAvLyByZW1vdmUgYW55IGV4aXN0aW5nIHN2ZyBlbGVtZW50XG4gIGQzLnNlbGVjdChlbCkuc2VsZWN0KFwic3ZnLm1hcmtzXCIpLnJlbW92ZSgpO1xuXG4gIC8vIGNyZWF0ZSBzdmcgZWxlbWVudCBhbmQgaW5pdGlhbGl6ZSBhdHRyaWJ1dGVzXG4gIHRoaXMuX3N2ZyA9IGQzLnNlbGVjdChlbClcbiAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtzXCIpO1xuICBcbiAgLy8gc2V0IHRoZSBzdmcgcm9vdCBncm91cFxuICB0aGlzLl9jdHggPSB0aGlzLl9zdmcuYXBwZW5kKFwiZ1wiKTtcbiAgXG4gIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwYWQpO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIFxuICB0aGlzLl9zdmdcbiAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgcGFkLmxlZnQgKyBwYWQucmlnaHQpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20pO1xuICAgIFxuICB0aGlzLl9jdHhcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIitwYWQubGVmdCtcIixcIitwYWQudG9wK1wiKVwiKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jdHg7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUudXBkYXRlRGVmcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgYWxsID0gdGhpcy5fZGVmcyxcbiAgICAgIGRncmFkID0gZGwua2V5cyhhbGwuZ3JhZGllbnQpLFxuICAgICAgZGNsaXAgPSBkbC5rZXlzKGFsbC5jbGlwcGluZyksXG4gICAgICBkZWZzID0gc3ZnLnNlbGVjdChcImRlZnNcIiksIGdyYWQsIGNsaXA7XG5cbiAgLy8gZ2V0IG9yIGNyZWF0ZSBzdmcgZGVmcyBibG9ja1xuICBpZiAoZGdyYWQubGVuZ3RoPT09MCAmJiBkY2xpcC5sZW5ndGg9PTApIHsgZGVmcy5yZW1vdmUoKTsgcmV0dXJuOyB9XG4gIGlmIChkZWZzLmVtcHR5KCkpIGRlZnMgPSBzdmcuaW5zZXJ0KFwiZGVmc1wiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgXG4gIGdyYWQgPSBkZWZzLnNlbGVjdEFsbChcImxpbmVhckdyYWRpZW50XCIpLmRhdGEoZGdyYWQsIGRsLmlkZW50aXR5KTtcbiAgZ3JhZC5lbnRlcigpLmFwcGVuZChcImxpbmVhckdyYWRpZW50XCIpLmF0dHIoXCJpZFwiLCBkbC5pZGVudGl0eSk7XG4gIGdyYWQuZXhpdCgpLnJlbW92ZSgpO1xuICBncmFkLmVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZGVmID0gYWxsLmdyYWRpZW50W2lkXSxcbiAgICAgICAgZ3JkID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgLy8gc2V0IGdyYWRpZW50IGNvb3JkaW5hdGVzXG4gICAgZ3JkLmF0dHIoe3gxOiBkZWYueDEsIHgyOiBkZWYueDIsIHkxOiBkZWYueTEsIHkyOiBkZWYueTJ9KTtcblxuICAgIC8vIHNldCBncmFkaWVudCBzdG9wc1xuICAgIHN0b3AgPSBncmQuc2VsZWN0QWxsKFwic3RvcFwiKS5kYXRhKGRlZi5zdG9wcyk7XG4gICAgc3RvcC5lbnRlcigpLmFwcGVuZChcInN0b3BcIik7XG4gICAgc3RvcC5leGl0KCkucmVtb3ZlKCk7XG4gICAgc3RvcC5hdHRyKFwib2Zmc2V0XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQub2Zmc2V0OyB9KVxuICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jb2xvcjsgfSk7XG4gIH0pO1xuICBcbiAgY2xpcCA9IGRlZnMuc2VsZWN0QWxsKFwiY2xpcFBhdGhcIikuZGF0YShkY2xpcCwgZGwuaWRlbnRpdHkpO1xuICBjbGlwLmVudGVyKCkuYXBwZW5kKFwiY2xpcFBhdGhcIikuYXR0cihcImlkXCIsIGRsLmlkZW50aXR5KTtcbiAgY2xpcC5leGl0KCkucmVtb3ZlKCk7XG4gIGNsaXAuZWFjaChmdW5jdGlvbihpZCkge1xuICAgIHZhciBkZWYgPSBhbGwuY2xpcHBpbmdbaWRdLFxuICAgICAgICBjciA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJyZWN0XCIpLmRhdGEoWzFdKTtcbiAgICBjci5lbnRlcigpLmFwcGVuZChcInJlY3RcIik7XG4gICAgY3IuYXR0cihcInhcIiwgMClcbiAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBkZWYud2lkdGgpXG4gICAgICAuYXR0cihcImhlaWdodFwiLCBkZWYuaGVpZ2h0KTtcbiAgfSk7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIG1hcmtzLmN1cnJlbnQgPSB0aGlzO1xuXG4gIGlmIChpdGVtcykge1xuICAgIHRoaXMucmVuZGVySXRlbXMoZGwuYXJyYXkoaXRlbXMpKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRyYXcodGhpcy5fY3R4LCBzY2VuZSwgLTEpO1xuICB9XG4gIHRoaXMudXBkYXRlRGVmcygpO1xuXG4gZGVsZXRlIG1hcmtzLmN1cnJlbnQ7XG59O1xuXG5wcm90b3R5cGUucmVuZGVySXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuICB2YXIgaXRlbSwgbm9kZSwgdHlwZSwgbmVzdCwgaSwgbjtcblxuICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIG5vZGUgPSBpdGVtLl9zdmc7XG4gICAgdHlwZSA9IGl0ZW0ubWFyay5tYXJrdHlwZTtcblxuICAgIGl0ZW0gPSBtYXJrcy5uZXN0ZWRbdHlwZV0gPyBpdGVtLm1hcmsuaXRlbXMgOiBpdGVtO1xuICAgIG1hcmtzLnVwZGF0ZVt0eXBlXS5jYWxsKG5vZGUsIGl0ZW0pO1xuICAgIG1hcmtzLnN0eWxlLmNhbGwobm9kZSwgaXRlbSk7XG4gIH1cbn1cblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHNjZW5lLCBpbmRleCkge1xuICB2YXIgbWFya3R5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIHJlbmRlcmVyID0gbWFya3MuZHJhd1ttYXJrdHlwZV07XG4gIHJlbmRlcmVyLmNhbGwodGhpcywgY3R4LCBzY2VuZSwgaW5kZXgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJlcjtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyk7XG5cbmZ1bmN0aW9uIHgobykgICAgIHsgcmV0dXJuIG8ueCB8fCAwOyB9XG5mdW5jdGlvbiB5KG8pICAgICB7IHJldHVybiBvLnkgfHwgMDsgfVxuZnVuY3Rpb24geWgobykgICAgeyByZXR1cm4gby55ICsgby5oZWlnaHQgfHwgMDsgfVxuZnVuY3Rpb24ga2V5KG8pICAgeyByZXR1cm4gby5rZXk7IH1cbmZ1bmN0aW9uIHNpemUobykgIHsgcmV0dXJuIG8uc2l6ZT09bnVsbCA/IDEwMCA6IG8uc2l6ZTsgfVxuZnVuY3Rpb24gc2hhcGUobykgeyByZXR1cm4gby5zaGFwZSB8fCBcImNpcmNsZVwiOyB9XG4gICAgXG52YXIgYXJjX3BhdGggICAgPSBkMy5zdmcuYXJjKCksXG4gICAgYXJlYV9wYXRoICAgPSBkMy5zdmcuYXJlYSgpLngoeCkueTEoeSkueTAoeWgpLFxuICAgIGxpbmVfcGF0aCAgID0gZDMuc3ZnLmxpbmUoKS54KHgpLnkoeSksXG4gICAgc3ltYm9sX3BhdGggPSBkMy5zdmcuc3ltYm9sKCkudHlwZShzaGFwZSkuc2l6ZShzaXplKTtcblxudmFyIG1hcmtfaWQgPSAwLFxuICAgIGNsaXBfaWQgPSAwO1xuXG52YXIgdGV4dEFsaWduID0ge1xuICBcImxlZnRcIjogICBcInN0YXJ0XCIsXG4gIFwiY2VudGVyXCI6IFwibWlkZGxlXCIsXG4gIFwicmlnaHRcIjogIFwiZW5kXCJcbn07XG5cbnZhciBzdHlsZXMgPSB7XG4gIFwiZmlsbFwiOiAgICAgICAgICAgICBcImZpbGxcIixcbiAgXCJmaWxsT3BhY2l0eVwiOiAgICAgIFwiZmlsbC1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlXCI6ICAgICAgICAgICBcInN0cm9rZVwiLFxuICBcInN0cm9rZVdpZHRoXCI6ICAgICAgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJzdHJva2VPcGFjaXR5XCI6ICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgXCJzdHJva2VDYXBcIjogICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIixcbiAgXCJzdHJva2VEYXNoXCI6ICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiLFxuICBcInN0cm9rZURhc2hPZmZzZXRcIjogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICBcIm9wYWNpdHlcIjogICAgICAgICAgXCJvcGFjaXR5XCJcbn07XG52YXIgc3R5bGVQcm9wcyA9IGRsLmtleXMoc3R5bGVzKTtcblxuZnVuY3Rpb24gc3R5bGUoZCkge1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWUsXG4gICAgICBvID0gZC5tYXJrID8gZCA6IGQubGVuZ3RoID8gZFswXSA6IG51bGw7XG4gIGlmIChvID09PSBudWxsKSByZXR1cm47XG5cbiAgZm9yIChpPTAsIG49c3R5bGVQcm9wcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IHN0eWxlUHJvcHNbaV07XG4gICAgbmFtZSA9IHN0eWxlc1twcm9wXTtcbiAgICB2YWx1ZSA9IG9bcHJvcF07XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5hbWUgPT09IFwiZmlsbFwiKSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIFwibm9uZVwiLCBudWxsKTtcbiAgICAgIGVsc2UgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgIC8vIGVuc3VyZSBkZWZpbml0aW9uIGlzIGluY2x1ZGVkXG4gICAgICAgIG1hcmtzLmN1cnJlbnQuX2RlZnMuZ3JhZGllbnRbdmFsdWUuaWRdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gXCJ1cmwoI1wiICsgdmFsdWUuaWQgKyBcIilcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUrXCJcIiwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFyYyhvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBhcmNfcGF0aChvKSk7XG59XG5cbmZ1bmN0aW9uIGFyZWEoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgYXJlYV9wYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBhcmVhX3BhdGgoaXRlbXMpKTtcbn1cblxuZnVuY3Rpb24gbGluZShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICBsaW5lX3BhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIGxpbmVfcGF0aChpdGVtcykpO1xufVxuXG5mdW5jdGlvbiBwYXRoKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcbiAgaWYgKG8ucGF0aCAhPSBudWxsKSB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgby5wYXRoKTtcbn1cblxuZnVuY3Rpb24gcmVjdChvKSB7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCBvLnggfHwgMCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCBvLnkgfHwgMCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgby53aWR0aCB8fCAwKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgby5oZWlnaHQgfHwgMCk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobykge1xuICB2YXIgeDEgPSBvLnggfHwgMCxcbiAgICAgIHkxID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieDFcIiwgeDEpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInkxXCIsIHkxKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBvLngyICE9IG51bGwgPyBvLngyIDogeDEpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInkyXCIsIG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MSk7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBzeW1ib2xfcGF0aChvKSk7XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDAsXG4gICAgICB4ID0gby54IC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKSxcbiAgICAgIHkgPSBvLnkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKSxcbiAgICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgby51cmw7XG4gIFxuICB0aGlzLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcImhyZWZcIiwgdXJsKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGgpO1xufVxuICBcbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICByZXR1cm4gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbn1cblxuZnVuY3Rpb24gdGV4dChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBkeCA9IG8uZHggfHwgMCxcbiAgICAgIGR5ID0gby5keSB8fCAwLFxuICAgICAgYSA9IG8uYW5nbGUgfHwgMCxcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgYWxpZ24gPSB0ZXh0QWxpZ25bby5hbGlnbiB8fCBcImxlZnRcIl0sXG4gICAgICBiYXNlID0gby5iYXNlbGluZT09PVwidG9wXCIgPyBcIi45ZW1cIlxuICAgICAgICAgICA6IG8uYmFzZWxpbmU9PT1cIm1pZGRsZVwiID8gXCIuMzVlbVwiIDogMDtcblxuICBpZiAocikge1xuICAgIHZhciB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICB0aGlzLnNldEF0dHJpYnV0ZShcInhcIiwgeCArIGR4KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkgKyBkeSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgYWxpZ24pO1xuICBcbiAgaWYgKGEpIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKFwiK2ErXCIgXCIreCtcIixcIit5K1wiKVwiKTtcbiAgZWxzZSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgXG4gIGlmIChiYXNlKSB0aGlzLnNldEF0dHJpYnV0ZShcImR5XCIsIGJhc2UpO1xuICBlbHNlIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwiZHlcIik7XG4gIFxuICB0aGlzLnRleHRDb250ZW50ID0gby50ZXh0O1xuICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KFwiZm9udFwiLCBmb250U3RyaW5nKG8pLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuXG4gIGlmIChvLmNsaXApIHtcbiAgICB2YXIgYyA9IHt3aWR0aDogby53aWR0aCB8fCAwLCBoZWlnaHQ6IG8uaGVpZ2h0IHx8IDB9LFxuICAgICAgICBpZCA9IG8uY2xpcF9pZCB8fCAoby5jbGlwX2lkID0gXCJjbGlwXCIgKyBjbGlwX2lkKyspO1xuICAgIG1hcmtzLmN1cnJlbnQuX2RlZnMuY2xpcHBpbmdbaWRdID0gYztcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImNsaXAtcGF0aFwiLCBcInVybCgjXCIraWQrXCIpXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdyb3VwX2JnKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzc0NsYXNzKGRlZikge1xuICB2YXIgY2xzID0gXCJ0eXBlLVwiICsgZGVmLnR5cGU7XG4gIGlmIChkZWYubmFtZSkgY2xzICs9IFwiIFwiICsgZGVmLm5hbWU7XG4gIHJldHVybiBjbHM7XG59XG5cbmZ1bmN0aW9uIGRyYXcodGFnLCBhdHRyLCBuZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgaW5kZXgpIHtcbiAgICBkcmF3TWFyayhnLCBzY2VuZSwgaW5kZXgsIFwibWFya19cIiwgdGFnLCBhdHRyLCBuZXN0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHJhd01hcmsoZywgc2NlbmUsIGluZGV4LCBwcmVmaXgsIHRhZywgYXR0ciwgbmVzdCkge1xuICB2YXIgZGF0YSA9IG5lc3QgPyBbc2NlbmUuaXRlbXNdIDogc2NlbmUuaXRlbXMsXG4gICAgICBldnRzID0gc2NlbmUuaW50ZXJhY3RpdmU9PT1mYWxzZSA/IFwibm9uZVwiIDogbnVsbCxcbiAgICAgIGdycHMgPSBnLm5vZGUoKS5jaGlsZE5vZGVzLFxuICAgICAgbm90RyA9ICh0YWcgIT09IFwiZ1wiKSxcbiAgICAgIHAgPSAocCA9IGdycHNbaW5kZXgrMV0pIC8vICsxIHRvIHNraXAgZ3JvdXAgYmFja2dyb3VuZCByZWN0XG4gICAgICAgID8gZDMuc2VsZWN0KHApXG4gICAgICAgIDogZy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJnXCIrKCsrbWFya19pZCkpXG4gICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgY3NzQ2xhc3Moc2NlbmUuZGVmKSk7XG5cbiAgdmFyIGlkID0gcC5hdHRyKFwiaWRcIiksXG4gICAgICBzID0gXCIjXCIgKyBpZCArIFwiID4gXCIgKyB0YWcsXG4gICAgICBtID0gcC5zZWxlY3RBbGwocykuZGF0YShkYXRhKSxcbiAgICAgIGUgPSBtLmVudGVyKCkuYXBwZW5kKHRhZyk7XG5cbiAgaWYgKG5vdEcpIHtcbiAgICBwLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgZXZ0cyk7XG4gICAgZS5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChkLm1hcmspIGQuX3N2ZyA9IHRoaXM7XG4gICAgICBlbHNlIGlmIChkLmxlbmd0aCkgZFswXS5fc3ZnID0gdGhpcztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBlLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsXCJiYWNrZ3JvdW5kXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixldnRzKTtcbiAgfVxuICBcbiAgbS5leGl0KCkucmVtb3ZlKCk7XG4gIG0uZWFjaChhdHRyKTtcbiAgaWYgKG5vdEcpIG0uZWFjaChzdHlsZSk7XG4gIGVsc2UgcC5zZWxlY3RBbGwocytcIiA+IHJlY3QuYmFja2dyb3VuZFwiKS5lYWNoKGdyb3VwX2JnKS5lYWNoKHN0eWxlKTtcbiAgXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBkcmF3R3JvdXAoZywgc2NlbmUsIGluZGV4LCBwcmVmaXgpIHsgICAgXG4gIHZhciBwID0gZHJhd01hcmsoZywgc2NlbmUsIGluZGV4LCBwcmVmaXggfHwgXCJncm91cF9cIiwgXCJnXCIsIGdyb3VwKSxcbiAgICAgIGMgPSBwLm5vZGUoKS5jaGlsZE5vZGVzLCBuID0gYy5sZW5ndGgsIGksIGosIG07XG4gIFxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgaXRlbXMgPSBjW2ldLl9fZGF0YV9fLml0ZW1zLFxuICAgICAgICBsZWdlbmRzID0gY1tpXS5fX2RhdGFfXy5sZWdlbmRJdGVtcyB8fCBbXSxcbiAgICAgICAgYXhlcyA9IGNbaV0uX19kYXRhX18uYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgICBzZWwgPSBkMy5zZWxlY3QoY1tpXSksXG4gICAgICAgIGlkeCA9IDA7XG5cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgZHJhd0dyb3VwLmNhbGwodGhpcywgc2VsLCBheGVzW2pdLCBpZHgrKywgXCJheGlzX1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5kcmF3KHNlbCwgaXRlbXNbal0sIGlkeCsrKTtcbiAgICB9XG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgIT09IFwiYmFja1wiKSB7XG4gICAgICAgIGRyYXdHcm91cC5jYWxsKHRoaXMsIHNlbCwgYXhlc1tqXSwgaWR4KyssIFwiYXhpc19cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgZHJhd0dyb3VwLmNhbGwodGhpcywgc2VsLCBsZWdlbmRzW2pdLCBpZHgrKywgXCJsZWdlbmRfXCIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXBkYXRlOiB7XG4gICAgZ3JvdXA6ICAgcmVjdCxcbiAgICBhcmVhOiAgICBhcmVhLFxuICAgIGxpbmU6ICAgIGxpbmUsXG4gICAgYXJjOiAgICAgYXJjLFxuICAgIHBhdGg6ICAgIHBhdGgsXG4gICAgc3ltYm9sOiAgc3ltYm9sLFxuICAgIHJlY3Q6ICAgIHJlY3QsXG4gICAgcnVsZTogICAgcnVsZSxcbiAgICB0ZXh0OiAgICB0ZXh0LFxuICAgIGltYWdlOiAgIGltYWdlXG4gIH0sXG4gIG5lc3RlZDoge1xuICAgIFwiYXJlYVwiOiB0cnVlLFxuICAgIFwibGluZVwiOiB0cnVlXG4gIH0sXG4gIHN0eWxlOiBzdHlsZSxcbiAgZHJhdzoge1xuICAgIGdyb3VwOiAgIGRyYXdHcm91cCxcbiAgICBhcmVhOiAgICBkcmF3KFwicGF0aFwiLCBhcmVhLCB0cnVlKSxcbiAgICBsaW5lOiAgICBkcmF3KFwicGF0aFwiLCBsaW5lLCB0cnVlKSxcbiAgICBhcmM6ICAgICBkcmF3KFwicGF0aFwiLCBhcmMpLFxuICAgIHBhdGg6ICAgIGRyYXcoXCJwYXRoXCIsIHBhdGgpLFxuICAgIHN5bWJvbDogIGRyYXcoXCJwYXRoXCIsIHN5bWJvbCksXG4gICAgcmVjdDogICAgZHJhdyhcInJlY3RcIiwgcmVjdCksXG4gICAgcnVsZTogICAgZHJhdyhcImxpbmVcIiwgcnVsZSksXG4gICAgdGV4dDogICAgZHJhdyhcInRleHRcIiwgdGV4dCksXG4gICAgaW1hZ2U6ICAgZHJhdyhcImltYWdlXCIsIGltYWdlKSxcbiAgICBkcmF3OiAgICBkcmF3IC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICB9LFxuICBjdXJyZW50OiBudWxsXG59OyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbmZ1bmN0aW9uIEJvdW5kZXIoZ3JhcGgsIG1hcmspIHtcbiAgdGhpcy5fbWFyayA9IG1hcms7XG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKEJvdW5kZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImJvdW5kc1wiLCB0aGlzLl9tYXJrLm1hcmt0eXBlXSk7XG5cbiAgYm91bmRzLm1hcmsodGhpcy5fbWFyayk7XG4gIGlmICh0aGlzLl9tYXJrLm1hcmt0eXBlID09PSBDLkdST1VQKSBcbiAgICBib3VuZHMubWFyayh0aGlzLl9tYXJrLCBudWxsLCBmYWxzZSk7XG5cbiAgaW5wdXQucmVmbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEVuY29kZXIgID0gcmVxdWlyZSgnLi9FbmNvZGVyJyksXG4gICAgQm91bmRlciAgPSByZXF1aXJlKCcuL0JvdW5kZXInKSxcbiAgICBJdGVtICA9IHJlcXVpcmUoJy4vSXRlbScpLFxuICAgIHBhcnNlRGF0YSA9IHJlcXVpcmUoJy4uL3BhcnNlL2RhdGEnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7ICAgIFxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbn1cblxudmFyIHByb3RvID0gKEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIHRoaXMuX2RlZiAgID0gZGVmO1xuICB0aGlzLl9tYXJrICA9IG1hcms7XG4gIHRoaXMuX2Zyb20gID0gKGRlZi5mcm9tID8gZGVmLmZyb20uZGF0YSA6IG51bGwpIHx8IGluaGVyaXRGcm9tO1xuICB0aGlzLl9kcyAgICA9IGRsLmlzU3RyaW5nKHRoaXMuX2Zyb20pID8gZ3JhcGguZGF0YSh0aGlzLl9mcm9tKSA6IG51bGw7XG4gIHRoaXMuX21hcCAgID0ge307XG5cbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAgLy8gU2hvdWxkIHNjZW5lZ3JhcGggaXRlbXMgdHJhY2sgX3ByZXY/XG5cbiAgbWFyay5kZWYgPSBkZWY7XG4gIG1hcmsubWFya3R5cGUgPSBkZWYudHlwZTtcbiAgbWFyay5pbnRlcmFjdGl2ZSA9ICEoZGVmLmludGVyYWN0aXZlID09PSBmYWxzZSk7XG4gIG1hcmsuaXRlbXMgPSBbXTtcblxuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX3BhcmVudF9pZCA9IHBhcmVudF9pZDtcblxuICBpZihkZWYuZnJvbSAmJiAoZGVmLmZyb20ubWFyayB8fCBkZWYuZnJvbS50cmFuc2Zvcm0gfHwgZGVmLmZyb20ubW9kaWZ5KSkge1xuICAgIGlubGluZURzLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBOb24tZ3JvdXAgbWFyayBidWlsZGVycyBhcmUgc3VwZXIgbm9kZXMuIEVuY29kZXIgYW5kIEJvdW5kZXIgcmVtYWluIFxuICAvLyBzZXBhcmF0ZSBvcGVyYXRvcnMgYnV0IGFyZSBlbWJlZGRlZCBhbmQgY2FsbGVkIGJ5IEJ1aWxkZXIuZXZhbHVhdGUuXG4gIHRoaXMuX2lzU3VwZXIgPSAodGhpcy5fZGVmLnR5cGUgIT09IEMuR1JPVVApOyBcbiAgdGhpcy5fZW5jb2RlciA9IG5ldyBFbmNvZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcbiAgdGhpcy5fYm91bmRlciA9IG5ldyBCb3VuZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcblxuICBpZih0aGlzLl9kcykgeyB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5EQVRBLCB0aGlzLl9mcm9tKTsgfVxuXG4gIC8vIFNpbmNlIEJ1aWxkZXJzIGFyZSBzdXBlciBub2RlcywgY29weSBvdmVyIGVuY29kZXIgZGVwZW5kZW5jaWVzXG4gIC8vIChib3VuZGVyIGhhcyBubyByZWdpc3RlcmVkIGRlcGVuZGVuY2llcykuXG4gIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLkRBVEEpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0NBTEVTLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5TQ0FMRVMpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0lHTkFMUykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKHApIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuXG4gIC8vIElmIHdlJ3ZlIG5vdCBuZWVkZWQgcHJldiBpbiB0aGUgcGFzdCwgYnV0IGEgbmV3IGlubGluZSBkcyBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIGl0ZW1zIGhhdmUgcHJldiBzZXQuXG4gIGlmKCF0aGlzLl9yZXZpc2VzICYmIHApIHtcbiAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfSk7XG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJlYWN0aXZlIGdlb21ldHJ5IGFuZCBtYXJrLWxldmVsIHRyYW5zZm9ybWF0aW9ucyBhcmUgaGFuZGxlZCBoZXJlIFxuLy8gYmVjYXVzZSB0aGV5IG5lZWQgdGhlaXIgZ3JvdXAncyBkYXRhLWpvaW5lZCBjb250ZXh0LiBcbmZ1bmN0aW9uIGlubGluZURzKCkge1xuICB2YXIgZnJvbSA9IHRoaXMuX2RlZi5mcm9tLFxuICAgICAgZ2VvbSA9IGZyb20ubWFyayxcbiAgICAgIHNyYywgbmFtZSwgc3BlYywgc2libGluZywgb3V0cHV0O1xuXG4gIGlmKGdlb20pIHtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fcGFyZW50X2lkLCBnZW9tXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sIFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3JjID0gdGhpcy5fZ3JhcGguZGF0YSh0aGlzLl9mcm9tKTtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGUsIHNyYy5saXN0ZW5lcnModHJ1ZSkubGVuZ3RoXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHNvdXJjZTogdGhpcy5fZnJvbSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sXG4gICAgICBtb2RpZnk6IGZyb20ubW9kaWZ5XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuX2Zyb20gPSBuYW1lO1xuICB0aGlzLl9kcyA9IHBhcnNlRGF0YS5kYXRhc291cmNlKHRoaXMuX2dyYXBoLCBzcGVjKTtcbiAgdmFyIHJldmlzZXMgPSB0aGlzLl9kcy5yZXZpc2VzKCk7XG5cbiAgaWYoZ2VvbSkge1xuICAgIHNpYmxpbmcgPSB0aGlzLnNpYmxpbmcoZ2VvbSkucmV2aXNlcyhyZXZpc2VzKTtcbiAgICBpZihzaWJsaW5nLl9pc1N1cGVyKSBzaWJsaW5nLmFkZExpc3RlbmVyKHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICAgIGVsc2Ugc2libGluZy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9kcy5saXN0ZW5lcigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGEgbmV3IGRhdGFzb3VyY2UgYnV0IGl0IGlzIGVtcHR5IGFzXG4gICAgLy8gdGhlIHByb3BhZ2F0aW9uIGN5Y2xlIGhhcyBhbHJlYWR5IGNyb3NzZWQgdGhlIGRhdGFzb3VyY2VzLiBcbiAgICAvLyBTbywgd2UgcmVwdWxzZSBqdXN0IHRoaXMgZGF0YXNvdXJjZS4gVGhpcyBzaG91bGQgYmUgc2FmZVxuICAgIC8vIGFzIHRoZSBkcyBpc24ndCBjb25uZWN0ZWQgdG8gdGhlIHNjZW5lZ3JhcGggeWV0LlxuICAgIFxuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9kcy5zb3VyY2UoKS5yZXZpc2VzKHJldmlzZXMpLmxhc3QoKTtcbiAgICAgICAgaW5wdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShvdXRwdXQpO1xuXG4gICAgaW5wdXQuYWRkID0gb3V0cHV0LmFkZDtcbiAgICBpbnB1dC5tb2QgPSBvdXRwdXQubW9kO1xuICAgIGlucHV0LnJlbSA9IG91dHB1dC5yZW07XG4gICAgaW5wdXQuc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShpbnB1dCwgdGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gIH1cbn1cblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QodGhpcy5waXBlbGluZSgpKTtcbiAgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0NBTEVTKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBidWlsZGVyLl9wYXJlbnQuc2NhbGUocykuYWRkTGlzdGVuZXIoYnVpbGRlcik7XG4gIH0pO1xuXG4gIGlmKHRoaXMuX3BhcmVudCkge1xuICAgIGlmKHRoaXMuX2lzU3VwZXIpIHRoaXMuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICAgIGVsc2UgdGhpcy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQuX2NvbGxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBpZighdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xuICB0aGlzLl9ncmFwaC5kaXNjb25uZWN0KHRoaXMucGlwZWxpbmUoKSk7XG4gIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNDQUxFUykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgYnVpbGRlci5fcGFyZW50LnNjYWxlKHMpLnJlbW92ZUxpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5zaWJsaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50LmNoaWxkKG5hbWUsIHRoaXMuX3BhcmVudF9pZCk7XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZ1wiLCB0aGlzLl9mcm9tLCB0aGlzLl9kZWYudHlwZV0pO1xuXG4gIHZhciBvdXRwdXQsIGZ1bGxVcGRhdGUsIGZjcywgZGF0YTtcblxuICBpZih0aGlzLl9kcykge1xuICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYW55IGVuY29kZXIgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBlbmNvZGVyJ3MgZGF0YSBzb3VyY2Ugd2lsbCBsaWtlbHkgYmUgdXBkYXRlZCwgYW5kIHNob3VsZG4ndFxuICAgIC8vIHRyaWdnZXIgYWxsIGl0ZW1zIHRvIG1vZC5cbiAgICBkYXRhID0gZGwuZHVwbGljYXRlKG91dHB1dC5kYXRhKTtcbiAgICBkZWxldGUgb3V0cHV0LmRhdGFbdGhpcy5fZHMubmFtZSgpXTtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LmRhdGEgPSBkYXRhO1xuXG4gICAgLy8gSWYgYSBzY2FsZSBvciBzaWduYWwgaW4gdGhlIHVwZGF0ZSBwcm9wc2V0IGhhcyBiZWVuIHVwZGF0ZWQsIFxuICAgIC8vIHNlbmQgZm9yd2FyZCBhbGwgaXRlbXMgZm9yIHJlZW5jb2RpbmcgaWYgd2UgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgIGlmKGZ1bGxVcGRhdGUpIG91dHB1dC5tb2QgPSB0aGlzLl9tYXJrLml0ZW1zLnNsaWNlKCk7XG5cbiAgICBmY3MgPSB0aGlzLl9kcy5sYXN0KCk7XG4gICAgaWYoIWZjcykge1xuICAgICAgb3V0cHV0LnJlZmxvdyA9IHRydWVcbiAgICB9IGVsc2UgaWYoZmNzLnN0YW1wID4gdGhpcy5fc3RhbXApIHtcbiAgICAgIG91dHB1dCA9IGpvaW5EYXRhc291cmNlLmNhbGwodGhpcywgZmNzLCB0aGlzLl9kcy52YWx1ZXMoKSwgZnVsbFVwZGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZ1bGxVcGRhdGUgPSB0aGlzLl9lbmNvZGVyLnJlZXZhbHVhdGUoaW5wdXQpO1xuICAgIGRhdGEgPSBkbC5pc0Z1bmN0aW9uKHRoaXMuX2RlZi5mcm9tKSA/IHRoaXMuX2RlZi5mcm9tKCkgOiBbQy5TRU5USU5FTF07XG4gICAgb3V0cHV0ID0gam9pblZhbHVlcy5jYWxsKHRoaXMsIGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKTtcbiAgfVxuXG4gIG91dHB1dCA9IHRoaXMuX2dyYXBoLmV2YWx1YXRlKG91dHB1dCwgdGhpcy5fZW5jb2Rlcik7XG4gIHJldHVybiB0aGlzLl9pc1N1cGVyID8gdGhpcy5fZ3JhcGguZXZhbHVhdGUob3V0cHV0LCB0aGlzLl9ib3VuZGVyKSA6IG91dHB1dDtcbn07XG5cbmZ1bmN0aW9uIG5ld0l0ZW0oKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQsXG4gICAgICBpdGVtID0gdHVwbGUuaW5nZXN0KG5ldyBJdGVtKHRoaXMuX21hcmspLCBwcmV2KTtcblxuICAvLyBGb3IgdGhlIHJvb3Qgbm9kZSdzIGl0ZW1cbiAgaWYodGhpcy5fZGVmLndpZHRoKSAgdHVwbGUuc2V0KGl0ZW0sIFwid2lkdGhcIiwgIHRoaXMuX2RlZi53aWR0aCk7XG4gIGlmKHRoaXMuX2RlZi5oZWlnaHQpIHR1cGxlLnNldChpdGVtLCBcImhlaWdodFwiLCB0aGlzLl9kZWYuaGVpZ2h0KTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBqb2luKGRhdGEsIGtleWYsIG5leHQsIG91dHB1dCwgcHJldiwgbW9kKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvcihpPTAsIGxlbj1kYXRhLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcbiAgICBpdGVtICA9IGtleWYgPyB0aGlzLl9tYXBba2V5ID0ga2V5ZihkYXR1bSldIDogcHJldltpXTtcbiAgICBlbnRlciA9IGl0ZW0gPyBmYWxzZSA6IChpdGVtID0gbmV3SXRlbS5jYWxsKHRoaXMpLCB0cnVlKTtcbiAgICBpdGVtLnN0YXR1cyA9IGVudGVyID8gQy5FTlRFUiA6IEMuVVBEQVRFO1xuICAgIGl0ZW0uZGF0dW0gPSBkYXR1bTtcbiAgICB0dXBsZS5zZXQoaXRlbSwgXCJrZXlcIiwga2V5KTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IGl0ZW07XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIGlmKGVudGVyKSBvdXRwdXQuYWRkLnB1c2goaXRlbSk7XG4gICAgZWxzZSBpZighbW9kIHx8IChtb2QgJiYgbW9kW2RhdHVtLl9pZF0pKSBvdXRwdXQubW9kLnB1c2goaXRlbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gam9pbkRhdGFzb3VyY2UoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkgfHwgXCJfaWRcIiksXG4gICAgICBhZGQgPSBpbnB1dC5hZGQsIFxuICAgICAgbW9kID0gaW5wdXQubW9kLCBcbiAgICAgIHJlbSA9IGlucHV0LnJlbSxcbiAgICAgIG5leHQgPSBbXSxcbiAgICAgIGksIGtleSwgbGVuLCBpdGVtLCBkYXR1bSwgZW50ZXI7XG5cbiAgLy8gQnVpbGQgcmVtcyBmaXJzdCwgYW5kIHB1dCB0aGVtIGF0IHRoZSBoZWFkIG9mIHRoZSBuZXh0IGl0ZW1zXG4gIC8vIFRoZW4gYnVpbGQgdGhlIHJlc3Qgb2YgdGhlIGRhdGEgdmFsdWVzICh3aGljaCB3b24ndCBjb250YWluIHJlbSkuXG4gIC8vIFRoaXMgd2lsbCBwcmVzZXJ2ZSB0aGUgc29ydCBvcmRlciB3aXRob3V0IG5lZWRpbmcgYW55dGhpbmcgZXh0cmEuXG5cbiAgZm9yKGk9MCwgbGVuPXJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gdGhpcy5fbWFwW2tleSA9IGtleWYocmVtW2ldKV07XG4gICAgaXRlbS5zdGF0dXMgPSBDLkVYSVQ7XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIG91dHB1dC5yZW0ucHVzaChpdGVtKTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IG51bGw7XG4gIH1cblxuICBqb2luLmNhbGwodGhpcywgZGF0YSwga2V5ZiwgbmV4dCwgb3V0cHV0LCBudWxsLCB0dXBsZS5pZE1hcChmdWxsVXBkYXRlID8gZGF0YSA6IG1vZCkpO1xuXG4gIHJldHVybiAodGhpcy5fbWFyay5pdGVtcyA9IG5leHQsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGpvaW5WYWx1ZXMoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkpLFxuICAgICAgcHJldiA9IHRoaXMuX21hcmsuaXRlbXMgfHwgW10sXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuRVhJVDtcbiAgICBpZiAoa2V5ZikgdGhpcy5fbWFwW2l0ZW0ua2V5XSA9IGl0ZW07XG4gIH1cbiAgXG4gIGpvaW4uY2FsbCh0aGlzLCBkYXRhLCBrZXlmLCBuZXh0LCBvdXRwdXQsIHByZXYsIGZ1bGxVcGRhdGUgPyB0dXBsZS5pZE1hcChkYXRhKSA6IG51bGwpO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkge1xuICAgICAgdHVwbGUuc2V0KGl0ZW0sIFwia2V5XCIsIGtleWYgPyBpdGVtLmtleSA6IHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICBuZXh0LnNwbGljZSgwLCAwLCBpdGVtKTsgIC8vIEtlZXAgaXRlbSBhcm91bmQgZm9yIFwiZXhpdFwiIHRyYW5zaXRpb24uXG4gICAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gKHRoaXMuX21hcmsuaXRlbXMgPSBuZXh0LCBvdXRwdXQpO1xufTtcblxuZnVuY3Rpb24ga2V5RnVuY3Rpb24oa2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBmID0gZGwuYXJyYXkoa2V5KS5tYXAoZGwuYWNjZXNzb3IpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIGZvciAodmFyIHM9XCJcIiwgaT0wLCBuPWYubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKGk+MCkgcyArPSBcInxcIjtcbiAgICAgIHMgKz0gU3RyaW5nKGZbaV0oZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyOyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEVNUFRZID0ge307XG5cbmZ1bmN0aW9uIEVuY29kZXIoZ3JhcGgsIG1hcmspIHtcbiAgdmFyIHByb3BzID0gbWFyay5kZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIHVwZGF0ZSA9IHByb3BzLnVwZGF0ZTtcblxuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpXG5cbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuXG4gIGlmKHVwZGF0ZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHVwZGF0ZS5kYXRhKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHVwZGF0ZS5zY2FsZXMpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIHVwZGF0ZS5zaWduYWxzKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5GSUVMRFMsIHVwZGF0ZS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChFbmNvZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJlbmNvZGluZ1wiLCB0aGlzLl9tYXJrLmRlZi50eXBlXSk7XG4gIHZhciBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgaXRlbXMgPSB0aGlzLl9tYXJrLml0ZW1zLFxuICAgICAgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgZW50ZXIgID0gcHJvcHMuZW50ZXIsXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUsXG4gICAgICBleGl0ICAgPSBwcm9wcy5leGl0LFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSwgIC8vIEZvciBleHBlZGllbmN5LCBnZXQgYWxsIHNpZ25hbCB2YWx1ZXNcbiAgICAgIGRiLCBpLCBsZW4sIGl0ZW07XG5cbiAgZGIgPSBncmFwaC5kYXRhKCkucmVkdWNlKGZ1bmN0aW9uKGRiLCBkcykgeyBcbiAgICByZXR1cm4gKGRiW2RzLm5hbWUoKV0gPSBkcy52YWx1ZXMoKSwgZGIpO1xuICB9LCB7fSk7XG5cbiAgLy8gSXRlbXMgbWFya2VkIGZvciByZW1vdmFsIGFyZSBhdCB0aGUgaGVhZCBvZiBpdGVtcy4gUHJvY2VzcyB0aGVtIGZpcnN0LlxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5yZW1baV07XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2cpO1xuICAgIGlmKGV4aXQpICAgZW5jb2RlLmNhbGwodGhpcywgZXhpdCwgICBpdGVtLCBpbnB1dC50cmFucyksIGRiLCBzZzsgXG4gICAgaWYoaW5wdXQudHJhbnMgJiYgIWV4aXQpIGlucHV0LnRyYW5zLmludGVycG9sYXRlKGl0ZW0sIEVNUFRZKTtcbiAgICBlbHNlIGlmKCFpbnB1dC50cmFucykgaXRlbS5yZW1vdmUoKTtcbiAgfVxuXG4gIGZvcihpPTAsIGxlbj1pbnB1dC5hZGQubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IGlucHV0LmFkZFtpXTtcbiAgICBpZihlbnRlcikgIGVuY29kZS5jYWxsKHRoaXMsIGVudGVyLCAgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZyk7XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2cpO1xuICAgIGl0ZW0uc3RhdHVzID0gQy5VUERBVEU7XG4gIH1cblxuICBpZih1cGRhdGUpIHtcbiAgICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGlucHV0Lm1vZFtpXTtcbiAgICAgIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuZnVuY3Rpb24gZW5jb2RlKHByb3AsIGl0ZW0sIHRyYW5zLCBkYiwgc2cpIHtcbiAgdmFyIGVuYyA9IHByb3AuZW5jb2RlO1xuICBlbmMuY2FsbChlbmMsIGl0ZW0sIGl0ZW0ubWFyay5ncm91cHx8aXRlbSwgdHJhbnMsIGRiLCBzZywgdGhpcy5fZ3JhcGgucHJlZGljYXRlcygpKTtcbn1cblxuLy8gSWYgdXBkYXRlIHByb3BlcnR5IHNldCB1c2VzIG5lc3RlZCBmaWVsZHJlZnMsIHJlZXZhbHVhdGUgYWxsIGl0ZW1zLlxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX21hcmsuZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGU7XG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5yZWV2YWx1YXRlLmNhbGwodGhpcywgcHVsc2UpIHx8ICh1cGRhdGUgPyB1cGRhdGUucmVmbG93IDogZmFsc2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKSxcbiAgICBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBwYXJzZUF4ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9heGVzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnVpbGRlcigpIHtcbiAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgdGhpcy5fc2NhbGVyID0gbnVsbDtcbiAgdGhpcy5fcmVjdXJzb3IgPSBudWxsO1xuXG4gIHRoaXMuX3NjYWxlcyA9IHt9O1xuICB0aGlzLnNjYWxlID0gc2NhbGUuYmluZCh0aGlzKTtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHcm91cEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IEJ1aWxkZXIoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX3NjYWxlciA9IG5ldyBOb2RlKGdyYXBoKTtcblxuICAoZGVmLnNjYWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ocykgeyBcbiAgICBzID0gYnVpbGRlci5zY2FsZShzLm5hbWUsIG5ldyBTY2FsZShncmFwaCwgcywgYnVpbGRlcikpO1xuICAgIGJ1aWxkZXIuX3NjYWxlci5hZGRMaXN0ZW5lcihzKTsgIC8vIFNjYWxlcyBzaG91bGQgYmUgY29tcHV0ZWQgYWZ0ZXIgZ3JvdXAgaXMgZW5jb2RlZFxuICB9KTtcblxuICB0aGlzLl9yZWN1cnNvciA9IG5ldyBOb2RlKGdyYXBoKTtcbiAgdGhpcy5fcmVjdXJzb3IuZXZhbHVhdGUgPSByZWN1cnNlLmJpbmQodGhpcyk7XG5cbiAgdmFyIHNjYWxlcyA9IChkZWYuYXhlc3x8W10pLnJlZHVjZShmdW5jdGlvbihhY2MsIHgpIHtcbiAgICByZXR1cm4gKGFjY1t4LnNjYWxlXSA9IDEsIGFjYyk7XG4gIH0sIHt9KTtcbiAgdGhpcy5fcmVjdXJzb3IuZGVwZW5kZW5jeShDLlNDQUxFUywgZGwua2V5cyhzY2FsZXMpKTtcblxuICAvLyBXZSBvbmx5IG5lZWQgYSBjb2xsZWN0b3IgZm9yIHVwLXByb3BhZ2F0aW9uIG9mIGJvdW5kcyBjYWxjdWxhdGlvbixcbiAgLy8gc28gb25seSBHcm91cEJ1aWxkZXJzLCBhbmQgbm90IHJlZ3VsYXIgQnVpbGRlcnMsIGhhdmUgY29sbGVjdG9ycy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG5cbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IEJ1aWxkZXIucHJvdG90eXBlLmV2YWx1YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgYnVpbGRHcm91cC5jYWxsKGJ1aWxkZXIsIG91dHB1dCwgZ3JvdXApOyB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcywgdGhpcy5fc2NhbGVyLCB0aGlzLl9yZWN1cnNvciwgdGhpcy5fY29sbGVjdG9yLCB0aGlzLl9ib3VuZGVyXTtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBkbC5rZXlzKGJ1aWxkZXIuX2NoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwX2lkKSB7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXBfaWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7XG4gICAgfSlcbiAgfSk7XG5cbiAgYnVpbGRlci5fY2hpbGRyZW4gPSB7fTtcbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLmNoaWxkID0gZnVuY3Rpb24obmFtZSwgZ3JvdXBfaWQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bZ3JvdXBfaWRdLFxuICAgICAgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGNoaWxkO1xuXG4gIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmKGNoaWxkLnR5cGUgPT0gQy5NQVJLICYmIGNoaWxkLmJ1aWxkZXIuX2RlZi5uYW1lID09IG5hbWUpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkLmJ1aWxkZXI7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNlKGlucHV0KSB7XG4gIHZhciBidWlsZGVyID0gdGhpcyxcbiAgICAgIGhhc01hcmtzID0gdGhpcy5fZGVmLm1hcmtzICYmIHRoaXMuX2RlZi5tYXJrcy5sZW5ndGggPiAwLFxuICAgICAgaGFzQXhlcyA9IHRoaXMuX2RlZi5heGVzICYmIHRoaXMuX2RlZi5heGVzLmxlbmd0aCA+IDAsXG4gICAgICBpLCBsZW4sIGdyb3VwLCBwaXBlbGluZSwgZGVmLCBpbmxpbmUgPSBmYWxzZTtcblxuICBmb3IoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmKGhhc01hcmtzKSBidWlsZE1hcmtzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgICBpZihoYXNBeGVzKSAgYnVpbGRBeGVzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIFdpcmUgdXAgbmV3IGNoaWxkcmVuIGJ1aWxkZXJzIGluIHJldmVyc2UgdG8gbWluaW1pemUgZ3JhcGggcmV3cml0ZXMuXG4gIGZvciAoaT1pbnB1dC5hZGQubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGZvciAoaj10aGlzLl9jaGlsZHJlbltncm91cC5faWRdLmxlbmd0aC0xOyBqPj0wOyAtLWopIHtcbiAgICAgIGMgPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdW2pdO1xuICAgICAgYy5idWlsZGVyLmNvbm5lY3QoKTtcbiAgICAgIHBpcGVsaW5lID0gYy5idWlsZGVyLnBpcGVsaW5lKCk7XG4gICAgICBkZWYgPSBjLmJ1aWxkZXIuX2RlZjtcblxuICAgICAgLy8gVGhpcyBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYnVpbHQgZHVyaW5nIHRoaXMgcHJvcGFnYXRpb24gY3ljbGUuXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgaXRzIGJ1aWxkZXIgYXMgYSBsaXN0ZW5lciBvZmYgdGhlIF9yZWN1cnNvciBub2RlLCBcbiAgICAgIC8vIGJ1dCB0cnkgdG8gaW5saW5lIGl0IGlmIHdlIGNhbiB0byBtaW5pbWl6ZSBncmFwaCBkaXNwYXRjaGVzLlxuICAgICAgaW5saW5lID0gKGRlZi50eXBlICE9PSBDLkdST1VQKTtcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAodGhpcy5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQpOyBcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAocGlwZWxpbmVbcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpLmxlbmd0aCA9PSAxKTsgLy8gUmVhY3RpdmUgZ2VvbVxuICAgICAgYy5pbmxpbmUgPSBpbmxpbmU7XG5cbiAgICAgIGlmKGlubGluZSkgYy5idWlsZGVyLmV2YWx1YXRlKGlucHV0KTtcbiAgICAgIGVsc2UgdGhpcy5fcmVjdXJzb3IuYWRkTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQubW9kW2ldO1xuICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY29ubmVjdGlvbiBmb3IgbWFya3MgdGhhdCBkcmF3IGZyb20gYSBzb3VyY2VcbiAgICBpZihoYXNNYXJrcykge1xuICAgICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYoYy50eXBlID09IEMuTUFSSyAmJiAhYy5pbmxpbmUgJiYgYnVpbGRlci5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGF4ZXMgZGF0YSBkZWZzXG4gICAgaWYoaGFzQXhlcykge1xuICAgICAgcGFyc2VBeGVzKGJ1aWxkZXIuX2dyYXBoLCBidWlsZGVyLl9kZWYuYXhlcywgZ3JvdXAuYXhlcywgZ3JvdXApO1xuICAgICAgZ3JvdXAuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHsgYS5kZWYoKSB9KTtcbiAgICB9ICAgICAgXG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQucmVtW2ldO1xuICAgIC8vIEZvciBkZWxldGVkIGdyb3VwcywgZGlzY29ubmVjdCB0aGVpciBjaGlsZHJlblxuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0uZm9yRWFjaChmdW5jdGlvbihjKSB7IFxuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7IFxuICAgIH0pO1xuICAgIGRlbGV0ZSBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuZnVuY3Rpb24gc2NhbGUobmFtZSwgc2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gdGhpcztcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIChncm91cC5fc2NhbGVzW25hbWVdID0gc2NhbGUsIHNjYWxlKTtcbiAgd2hpbGUoc2NhbGUgPT0gbnVsbCkge1xuICAgIHNjYWxlID0gZ3JvdXAuX3NjYWxlc1tuYW1lXTtcbiAgICBncm91cCA9IGdyb3VwLm1hcmsgPyBncm91cC5tYXJrLmdyb3VwIDogZ3JvdXAuX3BhcmVudDtcbiAgICBpZighZ3JvdXApIGJyZWFrO1xuICB9XG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRHcm91cChpbnB1dCwgZ3JvdXApIHtcbiAgZGVidWcoaW5wdXQsIFtcImJ1aWxkaW5nIGdyb3VwXCIsIGdyb3VwLl9pZF0pO1xuXG4gIGdyb3VwLl9zY2FsZXMgPSBncm91cC5fc2NhbGVzIHx8IHt9OyAgICBcbiAgZ3JvdXAuc2NhbGUgID0gc2NhbGUuYmluZChncm91cCk7XG5cbiAgZ3JvdXAuaXRlbXMgPSBncm91cC5pdGVtcyB8fCBbXTtcbiAgdGhpcy5fY2hpbGRyZW5bZ3JvdXAuX2lkXSA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gfHwgW107XG5cbiAgZ3JvdXAuYXhlcyA9IGdyb3VwLmF4ZXMgfHwgW107XG4gIGdyb3VwLmF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNYXJrcyhpbnB1dCwgZ3JvdXApIHtcbiAgZGVidWcoaW5wdXQsIFtcImJ1aWxkaW5nIG1hcmtzXCIsIGdyb3VwLl9pZF0pO1xuICB2YXIgbWFya3MgPSB0aGlzLl9kZWYubWFya3MsXG4gICAgICBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgIG1hcmssIGZyb20sIGluaGVyaXQsIGksIGxlbiwgbSwgYjtcblxuICBmb3IoaT0wLCBsZW49bWFya3MubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbWFyayA9IG1hcmtzW2ldO1xuICAgIGZyb20gPSBtYXJrLmZyb20gfHwge307XG4gICAgaW5oZXJpdCA9IFwidmdfXCIrZ3JvdXAuZGF0dW0uX2lkO1xuICAgIGdyb3VwLml0ZW1zW2ldID0ge2dyb3VwOiBncm91cH07XG4gICAgYiA9IChtYXJrLnR5cGUgPT09IEMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQodGhpcy5fZ3JhcGgsIG1hcmssIGdyb3VwLml0ZW1zW2ldLCB0aGlzLCBncm91cC5faWQsIGluaGVyaXQpO1xuICAgIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IFxuICAgICAgYnVpbGRlcjogYiwgXG4gICAgICBmcm9tOiBmcm9tLmRhdGEgfHwgKGZyb20ubWFyayA/IChcInZnX1wiICsgZ3JvdXAuX2lkICsgXCJfXCIgKyBmcm9tLm1hcmspIDogaW5oZXJpdCksIFxuICAgICAgdHlwZTogQy5NQVJLIFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQXhlcyhpbnB1dCwgZ3JvdXApIHtcbiAgdmFyIGF4ZXMgPSBncm91cC5heGVzLFxuICAgICAgYXhpc0l0ZW1zID0gZ3JvdXAuYXhpc0l0ZW1zLFxuICAgICAgYnVpbGRlciA9IHRoaXM7XG5cbiAgcGFyc2VBeGVzKHRoaXMuX2dyYXBoLCB0aGlzLl9kZWYuYXhlcywgYXhlcywgZ3JvdXApO1xuICBheGVzLmZvckVhY2goZnVuY3Rpb24oYSwgaSkge1xuICAgIHZhciBzY2FsZSA9IGJ1aWxkZXIuX2RlZi5heGVzW2ldLnNjYWxlLFxuICAgICAgICBkZWYgPSBhLmRlZigpLFxuICAgICAgICBiID0gbnVsbDtcblxuICAgIGF4aXNJdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIGF4aXNEZWY6IGRlZn07XG4gICAgYiA9IChkZWYudHlwZSA9PT0gQy5HUk9VUCkgPyBuZXcgR3JvdXBCdWlsZGVyKCkgOiBuZXcgQnVpbGRlcigpO1xuICAgIGIuaW5pdChidWlsZGVyLl9ncmFwaCwgZGVmLCBheGlzSXRlbXNbaV0sIGJ1aWxkZXIpXG4gICAgICAuZGVwZW5kZW5jeShDLlNDQUxFUywgc2NhbGUpO1xuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IGJ1aWxkZXI6IGIsIHR5cGU6IEMuQVhJUywgc2NhbGU6IHNjYWxlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ1aWxkZXI7IiwiZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG59XG5cbnZhciBwcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmhhc1Byb3BlcnR5U2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gIHJldHVybiBwcm9wcyAmJiBwcm9wc1tuYW1lXSAhPSBudWxsO1xufTtcblxucHJvdG90eXBlLmNvdXNpbiA9IGZ1bmN0aW9uKG9mZnNldCwgaW5kZXgpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBncm91cCA9IG1hcmsuZ3JvdXAsXG4gICAgICBpaWR4ID0gaW5kZXg9PW51bGwgPyBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgOiBpbmRleCxcbiAgICAgIG1pZHggPSBncm91cC5pdGVtcy5pbmRleE9mKG1hcmspICsgb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXAuaXRlbXNbbWlkeF0uaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGlpZHggPSBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgKyBvZmZzZXQ7XG4gIHJldHVybiBtYXJrLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IHRoaXMsXG4gICAgICBsaXN0ID0gaXRlbS5tYXJrLml0ZW1zLFxuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGkgPj0gMCkgKGk9PT1saXN0Lmxlbmd0aC0xKSA/IGxpc3QucG9wKCkgOiBsaXN0LnNwbGljZShpLCAxKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGF0aENhY2hlKSB0aGlzLnBhdGhDYWNoZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hcmsucGF0aENhY2hlKSB0aGlzLm1hcmsucGF0aENhY2hlID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvQWdncmVnYXRlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIEdST1VQX1BST1BFUlRZID0ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9O1xuXG5mdW5jdGlvbiBTY2FsZShncmFwaCwgZGVmLCBwYXJlbnQpIHtcbiAgdGhpcy5fZGVmICAgICA9IGRlZjtcbiAgdGhpcy5fcGFyZW50ICA9IHBhcmVudDtcbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbn1cblxudmFyIHByb3RvID0gKFNjYWxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZuID0gZnVuY3Rpb24oZ3JvdXApIHsgc2NhbGUuY2FsbChzZWxmLCBncm91cCk7IH07XG5cbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICBpbnB1dC5hZGQuZm9yRWFjaChmbik7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZuKTtcblxuICAvLyBTY2FsZXMgYXJlIGF0IHRoZSBlbmQgb2YgYW4gZW5jb2RpbmcgcGlwZWxpbmUsIHNvIHRoZXkgc2hvdWxkIGZvcndhcmQgYVxuICAvLyByZWZsb3cgcHVsc2UuIFRodXMsIGlmIG11bHRpcGxlIHNjYWxlcyB1cGRhdGUgaW4gdGhlIHBhcmVudCBncm91cCwgd2UgZG9uJ3RcbiAgLy8gcmVldmFsdWF0ZSBjaGlsZCBtYXJrcyBtdWx0aXBsZSB0aW1lcy4gXG4gIGlmICh0aGlzLl91cGRhdGVkKSBpbnB1dC5zY2FsZXNbdGhpcy5fZGVmLm5hbWVdID0gMTtcbiAgcmV0dXJuIGNoYW5nZXNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xufTtcblxuLy8gQWxsIG9mIGEgc2NhbGUncyBkZXBlbmRlbmNpZXMgYXJlIHJlZ2lzdGVyZWQgZHVyaW5nIHByb3BhZ2F0aW9uIGFzIHdlIHBhcnNlXG4vLyBkYXRhUmVmcy4gU28gYSBzY2FsZSBtdXN0IGJlIHJlc3BvbnNpYmxlIGZvciBjb25uZWN0aW5nIGl0c2VsZiB0byBkZXBlbmRlbnRzLlxucHJvdG8uZGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHR5cGUsIGRlcHMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgIGRlcHMgPSBkbC5hcnJheShkZXBzKTtcbiAgICBmb3IodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9ncmFwaFt0eXBlID09IEMuREFUQSA/IEMuREFUQSA6IEMuU0lHTkFMXShkZXBzW2ldKVxuICAgICAgICAuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuZGVwZW5kZW5jeS5jYWxsKHRoaXMsIHR5cGUsIGRlcHMpO1xufTtcblxuZnVuY3Rpb24gc2NhbGUoZ3JvdXApIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9kZWYubmFtZSxcbiAgICAgIHByZXYgPSBuYW1lICsgXCI6cHJldlwiLFxuICAgICAgcyA9IGluc3RhbmNlLmNhbGwodGhpcywgZ3JvdXAuc2NhbGUobmFtZSkpLFxuICAgICAgbSA9IHMudHlwZT09PUMuT1JESU5BTCA/IG9yZGluYWwgOiBxdWFudGl0YXRpdmUsXG4gICAgICBybmcgPSByYW5nZS5jYWxsKHRoaXMsIGdyb3VwKTtcblxuICBtLmNhbGwodGhpcywgcywgcm5nLCBncm91cCk7XG5cbiAgZ3JvdXAuc2NhbGUobmFtZSwgcyk7XG4gIGdyb3VwLnNjYWxlKHByZXYsIGdyb3VwLnNjYWxlKHByZXYpIHx8IHMpO1xuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZShzY2FsZSkge1xuICB2YXIgdHlwZSA9IHRoaXMuX2RlZi50eXBlIHx8IEMuTElORUFSO1xuICBpZiAoIXNjYWxlIHx8IHR5cGUgIT09IHNjYWxlLnR5cGUpIHtcbiAgICB2YXIgY3RvciA9IGNvbmZpZy5zY2FsZVt0eXBlXSB8fCBkMy5zY2FsZVt0eXBlXTtcbiAgICBpZiAoIWN0b3IpIGRsLmVycm9yKFwiVW5yZWNvZ25pemVkIHNjYWxlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgKHNjYWxlID0gY3RvcigpKS50eXBlID0gc2NhbGUudHlwZSB8fCB0eXBlO1xuICAgIHNjYWxlLnNjYWxlTmFtZSA9IHRoaXMuX2RlZi5uYW1lO1xuICAgIHNjYWxlLl9wcmV2ID0ge307XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkb21haW4sIHNvcnQsIHN0ciwgcmVmcywgZGF0YURyaXZlblJhbmdlID0gZmFsc2U7XG4gIFxuICAvLyByYW5nZSBwcmUtcHJvY2Vzc2luZyBmb3IgZGF0YS1kcml2ZW4gcmFuZ2VzXG4gIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpICYmICFkbC5pc0FycmF5KGRlZi5yYW5nZSkpIHtcbiAgICBkYXRhRHJpdmVuUmFuZ2UgPSB0cnVlO1xuICAgIHJuZyA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLlJBTkdFLCBkZWYucmFuZ2UsIHNjYWxlLCBncm91cCk7XG4gIH1cbiAgXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcblxuICBzdHIgPSB0eXBlb2Ygcm5nWzBdID09PSAnc3RyaW5nJztcbiAgaWYgKHN0ciB8fCBybmcubGVuZ3RoID4gMiB8fCBybmcubGVuZ3RoPT09MSB8fCBkYXRhRHJpdmVuUmFuZ2UpIHtcbiAgICBzY2FsZS5yYW5nZShybmcpOyAvLyBjb2xvciBvciBzaGFwZSB2YWx1ZXNcbiAgfSBlbHNlIGlmIChkZWYucG9pbnRzKSB7XG4gICAgc2NhbGUucmFuZ2VQb2ludHMocm5nLCBkZWYucGFkZGluZ3x8MCk7XG4gIH0gZWxzZSBpZiAoZGVmLnJvdW5kIHx8IGRlZi5yb3VuZD09PXVuZGVmaW5lZCkge1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyhybmcsIGRlZi5wYWRkaW5nfHwwKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZS5yYW5nZUJhbmRzKHJuZywgZGVmLnBhZGRpbmd8fDApO1xuICB9XG5cbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXRhdGl2ZShzY2FsZSwgcm5nLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgcHJldiA9IHNjYWxlLl9wcmV2LFxuICAgICAgZG9tYWluLCBpbnRlcnZhbDtcblxuICAvLyBkb21haW5cbiAgZG9tYWluID0gKGRlZi50eXBlID09PSBDLlFVQU5USUxFKVxuICAgID8gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOLCBkZWYuZG9tYWluLCBzY2FsZSwgZ3JvdXApXG4gICAgOiBkb21haW5NaW5NYXguY2FsbCh0aGlzLCBzY2FsZSwgZ3JvdXApO1xuICBpZiAoZG9tYWluICYmICFkbC5lcXVhbChwcmV2LmRvbWFpbiwgZG9tYWluKSkge1xuICAgIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgIHByZXYuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICB9IFxuXG4gIC8vIHJhbmdlXG4gIC8vIHZlcnRpY2FsIHNjYWxlcyBzaG91bGQgZmxpcCBieSBkZWZhdWx0LCBzbyB1c2UgWE9SIGhlcmVcbiAgaWYgKGRlZi5yYW5nZSA9PT0gXCJoZWlnaHRcIikgcm5nID0gcm5nLnJldmVyc2UoKTtcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcbiAgc2NhbGVbZGVmLnJvdW5kICYmIHNjYWxlLnJhbmdlUm91bmQgPyBcInJhbmdlUm91bmRcIiA6IFwicmFuZ2VcIl0ocm5nKTtcbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG5cbiAgLy8gVE9ETzogU3VwcG9ydCBzaWduYWxzIGZvciB0aGVzZSBwcm9wZXJ0aWVzLiBVbnRpbCB0aGVuLCBvbmx5IGV2YWxcbiAgLy8gdGhlbSBvbmNlLlxuICBpZiAodGhpcy5fc3RhbXAgPiAwKSByZXR1cm47XG4gIGlmIChkZWYuZXhwb25lbnQgJiYgZGVmLnR5cGU9PT1DLlBPV0VSKSBzY2FsZS5leHBvbmVudChkZWYuZXhwb25lbnQpO1xuICBpZiAoZGVmLmNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGRlZi5uaWNlKSB7XG4gICAgaWYgKGRlZi50eXBlID09PSBDLlRJTUUpIHtcbiAgICAgIGludGVydmFsID0gZDMudGltZVtkZWYubmljZV07XG4gICAgICBpZiAoIWludGVydmFsKSBkbC5lcnJvcihcIlVucmVjb2duaXplZCBpbnRlcnZhbDogXCIgKyBpbnRlcnZhbCk7XG4gICAgICBzY2FsZS5uaWNlKGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUubmljZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhUmVmKHdoaWNoLCBkZWYsIHNjYWxlLCBncm91cCkge1xuICBpZiAoZGVmID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG4gIGlmIChkbC5pc0FycmF5KGRlZikpIHJldHVybiBkZWYubWFwKHNpZ25hbC5iaW5kKHRoaXMpKTtcblxuICB2YXIgc2VsZiA9IHRoaXMsIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICByZWZzID0gZGVmLmZpZWxkcyB8fCBkbC5hcnJheShkZWYpLFxuICAgICAgdW5pcXVlcyA9IHNjYWxlLnR5cGUgPT09IEMuT1JESU5BTCB8fCBzY2FsZS50eXBlID09PSBDLlFVQU5USUxFLFxuICAgICAgY2sgPSBcIl9cIit3aGljaCxcbiAgICAgIGNhY2hlID0gc2NhbGVbY2tdLFxuICAgICAgY2FjaGVGaWVsZCA9IHtvcHM6IFtdfSwgIC8vIHRoZSBmaWVsZCBhbmQgbWVhc3VyZXMgaW4gdGhlIGFnZ3JlZ2F0b3JcbiAgICAgIHNvcnQgPSBkZWYuc29ydCxcbiAgICAgIGksIHJsZW4sIGosIGZsZW4sIHIsIGZpZWxkcywgZnJvbSwgZGF0YSwga2V5cztcblxuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBzY2FsZVtja10gPSBuZXcgQWdncmVnYXRlKGdyYXBoKTtcbiAgICBjYWNoZUZpZWxkLm9wcyA9IFtdO1xuICAgIGNhY2hlLnNpbmdsZXRvbih0cnVlKTtcbiAgICBpZiAodW5pcXVlcyAmJiBzb3J0KSBjYWNoZUZpZWxkLm9wcy5wdXNoKHNvcnQuc3RhdCk7XG4gIH1cblxuICBmb3IoaT0wLCBybGVuPXJlZnMubGVuZ3RoOyBpPHJsZW47ICsraSkge1xuICAgIHIgPSByZWZzW2ldO1xuICAgIGZyb20gPSByLmRhdGEgfHwgXCJ2Z19cIitncm91cC5kYXR1bS5faWQ7XG4gICAgZGF0YSA9IGdyYXBoLmRhdGEoZnJvbSlcbiAgICAgIC5yZXZpc2VzKHRydWUpXG4gICAgICAubGFzdCgpO1xuXG4gICAgaWYgKGRhdGEuc3RhbXAgPD0gdGhpcy5fc3RhbXApIGNvbnRpbnVlO1xuXG4gICAgZmllbGRzID0gZGwuYXJyYXkoci5maWVsZCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIGlmIChmLnBhcmVudCkgcmV0dXJuIGRsLmFjY2Vzc29yKGYucGFyZW50KShncm91cC5kYXR1bSlcbiAgICAgIHJldHVybiBmOyAvLyBTdHJpbmcgb3Ige1wic2lnbmFsXCJ9XG4gICAgfSk7XG5cbiAgICBpZiAodW5pcXVlcykge1xuICAgICAgY2FjaGVGaWVsZC5uYW1lID0gc29ydCA/IHNvcnQuZmllbGQgOiBcIl9pZFwiO1xuICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKTtcbiAgICAgIGZvciAoaj0wLCBmbGVuPWZpZWxkcy5sZW5ndGg7IGo8ZmxlbjsgKytqKSB7XG4gICAgICAgIGNhY2hlLmdyb3VwX2J5LnNldChjYWNoZSwgZmllbGRzW2pdKVxuICAgICAgICAgIC5ldmFsdWF0ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqPTAsIGZsZW49ZmllbGRzLmxlbmd0aDsgajxmbGVuOyArK2opIHtcbiAgICAgICAgY2FjaGVGaWVsZC5uYW1lID0gZmllbGRzW2pdO1xuICAgICAgICBjYWNoZUZpZWxkLm9wcyAgPSBbQy5NSU4sIEMuTUFYXTtcbiAgICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKSAvLyBUcmVhdCBhcyBmbGF0IGRhdGFzb3VyY2VcbiAgICAgICAgICAuZXZhbHVhdGUoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuREFUQSwgZnJvbSk7XG4gICAgY2FjaGUuZGVwZW5kZW5jeShDLlNJR05BTFMpLmZvckVhY2goZnVuY3Rpb24ocykgeyBzZWxmLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzKSB9KTtcbiAgfVxuXG4gIGRhdGEgPSBjYWNoZS5kYXRhKCk7XG4gIGlmICh1bmlxdWVzKSB7XG4gICAga2V5cyA9IGRsLmtleXMoZGF0YSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaykgeyByZXR1cm4gZGF0YVtrXSAhPSBudWxsOyB9KTtcblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBzb3J0ID0gc29ydC5vcmRlci5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoc29ydC5vcmRlci5zaWduYWwpIDogc29ydC5vcmRlcjtcbiAgICAgIHNvcnQgPSAoc29ydCA9PSBDLkRFU0MgPyBcIi1cIiA6IFwiK1wiKSArIFwidHBsLlwiICsgY2FjaGVGaWVsZC5uYW1lO1xuICAgICAgc29ydCA9IGRsLmNvbXBhcmF0b3Ioc29ydCk7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4geyBrZXk6IGssIHRwbDogZGF0YVtrXS50cGwgfX0pXG4gICAgICAgIC5zb3J0KHNvcnQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gay5rZXk7IH0pO1xuICAgIC8vIH0gZWxzZSB7ICAvLyBcIkZpcnN0IHNlZW5cIiBvcmRlclxuICAgIC8vICAgc29ydCA9IGRsLmNvbXBhcmF0b3IoXCJ0cGwuX2lkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBkYXRhW1wiXCJdOyAvLyBVbnBhY2sgZmxhdCBhZ2dyZWdhdGlvblxuICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCkgPyBbXSA6IFtkYXRhW0MuU0lOR0xFVE9OXS5taW4sIGRhdGFbQy5TSU5HTEVUT05dLm1heF07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lnbmFsKHYpIHtcbiAgdmFyIHMgPSB2LnNpZ25hbCwgcmVmO1xuICBpZiAoIXMpIHJldHVybiB2O1xuICB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTLCAocmVmID0gZGwuZmllbGQocykpWzBdKTtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoLnNpZ25hbFJlZihyZWYpO1xufVxuXG5mdW5jdGlvbiBkb21haW5NaW5NYXgoc2NhbGUsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBkb21haW4gPSBbbnVsbCwgbnVsbF0sIHJlZnMsIHo7XG5cbiAgaWYgKGRlZi5kb21haW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGRvbWFpbiA9ICghZGwuaXNPYmplY3QoZGVmLmRvbWFpbikpID8gZG9tYWluIDpcbiAgICAgIGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuXG4gIHogPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgaWYgKGRlZi5kb21haW5NaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5pc09iamVjdChkZWYuZG9tYWluTWluKSkge1xuICAgICAgaWYgKGRlZi5kb21haW5NaW4uc2lnbmFsKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5kb21haW5NaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluWzBdID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOK0MuTUlOLCBkZWYuZG9tYWluTWluLCBzY2FsZSwgZ3JvdXApWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW5bMF0gPSBkZWYuZG9tYWluTWluO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLmRvbWFpbk1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NYXgpKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1heC5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluW3pdID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1heCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bel0gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4rQy5NQVgsIGRlZi5kb21haW5NYXgsIHNjYWxlLCBncm91cClbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblt6XSA9IGRlZi5kb21haW5NYXg7XG4gICAgfVxuICB9XG4gIGlmIChkZWYudHlwZSAhPT0gQy5MT0cgJiYgZGVmLnR5cGUgIT09IEMuVElNRSAmJiAoZGVmLnplcm8gfHwgZGVmLnplcm89PT11bmRlZmluZWQpKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oMCwgZG9tYWluWzBdKTtcbiAgICBkb21haW5bel0gPSBNYXRoLm1heCgwLCBkb21haW5bel0pO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHJhbmdlKGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBybmcgPSBbbnVsbCwgbnVsbF07XG5cbiAgaWYgKGRlZi5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYucmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoR1JPVVBfUFJPUEVSVFlbZGVmLnJhbmdlXSkge1xuICAgICAgICBybmcgPSBbMCwgZ3JvdXBbZGVmLnJhbmdlXV07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdKSB7XG4gICAgICAgIHJuZyA9IGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGwuZXJyb3IoXCJVbnJlY29naXplZCByYW5nZTogXCIrZGVmLnJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgICAgcm5nID0gZGVmLnJhbmdlLm1hcChzaWduYWwuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZWFybHkgZXhpdFxuICAgIH0gZWxzZSB7XG4gICAgICBybmcgPSBbMCwgZGVmLnJhbmdlXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nWzBdID0gZGVmLnJhbmdlTWluLnNpZ25hbCA/IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZU1pbikgOiBkZWYucmFuZ2VNaW47XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nW3JuZy5sZW5ndGgtMV0gPSBkZWYucmFuZ2VNYXguc2lnbmFsID8gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWF4KSA6IGRlZi5yYW5nZU1heDtcbiAgfVxuICBcbiAgaWYgKGRlZi5yZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmV2ID0gZGVmLnJldmVyc2U7XG4gICAgaWYgKGRsLmlzT2JqZWN0KHJldikpIHtcbiAgICAgIHJldiA9IGRsLmFjY2Vzc29yKHJldi5maWVsZCkoZ3JvdXAuZGF0dW0pO1xuICAgIH1cbiAgICBpZiAocmV2KSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICB9XG4gIFxuICByZXR1cm4gcm5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlOyIsInZhciB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2FsY0JvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZHVyYXRpb24sIGVhc2UpIHtcbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDUwMDtcbiAgdGhpcy5lYXNlID0gZWFzZSAmJiBkMy5lYXNlKGVhc2UpIHx8IGQzLmVhc2UoXCJjdWJpYy1pbi1vdXRcIik7XG4gIHRoaXMudXBkYXRlcyA9IHtuZXh0OiBudWxsfTtcbn1cblxudmFyIHByb3RvdHlwZSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG52YXIgc2tpcCA9IHtcbiAgXCJ0ZXh0XCI6IDEsXG4gIFwidXJsXCI6ICAxXG59O1xuXG5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihpdGVtLCB2YWx1ZXMsIHN0YW1wKSB7XG4gIHZhciBrZXksIGN1cnIsIG5leHQsIGludGVycCwgbGlzdCA9IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgY3VyciA9IGl0ZW1ba2V5XTtcbiAgICBuZXh0ID0gdmFsdWVzW2tleV07ICAgICAgXG4gICAgaWYgKGN1cnIgIT09IG5leHQpIHtcbiAgICAgIGlmIChza2lwW2tleV0gfHwgY3VyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNraXAgaW50ZXJwb2xhdGlvbiBmb3Igc3BlY2lmaWMga2V5cyBvciB1bmRlZmluZWQgc3RhcnQgdmFsdWVzXG4gICAgICAgIHR1cGxlLnNldChpdGVtLCBrZXksIG5leHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3VyciA9PT0gXCJudW1iZXJcIiAmJiAhaXNGaW5pdGUoY3VycikpIHtcbiAgICAgICAgLy8gZm9yIE5hTiBvciBpbmZpbml0ZSBudW1lcmljIHZhbHVlcywgc2tpcCB0byBmaW5hbCB2YWx1ZVxuICAgICAgICB0dXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBsb29rdXAgaW50ZXJwb2xhdG9yXG4gICAgICAgIGludGVycCA9IGQzLmludGVycG9sYXRlKGN1cnIsIG5leHQpO1xuICAgICAgICBpbnRlcnAucHJvcGVydHkgPSBrZXk7XG4gICAgICAgIChsaXN0IHx8IChsaXN0PVtdKSkucHVzaChpbnRlcnApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsaXN0ID09PSBudWxsICYmIGl0ZW0uc3RhdHVzID09PSBDLkVYSVQpIHtcbiAgICBsaXN0ID0gW107IC8vIGVuc3VyZSBleGl0aW5nIGl0ZW1zIGFyZSBpbmNsdWRlZFxuICB9XG5cbiAgaWYgKGxpc3QgIT0gbnVsbCkge1xuICAgIGxpc3QuaXRlbSA9IGl0ZW07XG4gICAgbGlzdC5lYXNlID0gaXRlbS5tYXJrLmVhc2UgfHwgdGhpcy5lYXNlO1xuICAgIGxpc3QubmV4dCA9IHRoaXMudXBkYXRlcy5uZXh0O1xuICAgIHRoaXMudXBkYXRlcy5uZXh0ID0gbGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB0ID0gdGhpcywgcHJldiA9IHQudXBkYXRlcywgY3VyciA9IHByZXYubmV4dDtcbiAgZm9yICg7IGN1cnIhPW51bGw7IHByZXY9Y3VyciwgY3Vycj1wcmV2Lm5leHQpIHtcbiAgICBpZiAoY3Vyci5pdGVtLnN0YXR1cyA9PT0gQy5FWElUKSBjdXJyLnJlbW92ZSA9IHRydWU7XG4gIH1cbiAgdC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBkMy50aW1lcihmdW5jdGlvbihlbGFwc2VkKSB7IHJldHVybiBzdGVwLmNhbGwodCwgZWxhcHNlZCk7IH0pO1xufTtcblxuZnVuY3Rpb24gc3RlcChlbGFwc2VkKSB7XG4gIHZhciBsaXN0ID0gdGhpcy51cGRhdGVzLCBwcmV2ID0gbGlzdCwgY3VyciA9IHByZXYubmV4dCxcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbixcbiAgICAgIGl0ZW0sIGRlbGF5LCBmLCBlLCBpLCBuLCBzdG9wID0gdHJ1ZTtcblxuICBmb3IgKDsgY3VyciE9bnVsbDsgcHJldj1jdXJyLCBjdXJyPXByZXYubmV4dCkge1xuICAgIGl0ZW0gPSBjdXJyLml0ZW07XG4gICAgZGVsYXkgPSBpdGVtLmRlbGF5IHx8IDA7XG5cbiAgICBmID0gKGVsYXBzZWQgLSBkZWxheSkgLyBkdXJhdGlvbjtcbiAgICBpZiAoZiA8IDApIHsgc3RvcCA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGlmIChmID4gMSkgZiA9IDE7XG4gICAgZSA9IGN1cnIuZWFzZShmKTtcblxuICAgIGZvciAoaT0wLCBuPWN1cnIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaXRlbVtjdXJyW2ldLnByb3BlcnR5XSA9IGN1cnJbaV0oZSk7XG4gICAgfVxuICAgIGl0ZW0udG91Y2goKTtcbiAgICBjYWxjQm91bmRzLml0ZW0oaXRlbSk7XG5cbiAgICBpZiAoZiA9PT0gMSkge1xuICAgICAgaWYgKGN1cnIucmVtb3ZlKSBpdGVtLnJlbW92ZSgpO1xuICAgICAgcHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuICAgICAgY3VyciA9IHByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhbGxiYWNrKCk7XG4gIHJldHVybiBzdG9wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgdHBsID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBwYXJzZU1hcmsgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrJyk7XG5cbmZ1bmN0aW9uIGF4cyhtb2RlbCkge1xuICB2YXIgc2NhbGUsXG4gICAgICBvcmllbnQgPSBjb25maWcuYXhpcy5vcmllbnQsXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgdGl0bGVPZmZzZXQgPSBjb25maWcuYXhpcy50aXRsZU9mZnNldCxcbiAgICAgIGF4aXNEZWYgPSB7fSxcbiAgICAgIGxheWVyID0gXCJmcm9udFwiLFxuICAgICAgZ3JpZCA9IGZhbHNlLFxuICAgICAgdGl0bGUgPSBudWxsLFxuICAgICAgdGlja01ham9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja01pbm9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja0VuZFNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tQYWRkaW5nID0gY29uZmlnLmF4aXMucGFkZGluZyxcbiAgICAgIHRpY2tWYWx1ZXMgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdFN0cmluZyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTdWJkaXZpZGUgPSAwLFxuICAgICAgdGlja0FyZ3VtZW50cyA9IFtjb25maWcuYXhpcy50aWNrc10sXG4gICAgICBncmlkTGluZVN0eWxlID0ge30sXG4gICAgICB0aWNrTGFiZWxTdHlsZSA9IHt9LFxuICAgICAgbWFqb3JUaWNrU3R5bGUgPSB7fSxcbiAgICAgIG1pbm9yVGlja1N0eWxlID0ge30sXG4gICAgICB0aXRsZVN0eWxlID0ge30sXG4gICAgICBkb21haW5TdHlsZSA9IHt9LFxuICAgICAgbSA9IHsgLy8gQXhpcyBtYXJrcyBhcyByZWZlcmVuY2VzIGZvciB1cGRhdGVzXG4gICAgICAgIGdyaWRMaW5lczogbnVsbCxcbiAgICAgICAgbWFqb3JUaWNrczogbnVsbCxcbiAgICAgICAgbWlub3JUaWNrczogbnVsbCxcbiAgICAgICAgdGlja0xhYmVsczogbnVsbCxcbiAgICAgICAgZG9tYWluOiBudWxsLFxuICAgICAgICB0aXRsZTogbnVsbFxuICAgICAgfTtcblxuICB2YXIgYXhpcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGF4aXNEZWYudHlwZSA9IG51bGw7XG4gIH07XG5cbiAgYXhpcy5kZWYgPSBmdW5jdGlvbigpIHtcbiAgICBpZighYXhpc0RlZi50eXBlKSBheGlzX2RlZihzY2FsZSk7XG5cbiAgICAvLyB0aWNrIGZvcm1hdFxuICAgIHRpY2tGb3JtYXQgPSAhdGlja0Zvcm1hdFN0cmluZyA/IG51bGwgOiAoKHNjYWxlLnR5cGUgPT09ICd0aW1lJylcbiAgICAgID8gZDMudGltZS5mb3JtYXQodGlja0Zvcm1hdFN0cmluZylcbiAgICAgIDogZDMuZm9ybWF0KHRpY2tGb3JtYXRTdHJpbmcpKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICAvLyBXZSBkb24ndCBfcmVhbGx5XyBuZWVkIHRvIG1vZGVsIHRoZXNlIGFzIHR1cGxlcyBhcyBubyBmdXJ0aGVyXG4gICAgLy8gZGF0YSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLiBTbyB3ZSBvcHRpbWl6ZSBmb3IgYSBoaWdoIGNodXJuIHJhdGUuIFxuICAgIHZhciBpbmplc3QgPSBmdW5jdGlvbihkKSB7IHJldHVybiB7ZGF0YTogZH07IH07XG4gICAgdmFyIG1ham9yID0gdGlja1ZhbHVlcyA9PSBudWxsXG4gICAgICA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKVxuICAgICAgOiB0aWNrVmFsdWVzO1xuICAgIHZhciBtaW5vciA9IHZnX2F4aXNTdWJkaXZpZGUoc2NhbGUsIG1ham9yLCB0aWNrU3ViZGl2aWRlKS5tYXAoaW5qZXN0KTtcbiAgICBtYWpvciA9IG1ham9yLm1hcChpbmplc3QpO1xuICAgIHZhciBmbXQgPSB0aWNrRm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiB0aWNrRm9ybWF0O1xuICAgIG1ham9yLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkLmxhYmVsID0gZm10KGQuZGF0YSk7IH0pO1xuICAgIHZhciB0ZGF0YSA9IHRpdGxlID8gW3RpdGxlXS5tYXAoaW5qZXN0KSA6IFtdO1xuXG4gICAgYXhpc0RlZi5tYXJrc1swXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBncmlkID8gbWFqb3IgOiBbXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1ham9yOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWlub3I7IH07XG4gICAgYXhpc0RlZi5tYXJrc1szXS5mcm9tID0gYXhpc0RlZi5tYXJrc1sxXS5mcm9tO1xuICAgIGF4aXNEZWYubWFya3NbNF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gWzFdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbNV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgYXhpc0RlZi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgYXhpc0RlZi5vcmllbnQgPSBvcmllbnQ7XG4gICAgYXhpc0RlZi5sYXllciA9IGxheWVyO1xuICAgIHJldHVybiBheGlzRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGF4aXNfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgc2NhbGUgbWFwcGluZ1xuICAgIHZhciBuZXdTY2FsZSwgb2xkU2NhbGUsIHJhbmdlO1xuICAgIGlmIChzY2FsZS50eXBlID09PSBcIm9yZGluYWxcIikge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjUgKyBzY2FsZS5yYW5nZUJhbmQoKS8yfTtcbiAgICAgIG9sZFNjYWxlID0gbmV3U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUsIG9mZnNldDogMC41fTtcbiAgICAgIG9sZFNjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUrXCI6cHJldlwiLCBvZmZzZXQ6IDAuNX07XG4gICAgfVxuICAgIHJhbmdlID0gdmdfYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpO1xuXG4gICAgLy8gc2V0dXAgYXhpcyBtYXJrc1xuICAgIGlmICghbS5ncmlkTGluZXMpICBtLmdyaWRMaW5lcyAgPSB2Z19heGlzVGlja3MoKTtcbiAgICBpZiAoIW0ubWFqb3JUaWNrcykgbS5tYWpvclRpY2tzID0gdmdfYXhpc1RpY2tzKCk7XG4gICAgaWYgKCFtLm1pbm9yVGlja3MpIG0ubWlub3JUaWNrcyA9IHZnX2F4aXNUaWNrcygpO1xuICAgIGlmICghbS50aWNrTGFiZWxzKSBtLnRpY2tMYWJlbHMgPSB2Z19heGlzVGlja0xhYmVscygpO1xuICAgIGlmICghbS5kb21haW4pIG0uZG9tYWluID0gdmdfYXhpc0RvbWFpbigpO1xuICAgIGlmICghbS50aXRsZSkgIG0udGl0bGUgID0gdmdfYXhpc1RpdGxlKCk7XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2UgPSB7dmFsdWU6IGNvbmZpZy5heGlzLmdyaWRDb2xvcn07XG5cbiAgICAvLyBleHRlbmQgYXhpcyBtYXJrcyBiYXNlZCBvbiBheGlzIG9yaWVudGF0aW9uXG4gICAgdmdfYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5ncmlkTGluZXMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgSW5maW5pdHkpO1xuICAgIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWFqb3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplKTtcbiAgICB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1pbm9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01pbm9yU2l6ZSk7XG4gICAgdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbS50aWNrTGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUsIHRpY2tQYWRkaW5nKTtcblxuICAgIHZnX2F4aXNEb21haW5FeHRlbmQob3JpZW50LCBtLmRvbWFpbiwgcmFuZ2UsIHRpY2tFbmRTaXplKTtcbiAgICB2Z19heGlzVGl0bGVFeHRlbmQob3JpZW50LCBtLnRpdGxlLCByYW5nZSwgdGl0bGVPZmZzZXQpOyAvLyBUT0RPIGdldCBvZmZzZXRcbiAgICBcbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JpZExpbmVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWFqb3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWFqb3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1pbm9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1pbm9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aWNrTGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB0aWNrTGFiZWxTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLCBkb21haW5TdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGl0bGUucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuXG4gICAgdmFyIG1hcmtzID0gW20uZ3JpZExpbmVzLCBtLm1ham9yVGlja3MsIG0ubWlub3JUaWNrcywgbS50aWNrTGFiZWxzLCBtLmRvbWFpbiwgbS50aXRsZV07XG4gICAgZGwuZXh0ZW5kKGF4aXNEZWYsIHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHsgXG4gICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19heGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGVuY29kZTogdmdfYXhpc1VwZGF0ZSxcbiAgICAgICAgICBzY2FsZXM6IFtzY2FsZS5zY2FsZU5hbWVdLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBkYXRhOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBheGlzRGVmLm1hcmtzID0gbWFya3MubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pO1xuICB9O1xuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgaWYgKHNjYWxlICE9PSB4KSB7IHNjYWxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSB4KSB7XG4gICAgICBvcmllbnQgPSB4IGluIHZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBjb25maWcuYXhpcy5vcmllbnQ7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIGlmICh0aXRsZSAhPT0geCkgeyB0aXRsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50cztcbiAgICB0aWNrQXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0U3RyaW5nO1xuICAgIGlmICh0aWNrRm9ybWF0U3RyaW5nICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrTWFqb3JTaXplO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgIG1ham9yID0gK3gsXG4gICAgICAgIG1pbm9yID0gbiA+IDEgPyAreSA6IHRpY2tNYWpvclNpemUsXG4gICAgICAgIGVuZCAgID0gbiA+IDAgPyArYXJndW1lbnRzW25dIDogdGlja01ham9yU2l6ZTtcblxuICAgIGlmICh0aWNrTWFqb3JTaXplICE9PSBtYWpvciB8fFxuICAgICAgICB0aWNrTWlub3JTaXplICE9PSBtaW5vciB8fFxuICAgICAgICB0aWNrRW5kU2l6ZSAhPT0gZW5kKSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHRpY2tNYWpvclNpemUgPSBtYWpvcjtcbiAgICB0aWNrTWlub3JTaXplID0gbWlub3I7XG4gICAgdGlja0VuZFNpemUgPSBlbmQ7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tTdWJkaXZpZGU7XG4gICAgdGlja1N1YmRpdmlkZSA9ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGRsLmlzT2JqZWN0KHgpID8geCA6ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgaWYgKHRpY2tQYWRkaW5nICE9PSAreCkgeyB0aWNrUGFkZGluZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZU9mZnNldDtcbiAgICBpZiAodGl0bGVPZmZzZXQgIT09ICt4KSB7IHRpdGxlT2Zmc2V0ID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmxheWVyID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxheWVyO1xuICAgIGlmIChsYXllciAhPT0geCkgeyBsYXllciA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmdyaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZDtcbiAgICBpZiAoZ3JpZCAhPT0geCkgeyBncmlkID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyaWRMaW5lU3R5bGU7XG4gICAgaWYgKGdyaWRMaW5lU3R5bGUgIT09IHgpIHsgZ3JpZExpbmVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFqb3JUaWNrU3R5bGU7XG4gICAgaWYgKG1ham9yVGlja1N0eWxlICE9PSB4KSB7IG1ham9yVGlja1N0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW5vclRpY2tTdHlsZTtcbiAgICBpZiAobWlub3JUaWNrU3R5bGUgIT09IHgpIHsgbWlub3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tMYWJlbFN0eWxlO1xuICAgIGlmICh0aWNrTGFiZWxTdHlsZSAhPT0geCkgeyB0aWNrTGFiZWxTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVN0eWxlO1xuICAgIGlmICh0aXRsZVN0eWxlICE9PSB4KSB7IHRpdGxlU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpblN0eWxlO1xuICAgIGlmIChkb21haW5TdHlsZSAhPT0geCkgeyBkb21haW5TdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgXG4gIGF4aXMucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gYXhpcztcbn07XG5cbnZhciB2Z19heGlzT3JpZW50cyA9IHt0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19heGlzU3ViZGl2aWRlKHNjYWxlLCB0aWNrcywgbSkge1xuICBzdWJ0aWNrcyA9IFtdO1xuICBpZiAobSAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGV4dGVudCA9IHZnX2F4aXNTY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksXG4gICAgICAgIHN1YnRpY2tzLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0aWNrcy5sZW5ndGgsXG4gICAgICAgIGQgPSAodGlja3NbMV0gLSB0aWNrc1swXSkgLyArK20sXG4gICAgICAgIGosXG4gICAgICAgIHY7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGZvciAoaiA9IG07IC0taiA+IDA7KSB7XG4gICAgICAgIGlmICgodiA9ICt0aWNrc1tpXSAtIGogKiBkKSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICBzdWJ0aWNrcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoLS1pLCBqID0gMDsgKytqIDwgbSAmJiAodiA9ICt0aWNrc1tpXSArIGogKiBkKSA8IGV4dGVudFsxXTspIHtcbiAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJ0aWNrcztcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1NjYWxlRXh0ZW50KGRvbWFpbikge1xuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNTY2FsZVJhbmdlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudFxuICAgID8gc2NhbGUucmFuZ2VFeHRlbnQoKVxuICAgIDogdmdfYXhpc1NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xufVxuXG52YXIgdmdfYXhpc0FsaWduID0ge1xuICBib3R0b206IFwiY2VudGVyXCIsXG4gIHRvcDogXCJjZW50ZXJcIixcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCJcbn07XG5cbnZhciB2Z19heGlzQmFzZWxpbmUgPSB7XG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiLFxuICBsZWZ0OiBcIm1pZGRsZVwiLFxuICByaWdodDogXCJtaWRkbGVcIlxufTtcblxuZnVuY3Rpb24gdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUsIHBhZCkge1xuICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCkgKyBwYWQ7XG4gIGlmIChvcmllbnQgPT09IFwibGVmdFwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIHNpemUgKj0gLTE7XG4gIH0gIFxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogb2xkU2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IG5ld1NjYWxlLFxuICAgICAgeToge3ZhbHVlOiBzaXplfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6IFwiY2VudGVyXCJ9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogdmdfYXhpc0Jhc2VsaW5lW29yaWVudF19XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogb2xkU2NhbGUsXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG5ld1NjYWxlLFxuICAgICAgYWxpZ246IHt2YWx1ZTogdmdfYXhpc0FsaWduW29yaWVudF19LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCB0aWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCBzaXplKSB7XG4gIHZhciBzaWduID0gKG9yaWVudCA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSA/IC0xIDogMTtcbiAgaWYgKHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgc2l6ZSA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKVxuICAgICAgPyB7ZmllbGQ6IHtncm91cDogXCJoZWlnaHRcIiwgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn1cbiAgICAgIDoge2ZpZWxkOiB7Z3JvdXA6IFwid2lkdGhcIiwgIGxldmVsOiAyfSwgbXVsdDogLXNpZ259O1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB7dmFsdWU6IHNpZ24gKiBzaXplfTtcbiAgfVxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAgb2xkU2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAgbmV3U2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgIH0pOyAgICAgICAgXG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgb2xkU2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgbmV3U2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5leGl0LCB7XG4gICAgICB5OiAgbmV3U2NhbGUsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlRXh0ZW5kKG9yaWVudCwgdGl0bGUsIHJhbmdlLCBvZmZzZXQpIHtcbiAgdmFyIG1pZCA9IH5+KChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDIpLFxuICAgICAgc2lnbiA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikgPyAtMSA6IDE7XG4gIFxuICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBtaWR9LFxuICAgICAgeToge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICB5OiB7dmFsdWU6IG1pZH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAtOTB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc0RvbWFpbkV4dGVuZChvcmllbnQsIGRvbWFpbiwgcmFuZ2UsIHNpemUpIHtcbiAgdmFyIHBhdGg7XG4gIGlmIChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikge1xuICAgIHNpemUgPSAtMSAqIHNpemU7XG4gIH1cbiAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICBwYXRoID0gXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2l6ZSArIFwiVjBIXCIgKyByYW5nZVsxXSArIFwiVlwiICsgc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gXCJNXCIgKyBzaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2l6ZTtcbiAgfVxuICBkb21haW4ucHJvcGVydGllcy51cGRhdGUucGF0aCA9IHt2YWx1ZTogcGF0aH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNVcGRhdGUoaXRlbSwgZ3JvdXAsIHRyYW5zLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykge1xuICB2YXIgbyA9IHRyYW5zID8ge30gOiBpdGVtLFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHdpZHRoICA9IGdyb3VwLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZ3JvdXAuaGVpZ2h0OyAvLyBUT0RPIGZhbGxiYWNrIHRvIGdsb2JhbCB3LGg/XG5cbiAgaWYgKGRsLmlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSAtZ3JvdXAuc2NhbGUob2Zmc2V0LnNjYWxlKShvZmZzZXQudmFsdWUpO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFwibGVmdFwiOiAgIHsgdHBsLnNldChvLCAneCcsIC1vZmZzZXQpOyB0cGwuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgY2FzZSBcInJpZ2h0XCI6ICB7IHRwbC5zZXQobywgJ3gnLCB3aWR0aCArIG9mZnNldCk7IHRwbC5zZXQobywgJ3knLCAwKTsgYnJlYWs7IH1cbiAgICBjYXNlIFwiYm90dG9tXCI6IHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgaGVpZ2h0ICsgb2Zmc2V0KTsgYnJlYWs7IH1cbiAgICBjYXNlIFwidG9wXCI6ICAgIHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgLW9mZnNldCk7IGJyZWFrOyB9XG4gICAgZGVmYXVsdDogICAgICAgeyB0cGwuc2V0KG8sICd4JywgMCk7IHRwbC5zZXQobywgJ3knLCAwKTsgfVxuICB9XG5cbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpY2tzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicnVsZVwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHN0cm9rZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrV2lkdGh9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja0xhYmVscygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbEZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250U2l6ZX0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJsYWJlbFwifVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250V2VpZ2h0fSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUNvbG9yfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogXCJjZW50ZXJcIn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IFwibWlkZGxlXCJ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwiZGF0YVwifVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNEb21haW4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwYXRoXCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgeToge3ZhbHVlOiAwLjV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc1dpZHRofVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhzO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgR3JvdXBCeSA9IHJlcXVpcmUoJy4vR3JvdXBCeScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksIFxuICAgIG1lYXMgPSByZXF1aXJlKCcuL21lYXN1cmVzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEFnZ3JlZ2F0ZShncmFwaCkge1xuICBHcm91cEJ5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZ3JvdXBfYnk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJjb3VudFwiOiAgICBcImNvdW50XCIsXG4gICAgXCJhdmdcIjogICAgICBcImF2Z1wiLFxuICAgIFwibWluXCI6ICAgICAgXCJtaW5cIixcbiAgICBcIm1heFwiOiAgICAgIFwibWF4XCIsXG4gICAgXCJzdW1cIjogICAgICBcInN1bVwiLFxuICAgIFwibWVhblwiOiAgICAgXCJtZWFuXCIsXG4gICAgXCJ2YXJcIjogICAgICBcInZhclwiLFxuICAgIFwic3RkZXZcIjogICAgXCJzdGRldlwiLFxuICAgIFwidmFycFwiOiAgICAgXCJ2YXJwXCIsXG4gICAgXCJzdGRldnBcIjogICBcInN0ZGV2cFwiLFxuICAgIFwibWVkaWFuXCI6ICAgXCJtZWRpYW5cIlxuICB9O1xuXG4gIC8vIEFnZ3JlZ2F0b3JzIHBhcmFtZXRlciBoYW5kbGVkIG1hbnVhbGx5LlxuICB0aGlzLl9maWVsZHNEZWYgICA9IG51bGw7XG4gIHRoaXMuX0FnZ3JlZ2F0b3JzID0gbnVsbDtcbiAgdGhpcy5fc2luZ2xldG9uICAgPSBmYWxzZTsgIC8vIElmIHRydWUsIGFsbCBmaWVsZHMgYWdncmVnYXRlZCB3aXRoaW4gYSBzaW5nbGUgbW9ub2lkXG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChBZ2dyZWdhdGUucHJvdG90eXBlID0gbmV3IEdyb3VwQnkoKSk7XG5cbnByb3RvLmZpZWxkcyA9IHtcbiAgc2V0OiBmdW5jdGlvbih0cmFuc2Zvcm0sIGZpZWxkcykge1xuICAgIHZhciBpLCBsZW4sIGYsIHNpZ25hbHMgPSB7fTtcbiAgICBmb3IoaT0wLCBsZW49ZmllbGRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgZiA9IGZpZWxkc1tpXTtcbiAgICAgIGlmKGYubmFtZS5zaWduYWwpIHNpZ25hbHNbZi5uYW1lLnNpZ25hbF0gPSAxO1xuICAgICAgZGwuYXJyYXkoZi5vcHMpLmZvckVhY2goZnVuY3Rpb24obyl7IGlmKG8uc2lnbmFsKSBzaWduYWxzW28uc2lnbmFsXSA9IDEgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtLl9maWVsZHNEZWYgPSBmaWVsZHM7XG4gICAgdHJhbnNmb3JtLl9BZ2dyZWdhdG9ycyA9IG51bGw7XG4gICAgdHJhbnNmb3JtLmFnZ3MoKTtcbiAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLlNJR05BTFMsIGRsLmtleXMoc2lnbmFscykpO1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH1cbn07XG5cbnByb3RvLnNpbmdsZXRvbiA9IGZ1bmN0aW9uKGMpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaW5nbGV0b247XG4gIHRoaXMuX3NpbmdsZXRvbiA9IGM7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uYWdncyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcyxcbiAgICAgIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICBmaWVsZHMgPSB0aGlzLl9maWVsZHNEZWYsXG4gICAgICBhZ2dzID0gdGhpcy5fQWdncmVnYXRvcnMsXG4gICAgICBmLCBpLCBrLCBuYW1lLCBvcHMsIG1lYXN1cmVzO1xuXG4gIGlmKGFnZ3MpIHJldHVybiBhZ2dzO1xuICBlbHNlIGFnZ3MgPSB0aGlzLl9BZ2dyZWdhdG9ycyA9IFtdOyBcblxuICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZiA9IGZpZWxkc1tpXTtcbiAgICBpZiAoZi5vcHMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgIG5hbWUgPSBmLm5hbWUuc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKGYubmFtZS5zaWduYWwpIDogZi5uYW1lO1xuICAgIG9wcyAgPSBkbC5hcnJheShmLm9wcy5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoZi5vcHMuc2lnbmFsKSA6IGYub3BzKTtcbiAgICBtZWFzdXJlcyA9IG9wcy5tYXAoZnVuY3Rpb24oYSkge1xuICAgICAgYSA9IGEuc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKGEuc2lnbmFsKSA6IGE7XG4gICAgICByZXR1cm4gbWVhc1thXShuYW1lICsgJ18nICsgdHJhbnNmb3JtLl9vdXRwdXRbYV0pO1xuICAgIH0pO1xuICAgIGFnZ3MucHVzaCh7XG4gICAgICBhY2Nlc3NvcjogZGwuYWNjZXNzb3IobmFtZSksXG4gICAgICBmaWVsZDogdGhpcy5fc2luZ2xldG9uID8gQy5TSU5HTEVUT04gOiBuYW1lLFxuICAgICAgbWVhc3VyZXM6IG1lYXMuY3JlYXRlKG1lYXN1cmVzKVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFnZ3M7XG59O1xuXG5wcm90by5fcmVzZXQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0KSB7XG4gIHRoaXMuX0FnZ3JlZ2F0b3JzID0gbnVsbDsgLy8gcmVidWlsZCBhZ2dyZWdhdG9yc1xuICB0aGlzLmFnZ3MoKTtcbiAgcmV0dXJuIEdyb3VwQnkucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMsIGlucHV0LCBvdXRwdXQpO1xufTtcblxucHJvdG8uX2tleXMgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0aGlzLl9nYi5maWVsZHMubGVuZ3RoID8gXG4gICAgR3JvdXBCeS5wcm90b3R5cGUuX2tleXMuY2FsbCh0aGlzLCB4KSA6IHtrZXlzOiBbXSwga2V5OiBcIlwifTtcbn07XG5cbnByb3RvLl9uZXdfY2VsbCA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fbmV3X2NlbGwuY2FsbCh0aGlzLCB4LCBrKSxcbiAgICAgIGFnZ3MgPSB0aGlzLmFnZ3MoKSxcbiAgICAgIGkgPSAwLCBsZW4gPSBhZ2dzLmxlbmd0aCwgXG4gICAgICBhZ2c7XG5cbiAgZm9yKDsgaTxsZW47IGkrKykge1xuICAgIGFnZyA9IGFnZ3NbaV07XG4gICAgY2VsbFthZ2cuZmllbGRdID0gbmV3IGFnZy5tZWFzdXJlcyhjZWxsLCBjZWxsLnRwbCk7XG4gIH1cblxuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3MgPSB0aGlzLmFnZ3MoKSxcbiAgICAgIGkgPSAwLCBsZW4gPSBhZ2dzLmxlbmd0aCxcbiAgICAgIGFnZztcblxuICBjLmNudCsrO1xuICBmb3IoOyBpPGxlbjsgaSsrKSB7XG4gICAgYWdnID0gYWdnc1tpXTtcbiAgICBjW2FnZy5maWVsZF0uYWRkKGFnZy5hY2Nlc3Nvcih4KSk7XG4gIH1cbiAgYy5mbGcgfD0gQy5NT0RfQ0VMTDtcbn07XG5cbnByb3RvLl9yZW0gPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3MgPSB0aGlzLmFnZ3MoKSxcbiAgICAgIGkgPSAwLCBsZW4gPSBhZ2dzLmxlbmd0aCxcbiAgICAgIGFnZztcblxuICBjLmNudC0tO1xuICBmb3IoOyBpPGxlbjsgaSsrKSB7XG4gICAgYWdnID0gYWdnc1tpXTtcbiAgICBjW2FnZy5maWVsZF0ucmVtKGFnZy5hY2Nlc3Nvcih4KSk7XG4gIH1cbiAgYy5mbGcgfD0gQy5NT0RfQ0VMTDtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiYWdncmVnYXRlXCJdKTtcblxuICB0aGlzLl9nYiA9IHRoaXMuZ3JvdXBfYnkuZ2V0KHRoaXMuX2dyYXBoKTtcblxuICB2YXIgb3V0cHV0ID0gR3JvdXBCeS5wcm90b3R5cGUudHJhbnNmb3JtLmNhbGwodGhpcywgaW5wdXQsIHJlc2V0KSxcbiAgICAgIGFnZ3MgPSB0aGlzLmFnZ3MoKSxcbiAgICAgIGxlbiA9IGFnZ3MubGVuZ3RoLFxuICAgICAgaSwgaywgYztcblxuICBmb3IoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGMgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZighYykgY29udGludWU7XG4gICAgZm9yKGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgY1thZ2dzW2ldLmZpZWxkXS5zZXQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdGU7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvQ29sbGVjdG9yJyk7XG5cbmZ1bmN0aW9uIEJhdGNoVHJhbnNmb3JtKCkge1xufVxuXG52YXIgcHJvdG8gPSAoQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gTWF0ZXJpYWxpemUgdGhlIGN1cnJlbnQgZGF0YXNvdXJjZS5cbiAgLy8gVE9ETzogZWZmaWNpZW50bHkgc2hhcmUgY29sbGVjdG9yc1xuICB0aGlzLl9jb2xsZWN0b3IuZXZhbHVhdGUoaW5wdXQpO1xuICB2YXIgZGF0YSA9IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCk7XG4gIHJldHVybiB0aGlzLmJhdGNoVHJhbnNmb3JtKGlucHV0LCBkYXRhKTtcbn07XG5cbnByb3RvLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmF0Y2hUcmFuc2Zvcm07XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIEJpbihncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDoge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgbWluOiB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBtYXg6IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIHN0ZXA6IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIG1heGJpbnM6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDIwfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XCJiaW5cIjogXCJiaW5cIn07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoQmluLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LmJpbjtcbiAgICAgIFxuICB2YXIgYiA9IGRsLmJpbih7XG4gICAgbWluOiB0aGlzLm1pbi5nZXQoKSxcbiAgICBtYXg6IHRoaXMubWF4LmdldCgpLFxuICAgIHN0ZXA6IHRoaXMuc3RlcC5nZXQoKSxcbiAgICBtYXhiaW5zOiB0aGlzLm1heGJpbnMuZ2V0KClcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGQpIHtcbiAgICB2YXIgdiA9IHRyYW5zZm9ybS5maWVsZC5nZXQoKS5hY2Nlc3NvcihkKTtcbiAgICB2ID0gdiA9PSBudWxsID8gbnVsbFxuICAgICAgOiBiLnN0YXJ0ICsgYi5zdGVwICogfn4oKHYgLSBiLnN0YXJ0KSAvIGIuc3RlcCk7XG4gICAgdHVwbGUuc2V0KGQsIG91dHB1dCwgdiwgaW5wdXQuc3RhbXApO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW47IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvQ29sbGVjdG9yJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpO1xuXG5mdW5jdGlvbiBDcm9zcyhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICB3aXRoOiB7dHlwZTogXCJkYXRhXCJ9LFxuICAgIGRpYWdvbmFsOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcInRydWVcIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1wibGVmdFwiOiBcImFcIiwgXCJyaWdodFwiOiBcImJcIn07XG4gIHRoaXMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpO1xuICB0aGlzLl9sYXN0UmVtICA9IG51bGw7IC8vIE1vc3QgcmVjZW50IHN0YW1wIHRoYXQgcmVtIG9jY3VyZWQuIFxuICB0aGlzLl9sYXN0V2l0aCA9IG51bGw7IC8vIExhc3QgdGltZSB3ZSBjcm9zc2VkIHcvd2l0aGRzLlxuICB0aGlzLl9pZHMgICA9IHt9O1xuICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKENyb3NzLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbi8vIEVhY2ggY2FjaGVkIGluY29taW5nIHR1cGxlIGFsc28gaGFzIGEgc3RhbXAgdG8gdHJhY2sgaWYgd2UgbmVlZCB0byBkb1xuLy8gbGF6eSBmaWx0ZXJpbmcgb2YgcmVtb3ZlZCB0dXBsZXMuXG5mdW5jdGlvbiBjYWNoZSh4LCB0KSB7XG4gIHZhciBjID0gdGhpcy5fY2FjaGVbeC5faWRdID0gdGhpcy5fY2FjaGVbeC5faWRdIHx8IHtjOiBbXSwgczogdGhpcy5fc3RhbXB9O1xuICBjLmMucHVzaCh0KTtcbn1cblxuZnVuY3Rpb24gYWRkKG91dHB1dCwgbGVmdCwgd2RhdGEsIGRpYWcsIHgpIHtcbiAgdmFyIGRhdGEgPSBsZWZ0ID8gd2RhdGEgOiB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpLCAvLyBMZWZ0IHR1cGxlcyBjcm9zcyB3L3JpZ2h0LlxuICAgICAgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgcHJldiAgPSB4Ll9wcmV2ICE9PSB1bmRlZmluZWQgPyBudWxsIDogdW5kZWZpbmVkLCBcbiAgICAgIHQsIHksIGlkO1xuXG4gIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICB5ID0gZGF0YVtpXTtcbiAgICBpZCA9IGxlZnQgPyB4Ll9pZCtcIl9cIit5Ll9pZCA6IHkuX2lkK1wiX1wiK3guX2lkO1xuICAgIGlmKHRoaXMuX2lkc1tpZF0pIGNvbnRpbnVlO1xuICAgIGlmKHguX2lkID09IHkuX2lkICYmICFkaWFnKSBjb250aW51ZTtcblxuICAgIHQgPSB0dXBsZS5pbmdlc3Qoe30sIHByZXYpO1xuICAgIHRbdGhpcy5fb3V0cHV0LmxlZnRdICA9IGxlZnQgPyB4IDogeTtcbiAgICB0W3RoaXMuX291dHB1dC5yaWdodF0gPSBsZWZ0ID8geSA6IHg7XG4gICAgb3V0cHV0LmFkZC5wdXNoKHQpO1xuICAgIGNhY2hlLmNhbGwodGhpcywgeCwgdCk7XG4gICAgY2FjaGUuY2FsbCh0aGlzLCB5LCB0KTtcbiAgICB0aGlzLl9pZHNbaWRdID0gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2Qob3V0cHV0LCBsZWZ0LCB4KSB7XG4gIHZhciBjcm9zcyA9IHRoaXMsXG4gICAgICBjID0gdGhpcy5fY2FjaGVbeC5faWRdO1xuXG4gIGlmKHRoaXMuX2xhc3RSZW0gPiBjLnMpIHsgIC8vIFJlbW92ZWQgdHVwbGVzIGhhdmVuJ3QgYmVlbiBmaWx0ZXJlZCB5ZXRcbiAgICBjLmMgPSBjLmMuZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciB0ID0geVtjcm9zcy5fb3V0cHV0W2xlZnQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIl1dO1xuICAgICAgcmV0dXJuIGNyb3NzLl9jYWNoZVt0Ll9pZF0gIT09IG51bGw7XG4gICAgfSk7XG4gICAgYy5zID0gdGhpcy5fbGFzdFJlbTtcbiAgfVxuXG4gIG91dHB1dC5tb2QucHVzaC5hcHBseShvdXRwdXQubW9kLCBjLmMpO1xufVxuXG5mdW5jdGlvbiByZW0ob3V0cHV0LCB4KSB7XG4gIG91dHB1dC5yZW0ucHVzaC5hcHBseShvdXRwdXQucmVtLCB0aGlzLl9jYWNoZVt4Ll9pZF0uYyk7XG4gIHRoaXMuX2NhY2hlW3guX2lkXSA9IG51bGw7XG4gIHRoaXMuX2xhc3RSZW0gPSB0aGlzLl9zdGFtcDtcbn1cblxuZnVuY3Rpb24gdXBGaWVsZHMoaW5wdXQsIG91dHB1dCkge1xuICBpZihpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5sZWZ0XSAgPSAxOyBcbiAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5yaWdodF0gPSAxO1xuICB9XG59XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJjcm9zc2luZ1wiXSk7XG5cbiAgLy8gTWF0ZXJpYWxpemUgdGhlIGN1cnJlbnQgZGF0YXNvdXJjZS4gVE9ETzogc2hhcmUgY29sbGVjdG9yc1xuICB0aGlzLl9jb2xsZWN0b3IuZXZhbHVhdGUoaW5wdXQpO1xuXG4gIHZhciB3ID0gdGhpcy53aXRoLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBkaWFnID0gdGhpcy5kaWFnb25hbC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgc2VsZkNyb3NzID0gKCF3Lm5hbWUpLFxuICAgICAgZGF0YSA9IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksXG4gICAgICB3b3V0cHV0ID0gc2VsZkNyb3NzID8gaW5wdXQgOiB3LnNvdXJjZS5sYXN0KCksXG4gICAgICB3ZGF0YSAgID0gc2VsZkNyb3NzID8gZGF0YSA6IHcuc291cmNlLnZhbHVlcygpLFxuICAgICAgb3V0cHV0ICA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgciA9IHJlbS5iaW5kKHRoaXMsIG91dHB1dCk7IFxuXG4gIGlucHV0LnJlbS5mb3JFYWNoKHIpO1xuICBpbnB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUsIHdkYXRhLCBkaWFnKSk7XG5cbiAgaWYoIXNlbGZDcm9zcyAmJiB3b3V0cHV0LnN0YW1wID4gdGhpcy5fbGFzdFdpdGgpIHtcbiAgICB3b3V0cHV0LnJlbS5mb3JFYWNoKHIpO1xuICAgIHdvdXRwdXQuYWRkLmZvckVhY2goYWRkLmJpbmQodGhpcywgb3V0cHV0LCBmYWxzZSwgZGF0YSwgZGlhZykpO1xuICAgIHdvdXRwdXQubW9kLmZvckVhY2gobW9kLmJpbmQodGhpcywgb3V0cHV0LCBmYWxzZSkpO1xuICAgIHVwRmllbGRzLmNhbGwodGhpcywgd291dHB1dCwgb3V0cHV0KTtcbiAgICB0aGlzLl9sYXN0V2l0aCA9IHdvdXRwdXQuc3RhbXA7XG4gIH1cblxuICAvLyBNb2RzIG5lZWQgdG8gY29tZSBhZnRlciBhbGwgcmVtb3ZhbHMgaGF2ZSBiZWVuIHJ1bi5cbiAgaW5wdXQubW9kLmZvckVhY2gobW9kLmJpbmQodGhpcywgb3V0cHV0LCB0cnVlKSk7XG4gIHVwRmllbGRzLmNhbGwodGhpcywgaW5wdXQsIG91dHB1dCk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3Jvc3M7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgR3JvdXBCeSA9IHJlcXVpcmUoJy4vR3JvdXBCeScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEZhY2V0KGdyYXBoKSB7XG4gIEdyb3VwQnkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtrZXlzOiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0gfSk7XG5cbiAgdGhpcy5fcGlwZWxpbmUgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGYWNldC5wcm90b3R5cGUgPSBuZXcgR3JvdXBCeSgpKTtcblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbihwaXBlbGluZSkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BpcGVsaW5lO1xuICB0aGlzLl9waXBlbGluZSA9IHBpcGVsaW5lO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLl9yZXNldCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgdmFyIGssIGM7XG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKCFjKSBjb250aW51ZTtcbiAgICBvdXRwdXQucmVtLnB1c2goYy50cGwpO1xuICAgIGMuZGVsZXRlKCk7XG4gIH1cbiAgdGhpcy5fY2VsbHMgPSB7fTtcbn07XG5cbnByb3RvLl9uZXdfdHVwbGUgPSBmdW5jdGlvbih4LCBrKSB7XG4gIHJldHVybiB0dXBsZS5pbmdlc3QoaywgbnVsbCk7XG59O1xuXG5wcm90by5fbmV3X2NlbGwgPSBmdW5jdGlvbih4LCBrKSB7XG4gIC8vIFJhdGhlciB0aGFuIHNoYXJpbmcgdGhlIHBpcGVsaW5lIGJldHdlZW4gYWxsIG5vZGVzLFxuICAvLyBnaXZlIGVhY2ggY2VsbCBpdHMgaW5kaXZpZHVhbCBwaXBlbGluZS4gVGhpcyBhbGxvd3NcbiAgLy8gZHluYW1pY2FsbHkgYWRkZWQgY29sbGVjdG9ycyB0byBkbyB0aGUgcmlnaHQgdGhpbmdcbiAgLy8gd2hlbiB3aXJpbmcgdXAgdGhlIHBpcGVsaW5lcy5cbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fbmV3X2NlbGwuY2FsbCh0aGlzLCB4LCBrKSxcbiAgICAgIHBpcGVsaW5lID0gdGhpcy5fcGlwZWxpbmUubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uY2xvbmUoKTsgfSksXG4gICAgICBmYWNldCA9IHRoaXMsXG4gICAgICB0ID0gY2VsbC50cGw7XG5cbiAgY2VsbC5kcyA9IHRoaXMuX2dyYXBoLmRhdGEoXCJ2Z19cIit0Ll9pZCwgcGlwZWxpbmUsIHQpO1xuICBjZWxsLmRlbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKHt9LCBbXCJkZWxldGluZyBjZWxsXCIsIGsua2V5XSk7XG4gICAgZmFjZXQucmVtb3ZlTGlzdGVuZXIocGlwZWxpbmVbMF0pO1xuICAgIGZhY2V0Ll9ncmFwaC5kaXNjb25uZWN0KHBpcGVsaW5lKTtcbiAgfTtcblxuICB0aGlzLmFkZExpc3RlbmVyKHBpcGVsaW5lWzBdKTtcblxuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gR3JvdXBCeS5wcm90b3R5cGUuX2FkZC5jYWxsKHRoaXMsIHgpO1xuICBjZWxsLmRzLl9pbnB1dC5hZGQucHVzaCh4KTtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oeCwgcmVzZXQpIHtcbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fbW9kLmNhbGwodGhpcywgeCwgcmVzZXQpO1xuICBpZighKGNlbGwuZmxnICYgQy5BRERfQ0VMTCkpIGNlbGwuZHMuX2lucHV0Lm1vZC5wdXNoKHgpOyAvLyBQcm9wYWdhdGUgdHVwbGVzXG4gIGNlbGwuZmxnIHw9IEMuTU9EX0NFTEw7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX3JlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fcmVtLmNhbGwodGhpcywgeCk7XG4gIGNlbGwuZHMuX2lucHV0LnJlbS5wdXNoKHgpO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiZmFjZXRpbmdcIl0pO1xuXG4gIHRoaXMuX2diID0gdGhpcy5rZXlzLmdldCh0aGlzLl9ncmFwaCk7XG5cbiAgdmFyIG91dHB1dCA9IEdyb3VwQnkucHJvdG90eXBlLnRyYW5zZm9ybS5jYWxsKHRoaXMsIGlucHV0LCByZXNldCksXG4gICAgICBrLCBjO1xuXG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKGMgPT0gbnVsbCkgY29udGludWU7XG4gICAgaWYoYy5jbnQgPT09IDApIHtcbiAgICAgIGMuZGVsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHByb3BhZ2F0ZSBzb3J0LCBzaWduYWxzLCBmaWVsZHMsIGV0Yy5cbiAgICAgIGNoYW5nZXNldC5jb3B5KGlucHV0LCBjLmRzLl9pbnB1dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXQ7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksIFxuICAgIGV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZS9leHByJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEZpbHRlcihncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHt0ZXN0OiB7dHlwZTogXCJleHByXCJ9IH0pO1xuXG4gIHRoaXMuX3NraXAgPSB7fTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGaWx0ZXIucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gdGVzdCh4KSB7XG4gIHJldHVybiBleHByLmV2YWwodGhpcy5fZ3JhcGgsIHRoaXMudGVzdC5nZXQodGhpcy5fZ3JhcGgpLCBcbiAgICB4LCBudWxsLCBudWxsLCBudWxsLCB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTKSk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiZmlsdGVyaW5nXCJdKTtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgc2tpcCA9IHRoaXMuX3NraXAsXG4gICAgICBmID0gdGhpcztcblxuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYgKHNraXBbeC5faWRdICE9PSAxKSBvdXRwdXQucmVtLnB1c2goeCk7XG4gICAgZWxzZSBza2lwW3guX2lkXSA9IDA7XG4gIH0pO1xuXG4gIGlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAodGVzdC5jYWxsKGYsIHgpKSBvdXRwdXQuYWRkLnB1c2goeCk7XG4gICAgZWxzZSBza2lwW3guX2lkXSA9IDE7XG4gIH0pO1xuXG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgYiA9IHRlc3QuY2FsbChmLCB4KSxcbiAgICAgICAgcyA9IChza2lwW3guX2lkXSA9PT0gMSk7XG4gICAgaWYgKGIgJiYgcykge1xuICAgICAgc2tpcFt4Ll9pZF0gPSAwO1xuICAgICAgb3V0cHV0LmFkZC5wdXNoKHgpO1xuICAgIH0gZWxzZSBpZiAoYiAmJiAhcykge1xuICAgICAgb3V0cHV0Lm1vZC5wdXNoKHgpO1xuICAgIH0gZWxzZSBpZiAoIWIgJiYgcykge1xuICAgICAgLy8gZG8gbm90aGluZywga2VlcCBza2lwIHRydWVcbiAgICB9IGVsc2UgeyAvLyAhYiAmJiAhc1xuICAgICAgb3V0cHV0LnJlbS5wdXNoKHgpO1xuICAgICAgc2tpcFt4Ll9pZF0gPSAxO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLCBcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksIFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpO1xuXG5mdW5jdGlvbiBGb2xkKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkczoge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9IFxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7a2V5OiBcImtleVwiLCB2YWx1ZTogXCJ2YWx1ZVwifTtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcblxuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSkucmV2aXNlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKEZvbGQucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gcnN0KGlucHV0LCBvdXRwdXQpIHsgXG4gIGZvcih2YXIgaWQgaW4gdGhpcy5fY2FjaGUpIG91dHB1dC5yZW0ucHVzaC5hcHBseShvdXRwdXQucmVtLCB0aGlzLl9jYWNoZVtpZF0pO1xuICB0aGlzLl9jYWNoZSA9IHt9O1xufTtcblxuZnVuY3Rpb24gZ2V0X3R1cGxlKHgsIGksIGxlbikge1xuICB2YXIgbGlzdCA9IHRoaXMuX2NhY2hlW3guX2lkXSB8fCAodGhpcy5fY2FjaGVbeC5faWRdID0gQXJyYXkobGVuKSk7XG4gIHJldHVybiBsaXN0W2ldIHx8IChsaXN0W2ldID0gdHVwbGUuZGVyaXZlKHgsIHguX3ByZXYpKTtcbn07XG5cbmZ1bmN0aW9uIGZuKGRhdGEsIGZpZWxkcywgYWNjZXNzb3JzLCBvdXQsIHN0YW1wKSB7XG4gIHZhciBpID0gMCwgZGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgaiwgZmxlbiA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICBkLCB0O1xuXG4gIGZvcig7IGk8ZGxlbjsgKytpKSB7XG4gICAgZCA9IGRhdGFbaV07XG4gICAgZm9yKGo9MDsgajxmbGVuOyArK2opIHtcbiAgICAgIHQgPSBnZXRfdHVwbGUuY2FsbCh0aGlzLCBkLCBqLCBmbGVuKTsgIFxuICAgICAgdHVwbGUuc2V0KHQsIHRoaXMuX291dHB1dC5rZXksIGZpZWxkc1tqXSk7XG4gICAgICB0dXBsZS5zZXQodCwgdGhpcy5fb3V0cHV0LnZhbHVlLCBhY2Nlc3NvcnNbal0oZCkpO1xuICAgICAgb3V0LnB1c2godCk7XG4gICAgfSAgICAgIFxuICB9XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImZvbGRpbmdcIl0pO1xuXG4gIHZhciBmb2xkID0gdGhpcyxcbiAgICAgIG9uID0gdGhpcy5maWVsZHMuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGZpZWxkcyA9IG9uLmZpZWxkcywgYWNjZXNzb3JzID0gb24uYWNjZXNzb3JzLFxuICAgICAgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgaWYocmVzZXQpIHJzdC5jYWxsKHRoaXMsIGlucHV0LCBvdXRwdXQpO1xuXG4gIGZuLmNhbGwodGhpcywgaW5wdXQuYWRkLCBmaWVsZHMsIGFjY2Vzc29ycywgb3V0cHV0LmFkZCwgaW5wdXQuc3RhbXApO1xuICBmbi5jYWxsKHRoaXMsIGlucHV0Lm1vZCwgZmllbGRzLCBhY2Nlc3NvcnMsIHJlc2V0ID8gb3V0cHV0LmFkZCA6IG91dHB1dC5tb2QsIGlucHV0LnN0YW1wKTtcbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIG91dHB1dC5yZW0ucHVzaC5hcHBseShvdXRwdXQucmVtLCBmb2xkLl9jYWNoZVt4Ll9pZF0pO1xuICAgIGZvbGQuX2NhY2hlW3guX2lkXSA9IG51bGw7XG4gIH0pO1xuXG4gIC8vIElmIHdlJ3JlIG9ubHkgcHJvcGFnYXRpbmcgdmFsdWVzLCBkb24ndCBtYXJrIGtleS92YWx1ZSBhcyB1cGRhdGVkLlxuICBpZihpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0LnJlbS5sZW5ndGggfHwgXG4gICAgZmllbGRzLnNvbWUoZnVuY3Rpb24oZikgeyByZXR1cm4gISFpbnB1dC5maWVsZHNbZl07IH0pKVxuICAgICAgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQua2V5XSA9IDEsIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LnZhbHVlXSA9IDE7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvbGQ7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIEZvcmNlKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHNpemU6IHt0eXBlOiBcImFycmF5PHZhbHVlPlwiLCBkZWZhdWx0OiBbNTAwLCA1MDBdfSxcbiAgICBsaW5rczoge3R5cGU6IFwiZGF0YVwifSxcbiAgICBsaW5rRGlzdGFuY2U6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IDIwfSxcbiAgICBsaW5rU3RyZW5ndGg6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IDF9LFxuICAgIGNoYXJnZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMzB9LFxuICAgIGNoYXJnZURpc3RhbmNlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBJbmZpbml0eX0sXG4gICAgaXRlcmF0aW9uczoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogNTAwfSxcbiAgICBmcmljdGlvbjoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC45fSxcbiAgICB0aGV0YToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC44fSxcbiAgICBncmF2aXR5OiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjF9LFxuICAgIGFscGhhOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjF9XG4gIH0pO1xuXG4gIHRoaXMuX25vZGVzID0gW107XG4gIHRoaXMuX2xpbmtzID0gW107XG4gIHRoaXMuX2xheW91dCA9IGQzLmxheW91dC5mb3JjZSgpO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInhcIjogXCJsYXlvdXQ6eFwiLFxuICAgIFwieVwiOiBcImxheW91dDp5XCIsXG4gICAgXCJzb3VyY2VcIjogXCJfc291cmNlXCIsXG4gICAgXCJ0YXJnZXRcIjogXCJfdGFyZ2V0XCJcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZvcmNlLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIGdldCh0cmFuc2Zvcm0sIG5hbWUpIHtcbiAgdmFyIHYgPSB0cmFuc2Zvcm1bbmFtZV0uZ2V0KHRyYW5zZm9ybS5fZ3JhcGgpO1xuICByZXR1cm4gdi5hY2Nlc3NvclxuICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gdi5hY2Nlc3Nvcih4LnR1cGxlKTsgfVxuICAgIDogdi5maWVsZDtcbn1cblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24obm9kZUlucHV0KSB7XG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGxpbmtJbnB1dCA9IHRoaXMubGlua3MuZ2V0KGcpLnNvdXJjZS5sYXN0KCksXG4gICAgICBsYXlvdXQgPSB0aGlzLl9sYXlvdXQsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBub2RlcyA9IHRoaXMuX25vZGVzLFxuICAgICAgbGlua3MgPSB0aGlzLl9saW5rcyxcbiAgICAgIGl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMuZ2V0KGcpO1xuXG4gIC8vIHByb2Nlc3MgYWRkZWQgbm9kZXNcbiAgbm9kZUlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBub2Rlcy5wdXNoKHt0dXBsZTogbn0pO1xuICB9KTtcblxuICAvLyBwcm9jZXNzIGFkZGVkIGVkZ2VzXG4gIGxpbmtJbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgdmFyIGxpbmsgPSB7XG4gICAgICB0dXBsZTogbCxcbiAgICAgIHNvdXJjZTogbm9kZXNbbC5zb3VyY2VdLFxuICAgICAgdGFyZ2V0OiBub2Rlc1tsLnRhcmdldF1cbiAgICB9O1xuICAgIHR1cGxlLnNldChsLCBvdXRwdXQuc291cmNlLCBsaW5rLnNvdXJjZS50dXBsZSk7XG4gICAgdHVwbGUuc2V0KGwsIG91dHB1dC50YXJnZXQsIGxpbmsudGFyZ2V0LnR1cGxlKTtcbiAgICBsaW5rcy5wdXNoKGxpbmspO1xuICB9KTtcblxuICAvLyBUT0RPIHByb2Nlc3MgXCJtb2RcIiBvZiBlZGdlIHNvdXJjZSBvciB0YXJnZXQ/XG5cbiAgLy8gY29uZmlndXJlIGxheW91dFxuICBsYXlvdXRcbiAgICAuc2l6ZSh0aGlzLnNpemUuZ2V0KGcpKVxuICAgIC5saW5rRGlzdGFuY2UoZ2V0KHRoaXMsIFwibGlua0Rpc3RhbmNlXCIpKVxuICAgIC5saW5rU3RyZW5ndGgoZ2V0KHRoaXMsIFwibGlua1N0cmVuZ3RoXCIpKVxuICAgIC5jaGFyZ2UoZ2V0KHRoaXMsIFwiY2hhcmdlXCIpKVxuICAgIC5jaGFyZ2VEaXN0YW5jZShnZXQodGhpcywgXCJjaGFyZ2VEaXN0YW5jZVwiKSlcbiAgICAuZnJpY3Rpb24odGhpcy5mcmljdGlvbi5nZXQoZykpXG4gICAgLnRoZXRhKHRoaXMudGhldGEuZ2V0KGcpKVxuICAgIC5ncmF2aXR5KHRoaXMuZ3Jhdml0eS5nZXQoZykpXG4gICAgLmFscGhhKHRoaXMuYWxwaGEuZ2V0KGcpKVxuICAgIC5ub2Rlcyhub2RlcylcbiAgICAubGlua3MobGlua3MpO1xuXG4gIC8vIHJ1biBsYXlvdXRcbiAgbGF5b3V0LnN0YXJ0KCk7XG4gIGZvciAodmFyIGk9MDsgaTxpdGVyOyArK2kpIHtcbiAgICBsYXlvdXQudGljaygpO1xuICB9XG4gIGxheW91dC5zdG9wKCk7XG5cbiAgLy8gY29weSBsYXlvdXQgdmFsdWVzIHRvIG5vZGVzXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIHR1cGxlLnNldChuLnR1cGxlLCBvdXRwdXQueCwgbi54KTtcbiAgICB0dXBsZS5zZXQobi50dXBsZSwgb3V0cHV0LnksIG4ueSk7XG4gIH0pO1xuXG4gIC8vIHByb2Nlc3MgcmVtb3ZlZCBub2Rlc1xuICBpZiAobm9kZUlucHV0LnJlbS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIG5vZGVJZHMgPSB0dXBsZS5pZE1hcChub2RlSW5wdXQucmVtKTtcbiAgICB0aGlzLl9ub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbihuKSB7IHJldHVybiAhbm9kZUlkc1tuLnR1cGxlLl9pZF07IH0pO1xuICB9XG5cbiAgLy8gcHJvY2VzcyByZW1vdmVkIGVkZ2VzXG4gIGlmIChsaW5rSW5wdXQucmVtLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbGlua0lkcyA9IHR1cGxlLmlkTWFwKGxpbmtJbnB1dC5yZW0pO1xuICAgIHRoaXMuX2xpbmtzID0gbGlua3MuZmlsdGVyKGZ1bmN0aW9uKGwpIHsgcmV0dXJuICFsaW5rSWRzW2wudHVwbGUuX2lkXTsgfSk7XG4gIH1cblxuICAvLyByZXR1cm4gY2hhbmdlc2V0XG4gIG5vZGVJbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgbm9kZUlucHV0LmZpZWxkc1tvdXRwdXQueV0gPSAxO1xuICByZXR1cm4gbm9kZUlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JjZTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksIFxuICAgIGV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9wYXJzZS9leHByJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEZvcm11bGEoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIGV4cHI6ICB7dHlwZTogXCJleHByXCJ9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRm9ybXVsYS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiZm9ybXVsYXRpbmdcIl0pO1xuICB2YXIgdCA9IHRoaXMsIFxuICAgICAgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgZmllbGQgPSB0aGlzLmZpZWxkLmdldChnKSxcbiAgICAgIGV4cHIgPSB0aGlzLmV4cHIuZ2V0KGcpLFxuICAgICAgZGVwcyA9IHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMpO1xuICBcbiAgZnVuY3Rpb24gc2V0KHgpIHtcbiAgICB2YXIgdmFsID0gZXhwcmVzc2lvbi5ldmFsKGcsIGV4cHIsIHgsIG51bGwsIG51bGwsIG51bGwsIGRlcHMpO1xuICAgIHR1cGxlLnNldCh4LCBmaWVsZCwgdmFsKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIFxuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbZmllbGRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtdWxhOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBHZW8oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCBHZW8uUGFyYW1ldGVycyk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBsb246IHt0eXBlOiBcImZpZWxkXCJ9LFxuICAgIGxhdDoge3R5cGU6IFwiZmllbGRcIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiBcImdlbzp4XCIsXG4gICAgXCJ5XCI6IFwiZ2VvOnlcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIE5vbmVcblxuR2VvLlBhcmFtZXRlcnMgPSB7XG4gIHByb2plY3Rpb246IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwibWVyY2F0b3JcIn0sXG4gIGNlbnRlcjogICAgIHt0eXBlOiBcImFycmF5W3ZhbHVlXVwifSxcbiAgdHJhbnNsYXRlOiAge3R5cGU6IFwiYXJyYXlbdmFsdWVdXCJ9LFxuICByb3RhdGU6ICAgICB7dHlwZTogXCJhcnJheVt2YWx1ZV1cIn0sXG4gIHNjYWxlOiAgICAgIHt0eXBlOiBcInZhbHVlXCJ9LFxuICBwcmVjaXNpb246ICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgY2xpcEFuZ2xlOiAge3R5cGU6IFwidmFsdWVcIn0sXG4gIGNsaXBFeHRlbnQ6IHt0eXBlOiBcInZhbHVlXCJ9XG59O1xuXG5HZW8uZDNQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBwID0gdGhpcy5wcm9qZWN0aW9uLmdldChnKSxcbiAgICAgIHBhcmFtID0gR2VvLlBhcmFtZXRlcnMsXG4gICAgICBwcm9qLCBuYW1lLCB2YWx1ZTtcblxuICBpZiAocCAhPT0gdGhpcy5fbW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSBwO1xuICAgIHRoaXMuX3Byb2plY3Rpb24gPSBkMy5nZW9bcF0oKTtcbiAgfVxuICBwcm9qID0gdGhpcy5fcHJvamVjdGlvbjtcblxuICBmb3IgKG5hbWUgaW4gcGFyYW0pIHtcbiAgICBpZiAobmFtZSA9PT0gXCJwcm9qZWN0aW9uXCIgfHwgIXByb2pbbmFtZV0pIGNvbnRpbnVlO1xuICAgIHZhbHVlID0gdGhpc1tuYW1lXS5nZXQoZyk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgKGRsLmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHByb2pbbmFtZV0oKSkge1xuICAgICAgcHJvaltuYW1lXSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb2o7XG59O1xuXG52YXIgcHJvdG8gPSAoR2VvLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBsb24gPSB0aGlzLmxvbi5nZXQoZykuYWNjZXNzb3IsXG4gICAgICBsYXQgPSB0aGlzLmxhdC5nZXQoZykuYWNjZXNzb3IsXG4gICAgICBwcm9qID0gR2VvLmQzUHJvamVjdGlvbi5jYWxsKHRoaXMpO1xuXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgdmFyIGxsID0gW2xvbih0KSwgbGF0KHQpXTtcbiAgICB2YXIgeHkgPSBwcm9qKGxsKTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LngsIHh5WzBdKTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnksIHh5WzFdKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgICBpbnB1dC5yZW0uZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC54XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueV0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbztcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIEdlbyA9IHJlcXVpcmUoJy4vR2VvJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIEdlb1BhdGgoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCBHZW8uUGFyYW1ldGVycyk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICB2YWx1ZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogbnVsbH0sXG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInBhdGhcIjogXCJnZW86cGF0aFwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoR2VvUGF0aC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgZ2VvanNvbiA9IHRoaXMudmFsdWUuZ2V0KGcpLmFjY2Vzc29yIHx8IGRsLmlkZW50aXR5LFxuICAgICAgcHJvaiA9IEdlby5kM1Byb2plY3Rpb24uY2FsbCh0aGlzKSxcbiAgICAgIHBhdGggPSBkMy5nZW8ucGF0aCgpLnByb2plY3Rpb24ocHJvaik7XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnBhdGgsIHBhdGgoZ2VvanNvbih0KSkpO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnBhdGhdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9QYXRoO1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBHcm91cEJ5KGdyYXBoKSB7XG4gIGlmKGdyYXBoKSB0aGlzLmluaXQoZ3JhcGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEdyb3VwQnkucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMuX2diID0gbnVsbDsgLy8gZmllbGRzK2FjY2Vzc29ycyB0byBncm91cGJ5IGZpZWxkc1xuICB0aGlzLl9jZWxscyA9IHt9O1xuICByZXR1cm4gVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKS5yZXZpc2VzKHRydWUpO1xufTtcblxucHJvdG8uZGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fY2VsbHM7IH07XG5cbnByb3RvLl9yZXNldCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgdmFyIGssIGM7XG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgaWYoIShjID0gdGhpcy5fY2VsbHNba10pKSBjb250aW51ZTtcbiAgICBvdXRwdXQucmVtLnB1c2goYy50cGwpO1xuICB9XG4gIHRoaXMuX2NlbGxzID0ge307XG59O1xuXG5wcm90by5fa2V5cyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGFjYyA9IHRoaXMuX2diLmFjY2Vzc29ycyB8fCBbdGhpcy5fZ2IuYWNjZXNzb3JdO1xuICB2YXIga2V5cyA9IGFjYy5yZWR1Y2UoZnVuY3Rpb24oZywgZikge1xuICAgIHJldHVybiAoKHYgPSBmKHgpKSAhPT0gdW5kZWZpbmVkKSA/IChnLnB1c2godiksIGcpIDogZztcbiAgfSwgW10pLCBrID0ga2V5cy5qb2luKFwifFwiKSwgdjtcbiAgcmV0dXJuIGtleXMubGVuZ3RoID4gMCA/IHtrZXlzOiBrZXlzLCBrZXk6IGt9IDogdW5kZWZpbmVkO1xufTtcblxucHJvdG8uX2NlbGwgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrID0gdGhpcy5fa2V5cyh4KTtcbiAgcmV0dXJuIHRoaXMuX2NlbGxzW2sua2V5XSB8fCAodGhpcy5fY2VsbHNbay5rZXldID0gdGhpcy5fbmV3X2NlbGwoeCwgaykpO1xufTtcblxucHJvdG8uX25ld19jZWxsID0gZnVuY3Rpb24oeCwgaykge1xuICByZXR1cm4ge1xuICAgIGNudDogMCxcbiAgICB0cGw6IHRoaXMuX25ld190dXBsZSh4LCBrKSxcbiAgICBmbGc6IEMuQUREX0NFTExcbiAgfTtcbn07XG5cbnByb3RvLl9uZXdfdHVwbGUgPSBmdW5jdGlvbih4LCBrKSB7XG4gIHZhciBnYiA9IHRoaXMuX2diLFxuICAgICAgZmllbGRzID0gZ2IuZmllbGRzIHx8IFtnYi5maWVsZF0sXG4gICAgICBhY2MgPSBnYi5hY2Nlc3NvcnMgfHwgW2diLmFjY2Vzc29yXSxcbiAgICAgIHQgPSB7fSwgaSwgbGVuO1xuXG4gIGZvcihpPTAsIGxlbj1maWVsZHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgdFtmaWVsZHNbaV1dID0gYWNjW2ldKHgpO1xuICB9IFxuXG4gIHJldHVybiB0dXBsZS5pbmdlc3QodCwgbnVsbCk7XG59O1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCk7XG4gIGNlbGwuY250ICs9IDE7XG4gIGNlbGwuZmxnIHw9IEMuTU9EX0NFTEw7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX3JlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsKHgpO1xuICBjZWxsLmNudCAtPSAxO1xuICBjZWxsLmZsZyB8PSBDLk1PRF9DRUxMO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9tb2QgPSBmdW5jdGlvbih4LCByZXNldCkge1xuICBpZih4Ll9wcmV2ICYmIHguX3ByZXYgIT09IEMuU0VOVElORUwgJiYgdGhpcy5fa2V5cyh4Ll9wcmV2KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fcmVtKHguX3ByZXYpO1xuICAgIHJldHVybiB0aGlzLl9hZGQoeCk7XG4gIH0gZWxzZSBpZihyZXNldCkgeyAvLyBTaWduYWwgY2hhbmdlIHRyaWdnZXJlZCByZWZsb3dcbiAgICByZXR1cm4gdGhpcy5fYWRkKHgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9jZWxsKHgpO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIHZhciBncm91cEJ5ID0gdGhpcyxcbiAgICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgaywgYywgZiwgdDtcblxuICBpZihyZXNldCkgdGhpcy5fcmVzZXQoaW5wdXQsIG91dHB1dCk7XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkgeyBncm91cEJ5Ll9hZGQoeCk7IH0pO1xuICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7IGdyb3VwQnkuX21vZCh4LCByZXNldCk7IH0pO1xuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYoeC5fcHJldiAmJiB4Ll9wcmV2ICE9PSBDLlNFTlRJTkVMICYmIGdyb3VwQnkuX2tleXMoeC5fcHJldikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ3JvdXBCeS5fcmVtKHguX3ByZXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cEJ5Ll9yZW0oeCk7XG4gICAgfVxuICB9KTtcblxuICBmb3IoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGMgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZighYykgY29udGludWU7XG4gICAgZiA9IGMuZmxnO1xuICAgIHQgPSBjLnRwbDtcblxuICAgIGlmKGMuY250ID09PSAwKSB7XG4gICAgICBpZihmID09PSBDLk1PRF9DRUxMKSBvdXRwdXQucmVtLnB1c2godCk7XG4gICAgICB0aGlzLl9jZWxsc1trXSA9IG51bGw7XG4gICAgfSBlbHNlIGlmKGYgJiBDLkFERF9DRUxMKSB7XG4gICAgICBvdXRwdXQuYWRkLnB1c2godCk7XG4gICAgfSBlbHNlIGlmKGYgJiBDLk1PRF9DRUxMKSB7XG4gICAgICBvdXRwdXQubW9kLnB1c2godCk7XG4gICAgfVxuICAgIGMuZmxnID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwQnk7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBMaW5rUGF0aChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBzb3VyY2U6ICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcIl9zb3VyY2VcIn0sXG4gICAgdGFyZ2V0OiAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJfdGFyZ2V0XCJ9LFxuICAgIHg6ICAgICAgIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwibGF5b3V0OnhcIn0sXG4gICAgeTogICAgICAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJsYXlvdXQ6eVwifSxcbiAgICB0ZW5zaW9uOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjJ9LFxuICAgIHNoYXBlOiAgIHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwibGluZVwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XCJwYXRoXCI6IFwibGluazpwYXRoXCJ9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKExpbmtQYXRoLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIGxpbmUoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCk7XG4gIHJldHVybiBcIk1cIiArIHN4ICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCJMXCIgKyB0eCArIFwiLFwiICsgdHk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlKGQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKSB7XG4gIHZhciBzID0gc291cmNlKGQpLCBzeCA9IHgocyksIHN5ID0geShzKSxcbiAgICAgIHQgPSB0YXJnZXQoZCksIHR4ID0geCh0KSwgdHkgPSB5KHQpLFxuICAgICAgZHggPSB0eCAtIHN4LFxuICAgICAgZHkgPSB0eSAtIHN5LFxuICAgICAgaXggPSB0ZW5zaW9uICogKGR4ICsgZHkpLFxuICAgICAgaXkgPSB0ZW5zaW9uICogKGR5IC0gZHgpO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiQ1wiICsgKHN4K2l4KSArIFwiLFwiICsgKHN5K2l5KVxuICAgICAgICsgXCIgXCIgKyAodHgraXkpICsgXCIsXCIgKyAodHktaXgpXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxuZnVuY3Rpb24gZGlhZ29uYWxYKGQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKSB7XG4gIHZhciBzID0gc291cmNlKGQpLCBzeCA9IHgocyksIHN5ID0geShzKSxcbiAgICAgIHQgPSB0YXJnZXQoZCksIHR4ID0geCh0KSwgdHkgPSB5KHQpLFxuICAgICAgbSA9IChzeCArIHR4KSAvIDI7XG4gIHJldHVybiBcIk1cIiArIHN4ICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCJDXCIgKyBtICArIFwiLFwiICsgc3lcbiAgICAgICArIFwiIFwiICsgbSAgKyBcIixcIiArIHR5XG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxuZnVuY3Rpb24gZGlhZ29uYWxZKGQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKSB7XG4gIHZhciBzID0gc291cmNlKGQpLCBzeCA9IHgocyksIHN5ID0geShzKSxcbiAgICAgIHQgPSB0YXJnZXQoZCksIHR4ID0geCh0KSwgdHkgPSB5KHQpLFxuICAgICAgbSA9IChzeSArIHR5KSAvIDI7XG4gIHJldHVybiBcIk1cIiArIHN4ICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCJDXCIgKyBzeCArIFwiLFwiICsgbVxuICAgICAgICsgXCIgXCIgKyB0eCArIFwiLFwiICsgbVxuICAgICAgICsgXCIgXCIgKyB0eCArIFwiLFwiICsgdHk7XG59XG5cbnZhciBzaGFwZXMgPSB7XG4gIGxpbmU6ICAgICAgbGluZSxcbiAgY3VydmU6ICAgICBjdXJ2ZSxcbiAgZGlhZ29uYWw6ICBkaWFnb25hbFgsXG4gIGRpYWdvbmFsWDogZGlhZ29uYWxYLFxuICBkaWFnb25hbFk6IGRpYWdvbmFsWVxufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIHNoYXBlID0gc2hhcGVzW3RoaXMuc2hhcGUuZ2V0KGcpXSB8fCBzaGFwZXMubGluZSxcbiAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHggPSB0aGlzLnguZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgeSA9IHRoaXMueS5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uLmdldChnKTtcbiAgXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgdmFyIHBhdGggPSBzaGFwZSh0LCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbilcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnBhdGgsIHBhdGgpO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5wYXRoXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua1BhdGg7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZS9leHByJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbnZhciBhcnJheVR5cGUgPSAvYXJyYXkvaSxcbiAgICBkYXRhVHlwZSAgPSAvZGF0YS9pLFxuICAgIGZpZWxkVHlwZSA9IC9maWVsZC9pLFxuICAgIGV4cHJUeXBlICA9IC9leHByL2k7XG5cbmZ1bmN0aW9uIFBhcmFtZXRlcihuYW1lLCB0eXBlKSB7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl90eXBlID0gdHlwZTtcblxuICAvLyBJZiBwYXJhbWV0ZXIgaXMgZGVmaW5lZCB3L3NpZ25hbHMsIGl0IG11c3QgYmUgcmVzb2x2ZWRcbiAgLy8gb24gZXZlcnkgcHVsc2UuXG4gIHRoaXMuX3ZhbHVlID0gW107XG4gIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICB0aGlzLl9yZXNvbHV0aW9uID0gZmFsc2U7XG4gIHRoaXMuX3NpZ25hbHMgPSB7fTtcbn1cblxudmFyIHByb3RvID0gUGFyYW1ldGVyLnByb3RvdHlwZTtcblxucHJvdG8uX2dldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXNBcnJheSA9IGFycmF5VHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSk7XG5cbiAgaWYgKGlzRGF0YSkge1xuICAgIHJldHVybiBpc0FycmF5ID8geyBuYW1lczogdGhpcy5fdmFsdWUsIHNvdXJjZXM6IHRoaXMuX2FjY2Vzc29ycyB9IDpcbiAgICAgIHsgbmFtZTogdGhpcy5fdmFsdWVbMF0sIHNvdXJjZTogdGhpcy5fYWNjZXNzb3JzWzBdIH07XG4gIH0gZWxzZSBpZiAoaXNGaWVsZCkge1xuICAgIHJldHVybiBpc0FycmF5ID8geyBmaWVsZHM6IHRoaXMuX3ZhbHVlLCBhY2Nlc3NvcnM6IHRoaXMuX2FjY2Vzc29ycyB9IDpcbiAgICAgIHsgZmllbGQ6IHRoaXMuX3ZhbHVlWzBdLCBhY2Nlc3NvcjogdGhpcy5fYWNjZXNzb3JzWzBdIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB0aGlzLl92YWx1ZSA6IHRoaXMuX3ZhbHVlWzBdO1xuICB9XG59O1xuXG5wcm90by5nZXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB2YXIgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBzLCBpZHgsIHZhbDtcblxuICAvLyBJZiB3ZSBkb24ndCByZXF1aXJlIHJlc29sdXRpb24sIHJldHVybiB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gIGlmICghdGhpcy5fcmVzb2x1dGlvbikgcmV0dXJuIHRoaXMuX2dldCgpO1xuXG4gIGlmIChpc0RhdGEpIHtcbiAgICB0aGlzLl9hY2Nlc3NvcnMgPSB0aGlzLl92YWx1ZS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gZ3JhcGguZGF0YSh2KTsgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2dldCgpOyAvLyBUT0RPOiBzdXBwb3J0IHNpZ25hbCBhcyBkYXRhVHlwZXNcbiAgfVxuXG4gIGZvcihzIGluIHRoaXMuX3NpZ25hbHMpIHtcbiAgICBpZHggID0gdGhpcy5fc2lnbmFsc1tzXTtcbiAgICB2YWwgID0gZ3JhcGguc2lnbmFsUmVmKHMpO1xuXG4gICAgaWYgKGlzRmllbGQpIHtcbiAgICAgIHRoaXMuX2FjY2Vzc29yc1tpZHhdID0gdGhpcy5fdmFsdWVbaWR4XSAhPSB2YWwgPyBcbiAgICAgICAgZGwuYWNjZXNzb3IodmFsKSA6IHRoaXMuX2FjY2Vzc29yc1tpZHhdO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlW2lkeF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZ2V0KCk7XG59O1xuXG5wcm90by5zZXQgPSBmdW5jdGlvbih0cmFuc2Zvcm0sIHZhbHVlKSB7XG4gIHZhciBwYXJhbSA9IHRoaXMsIFxuICAgICAgaXNFeHByID0gZXhwclR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpO1xuXG4gIHRoaXMuX3ZhbHVlID0gZGwuYXJyYXkodmFsdWUpLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgaWYgKGRsLmlzU3RyaW5nKHYpKSB7XG4gICAgICBpZiAoaXNFeHByKSB7XG4gICAgICAgIHZhciBlID0gZXhwcih2KTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5GSUVMRFMsICBlLmZpZWxkcyk7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgZS5zaWduYWxzKTtcbiAgICAgICAgcmV0dXJuIGUuZm47XG4gICAgICB9IGVsc2UgaWYgKGlzRmllbGQpIHsgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHBhcmFtLl9hY2Nlc3NvcnNbaV0gPSBkbC5hY2Nlc3Nvcih2KTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5GSUVMRFMsIHYpO1xuICAgICAgfSBlbHNlIGlmIChpc0RhdGEpIHtcbiAgICAgICAgcGFyYW0uX3Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkRBVEEsIHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIGlmICh2LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodi5maWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbS5fYWNjZXNzb3JzW2ldID0gZGwuYWNjZXNzb3Iodi5maWVsZCk7XG4gICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgdi5maWVsZCk7XG4gICAgICByZXR1cm4gdi5maWVsZDtcbiAgICB9IGVsc2UgaWYgKHYuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtLl9yZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICAgIHBhcmFtLl9zaWduYWxzW3Yuc2lnbmFsXSA9IGk7XG4gICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLlNJR05BTFMsIHYuc2lnbmFsKTtcbiAgICAgIHJldHVybiB2LnNpZ25hbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYW1ldGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBQaWUoZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICB2YWx1ZTogICAgICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBudWxsfSxcbiAgICBzdGFydEFuZ2xlOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwfSxcbiAgICBlbmRBbmdsZTogICB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAyICogTWF0aC5QSX0sXG4gICAgc29ydDogICAgICAge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogZmFsc2V9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInN0YXJ0XCI6IFwibGF5b3V0OnN0YXJ0XCIsXG4gICAgXCJzdG9wXCI6ICBcImxheW91dDpzdG9wXCIsXG4gICAgXCJtaWRcIjogICBcImxheW91dDptaWRcIlxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoUGllLnByb3RvdHlwZSA9IG5ldyBCYXRjaFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gb25lcygpIHsgcmV0dXJuIDE7IH1cblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvciB8fCBvbmVzLFxuICAgICAgc3RhcnQgPSB0aGlzLnN0YXJ0QW5nbGUuZ2V0KGcpLFxuICAgICAgc3RvcCA9IHRoaXMuZW5kQW5nbGUuZ2V0KGcpLFxuICAgICAgc29ydCA9IHRoaXMuc29ydC5nZXQoZyk7XG5cbiAgdmFyIHZhbHVlcyA9IGRhdGEubWFwKHZhbHVlKSxcbiAgICAgIGEgPSBzdGFydCxcbiAgICAgIGsgPSAoc3RvcCAtIHN0YXJ0KSAvIGQzLnN1bSh2YWx1ZXMpLFxuICAgICAgaW5kZXggPSBkbC5yYW5nZShkYXRhLmxlbmd0aCksXG4gICAgICBpLCB0LCB2O1xuXG4gIGlmIChzb3J0KSB7XG4gICAgaW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gdmFsdWVzW2FdIC0gdmFsdWVzW2JdO1xuICAgIH0pO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8aW5kZXgubGVuZ3RoOyArK2kpIHtcbiAgICB0ID0gZGF0YVtpbmRleFtpXV07XG4gICAgdiA9IHZhbHVlc1tpbmRleFtpXV07XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5zdGFydCwgYSk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5taWQsIChhICsgMC41ICogdiAqIGspKTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnN0b3AsIChhICs9IHYgKiBrKSk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0YXJ0XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RvcF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0Lm1pZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpZTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZS9leHByJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbmZ1bmN0aW9uIFNvcnQoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7Ynk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSB9KTtcbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoU29ydC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wic29ydGluZ1wiXSk7XG5cbiAgaWYoaW5wdXQuYWRkLmxlbmd0aCB8fCBpbnB1dC5tb2QubGVuZ3RoIHx8IGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICBpbnB1dC5zb3J0ID0gZGwuY29tcGFyYXRvcih0aGlzLmJ5LmdldCh0aGlzLl9ncmFwaCkuZmllbGRzKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29ydDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIFN0YWNrKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZ3JvdXBieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9LFxuICAgIHNvcnRieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9LFxuICAgIHZhbHVlOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBvZmZzZXQ6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwiemVyb1wifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJzdGFydFwiOiBcImxheW91dDpzdGFydFwiLFxuICAgIFwic3RvcFwiOiAgXCJsYXlvdXQ6c3RvcFwiLFxuICAgIFwibWlkXCI6ICAgXCJsYXlvdXQ6bWlkXCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChTdGFjay5wcm90b3R5cGUgPSBuZXcgQmF0Y2hUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGdyb3VwYnkgPSB0aGlzLmdyb3VwYnkuZ2V0KGcpLmFjY2Vzc29ycyxcbiAgICAgIHNvcnRieSA9IGRsLmNvbXBhcmF0b3IodGhpcy5zb3J0YnkuZ2V0KGcpLmZpZWxkcyksXG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWUuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQuZ2V0KGcpLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0O1xuXG4gIC8vIHBhcnRpdGlvbiwgc3VtLCBhbmQgc29ydCB0aGUgc3RhY2sgZ3JvdXBzXG4gIHZhciBncm91cHMgPSBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydGJ5LCB2YWx1ZSk7XG5cbiAgLy8gY29tcHV0ZSBzdGFjayBsYXlvdXRzIHBlciBncm91cFxuICBmb3IgKHZhciBpPTAsIG1heD1ncm91cHMubWF4OyBpPGdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXSxcbiAgICAgICAgc3VtID0gZ3JvdXAuc3VtLFxuICAgICAgICBvZmYgPSBvZmZzZXQ9PT1cImNlbnRlclwiID8gKG1heCAtIHN1bSkvMiA6IDAsXG4gICAgICAgIHNjYWxlID0gb2Zmc2V0PT09XCJub3JtYWxpemVcIiA/ICgxL3N1bSkgOiAxLFxuICAgICAgICBpLCB4LCBhLCBiID0gb2ZmLCB2ID0gMDtcblxuICAgIC8vIHNldCBzdGFjayBjb29yZGluYXRlcyBmb3IgZWFjaCBkYXR1bSBpbiBncm91cFxuICAgIGZvciAoaj0wOyBqPGdyb3VwLmxlbmd0aDsgKytqKSB7XG4gICAgICB4ID0gZ3JvdXBbal07XG4gICAgICBhID0gYjsgLy8gdXNlIHByZXZpb3VzIHZhbHVlIGZvciBzdGFydCBwb2ludFxuICAgICAgdiArPSB2YWx1ZSh4KTtcbiAgICAgIGIgPSBzY2FsZSAqIHYgKyBvZmY7IC8vIGNvbXB1dGUgZW5kIHBvaW50XG4gICAgICB0dXBsZS5zZXQoeCwgb3V0cHV0LnN0YXJ0LCBhKTtcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQuc3RvcCwgYik7XG4gICAgICB0dXBsZS5zZXQoeCwgb3V0cHV0Lm1pZCwgMC41ICogKGEgKyBiKSk7XG4gICAgfVxuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdGFydF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0b3BdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5taWRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnRieSwgdmFsdWUpIHtcbiAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgbWFwLCBpLCB4LCBrLCBnLCBzLCBtYXg7XG5cbiAgLy8gcGFydGl0aW9uIGRhdGEgcG9pbnRzIGludG8gc3RhY2sgZ3JvdXBzXG4gIGlmIChncm91cGJ5ID09IG51bGwpIHtcbiAgICBncm91cHMucHVzaChkYXRhLnNsaWNlKCkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobWFwPXt9LCBpPTA7IGk8ZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgeCA9IGRhdGFbaV07XG4gICAgICBrID0gKGdyb3VwYnkubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYoeCk7IH0pKTtcbiAgICAgIGcgPSBtYXBba10gfHwgKGdyb3Vwcy5wdXNoKG1hcFtrXSA9IFtdKSwgbWFwW2tdKTtcbiAgICAgIGcucHVzaCh4KTtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wdXRlIHN1bXMgb2YgZ3JvdXBzLCBzb3J0IGdyb3VwcyBhcyBuZWVkZWRcbiAgZm9yIChrPTAsIG1heD0wOyBrPGdyb3Vwcy5sZW5ndGg7ICsraykge1xuICAgIGcgPSBncm91cHNba107XG4gICAgZm9yIChpPTAsIHM9MDsgaTxnLmxlbmd0aDsgKytpKSB7XG4gICAgICBzICs9IHZhbHVlKGdbaV0pO1xuICAgIH1cbiAgICBnLnN1bSA9IHM7XG4gICAgaWYgKHMgPiBtYXgpIG1heCA9IHM7XG4gICAgaWYgKHNvcnRieSAhPSBudWxsKSBnLnNvcnQoc29ydGJ5KTtcbiAgfVxuICBncm91cHMubWF4ID0gbWF4O1xuXG4gIHJldHVybiBncm91cHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7IiwidmFyIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgUGFyYW1ldGVyID0gcmVxdWlyZSgnLi9QYXJhbWV0ZXInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtKGdyYXBoKSB7XG4gIGlmKGdyYXBoKSBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxuVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwcm90bywgcGFyYW1zKSB7XG4gIHZhciBwO1xuICBmb3IgKHZhciBuYW1lIGluIHBhcmFtcykge1xuICAgIHAgPSBwYXJhbXNbbmFtZV07XG4gICAgcHJvdG9bbmFtZV0gPSBuZXcgUGFyYW1ldGVyKG5hbWUsIHAudHlwZSk7XG4gICAgaWYgKHAuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkgcHJvdG9bbmFtZV0uc2V0KHByb3RvLCBwLmRlZmF1bHQpO1xuICB9XG4gIHByb3RvLl9wYXJhbWV0ZXJzID0gcGFyYW1zO1xufTtcblxudmFyIHByb3RvID0gKFRyYW5zZm9ybS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSBOb2RlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICBuLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICBuLl9wYXJhbWV0ZXJzID0gdGhpcy5fcGFyYW1ldGVycztcbiAgZm9yKHZhciBrIGluIHRoaXMpIHsgXG4gICAgaWYobltrXSkgY29udGludWU7XG4gICAgbltrXSA9IHRoaXNba107IFxuICB9XG4gIHJldHVybiBuO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7IHJldHVybiBpbnB1dDsgfTtcbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gTWFueSB0cmFuc2Zvcm1zIHN0b3JlIGNhY2hlcyB0aGF0IG11c3QgYmUgaW52YWxpZGF0ZWQgaWZcbiAgLy8gYSBzaWduYWwgdmFsdWUgaGFzIGNoYW5nZWQuIFxuICB2YXIgcmVzZXQgPSB0aGlzLl9zdGFtcCA8IGlucHV0LnN0YW1wICYmIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMpLnNvbWUoZnVuY3Rpb24ocykgeyBcbiAgICByZXR1cm4gISFpbnB1dC5zaWduYWxzW3NdIFxuICB9KTtcblxuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oaW5wdXQsIHJlc2V0KTtcbn07XG5cbnByb3RvLm91dHB1dCA9IGZ1bmN0aW9uKG1hcCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fb3V0cHV0KSB7XG4gICAgaWYgKG1hcFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX291dHB1dFtrZXldID0gbWFwW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIFRyZWVtYXAoZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICAvLyBoaWVyYXJjaHkgcGFyYW1ldGVyc1xuICAgIHNvcnQ6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwiLCBkZWZhdWx0OiBbXCItdmFsdWVcIl19LFxuICAgIGNoaWxkcmVuOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImNoaWxkcmVuXCJ9LFxuICAgIHZhbHVlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcInZhbHVlXCJ9LFxuICAgIC8vIHRyZWVtYXAgcGFyYW1ldGVyc1xuICAgIHNpemU6IHt0eXBlOiBcImFycmF5PHZhbHVlPlwiLCBkZWZhdWx0OiBbNTAwLCA1MDBdfSxcbiAgICByb3VuZDoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogdHJ1ZX0sXG4gICAgc3RpY2t5OiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgcmF0aW86IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuNSAqICgxICsgTWF0aC5zcXJ0KDUpKX0sXG4gICAgcGFkZGluZzoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogbnVsbH0sXG4gICAgbW9kZToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJzcXVhcmlmeVwifVxuICB9KTtcblxuICB0aGlzLl9sYXlvdXQgPSBkMy5sYXlvdXQudHJlZW1hcCgpO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInhcIjogICAgICBcImxheW91dDp4XCIsXG4gICAgXCJ5XCI6ICAgICAgXCJsYXlvdXQ6eVwiLFxuICAgIFwid2lkdGhcIjogIFwibGF5b3V0OndpZHRoXCIsXG4gICAgXCJoZWlnaHRcIjogXCJsYXlvdXQ6aGVpZ2h0XCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChUcmVlbWFwLnByb3RvdHlwZSA9IG5ldyBCYXRjaFRyYW5zZm9ybSgpKTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAvLyBnZXQgdmFyaWFibGVzXG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBsYXlvdXQgPSB0aGlzLl9sYXlvdXQsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQ7XG5cbiAgLy8gY29uZmlndXJlIGxheW91dFxuICBsYXlvdXRcbiAgICAuc29ydChkbC5jb21wYXJhdG9yKHRoaXMuc29ydC5nZXQoZykuZmllbGRzKSlcbiAgICAuY2hpbGRyZW4odGhpcy5jaGlsZHJlbi5nZXQoZykuYWNjZXNzb3IpXG4gICAgLnZhbHVlKHRoaXMudmFsdWUuZ2V0KGcpLmFjY2Vzc29yKVxuICAgIC5zaXplKHRoaXMuc2l6ZS5nZXQoZykpXG4gICAgLnJvdW5kKHRoaXMucm91bmQuZ2V0KGcpKVxuICAgIC5zdGlja3kodGhpcy5zdGlja3kuZ2V0KGcpKVxuICAgIC5yYXRpbyh0aGlzLnJhdGlvLmdldChnKSlcbiAgICAucGFkZGluZyh0aGlzLnBhZGRpbmcuZ2V0KGcpKVxuICAgIC5tb2RlKHRoaXMubW9kZS5nZXQoZykpXG4gICAgLm5vZGVzKGRhdGFbMF0pO1xuXG4gIC8vIGNvcHkgbGF5b3V0IHZhbHVlcyB0byBub2Rlc1xuICBkYXRhLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQueCwgbi54KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LnksIG4ueSk7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC53aWR0aCwgbi5keCk7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC5oZWlnaHQsIG4uZHkpO1xuICB9KTtcblxuICAvLyByZXR1cm4gY2hhbmdlc2V0XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC53aWR0aF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LmhlaWdodF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVtYXA7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgR3JvdXBCeSA9IHJlcXVpcmUoJy4vR3JvdXBCeScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxuZnVuY3Rpb24gVW5pcXVlKGdyYXBoKSB7XG4gIEdyb3VwQnkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDoge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgYXM6IHt0eXBlOiBcInZhbHVlXCJ9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoVW5pcXVlLnByb3RvdHlwZSA9IG5ldyBHcm91cEJ5KCkpO1xuXG5wcm90by5fbmV3X3R1cGxlID0gZnVuY3Rpb24oeCkge1xuICB2YXIgbyAgPSB7fSxcbiAgICAgIG9uID0gdGhpcy5maWVsZC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgYXMgPSB0aGlzLmFzLmdldCh0aGlzLl9ncmFwaCk7XG5cbiAgb1thc10gPSBvbi5hY2Nlc3Nvcih4KTtcbiAgcmV0dXJuIHR1cGxlLmluZ2VzdChvLCBudWxsKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1widW5pcXVlc1wiXSk7XG4gIHRoaXMuX2diID0gdGhpcy5maWVsZC5nZXQodGhpcy5fZ3JhcGgpO1xuICByZXR1cm4gR3JvdXBCeS5wcm90b3R5cGUudHJhbnNmb3JtLmNhbGwodGhpcywgaW5wdXQsIHJlc2V0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBaaXAoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgd2l0aDoge3R5cGU6IFwiZGF0YVwifSxcbiAgICBhczogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIGtleToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJkYXRhXCJ9LFxuICAgIHdpdGhLZXk6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIGRlZmF1bHQ6IHt0eXBlOiBcInZhbHVlXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgdGhpcy5fbGFzdEpvaW4gPSAwO1xuXG4gIHJldHVybiB0aGlzLnJldmlzZXModHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChaaXAucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gbXAoaykge1xuICByZXR1cm4gdGhpcy5fbWFwW2tdIHx8ICh0aGlzLl9tYXBba10gPSBbXSk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgdyA9IHRoaXMud2l0aC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgd2RzID0gdy5zb3VyY2UsXG4gICAgICB3b3V0cHV0ID0gd2RzLmxhc3QoKSxcbiAgICAgIHdkYXRhID0gd2RzLnZhbHVlcygpLFxuICAgICAga2V5ID0gdGhpcy5rZXkuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIHdpdGhLZXkgPSB0aGlzLndpdGhLZXkuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGFzID0gdGhpcy5hcy5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgZGZsdCA9IHRoaXMuZGVmYXVsdC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgbWFwID0gbXAuYmluZCh0aGlzKSxcbiAgICAgIHJlbSA9IHt9O1xuXG4gIGRlYnVnKGlucHV0LCBbXCJ6aXBwaW5nXCIsIHcubmFtZV0pO1xuXG4gIGlmKHdpdGhLZXkuZmllbGQpIHtcbiAgICBpZih3b3V0cHV0ICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0Sm9pbikge1xuICAgICAgd291dHB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBtID0gbWFwKHdpdGhLZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICBpZihtWzBdKSBtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IGRmbHQgfSk7XG4gICAgICAgIG1bMV0gPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIHdvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkgeyBcbiAgICAgICAgdmFyIG0gPSBtYXAod2l0aEtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgIGlmKG1bMF0pIG1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0geCB9KTtcbiAgICAgICAgbVsxXSA9IHg7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gT25seSBwcm9jZXNzIHdvdXRwdXQubW9kIHR1cGxlcyBpZiB0aGUgam9pbiBrZXkgaGFzIGNoYW5nZWQuXG4gICAgICAvLyBPdGhlciBmaWVsZCB1cGRhdGVzIHdpbGwgYXV0by1wcm9wYWdhdGUgdmlhIHByb3RvdHlwZS5cbiAgICAgIGlmKHdvdXRwdXQuZmllbGRzW3dpdGhLZXkuZmllbGRdKSB7XG4gICAgICAgIHdvdXRwdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciBwcmV2O1xuICAgICAgICAgIGlmKCF4Ll9wcmV2IHx8IChwcmV2ID0gd2l0aEtleS5hY2Nlc3Nvcih4Ll9wcmV2KSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBwcmV2bSA9IG1hcChwcmV2KTtcbiAgICAgICAgICBpZihwcmV2bVswXSkgcHJldm1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0gZGZsdCB9KTtcbiAgICAgICAgICBwcmV2bVsxXSA9IG51bGw7XG5cbiAgICAgICAgICB2YXIgbSA9IG1hcCh3aXRoS2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgICBpZihtWzBdKSBtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IHggfSk7XG4gICAgICAgICAgbVsxXSA9IHg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYXN0Sm9pbiA9IHdvdXRwdXQuc3RhbXA7XG4gICAgfVxuICBcbiAgICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgbSA9IG1hcChrZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgeFthc10gPSBtWzFdIHx8IGRmbHQ7XG4gICAgICAobVswXT1tWzBdfHxbXSkucHVzaCh4KTtcbiAgICB9KTtcblxuICAgIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgXG4gICAgICB2YXIgayA9IGtleS5hY2Nlc3Nvcih4KTtcbiAgICAgIChyZW1ba109cmVtW2tdfHx7fSlbeC5faWRdID0gMTtcbiAgICB9KTtcblxuICAgIGlmKGlucHV0LmZpZWxkc1trZXkuZmllbGRdKSB7XG4gICAgICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICBpZigheC5fcHJldiB8fCAocHJldiA9IGtleS5hY2Nlc3Nvcih4Ll9wcmV2KSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBtID0gbWFwKGtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgIHhbYXNdID0gbVsxXSB8fCBkZmx0O1xuICAgICAgICAobVswXT1tWzBdfHxbXSkucHVzaCh4KTtcbiAgICAgICAgKHJlbVtwcmV2XT1yZW1bcHJldl18fHt9KVt4Ll9pZF0gPSAxO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGwua2V5cyhyZW0pLmZvckVhY2goZnVuY3Rpb24oaykgeyBcbiAgICAgIHZhciBtID0gbWFwKGspO1xuICAgICAgaWYoIW1bMF0pIHJldHVybjtcbiAgICAgIG1bMF0gPSBtWzBdLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW1ba11beC5faWRdICE9PSAxIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBydW4gYSBub24ta2V5LWpvaW4gYWdhaW4gaWYgd2UndmUgZ290IGFueSBhZGQvcmVtXG4gICAgLy8gb24gaW5wdXQgb3Igd291dHB1dFxuICAgIGlmKGlucHV0LmFkZC5sZW5ndGggPT0gMCAmJiBpbnB1dC5yZW0ubGVuZ3RoID09IDAgJiYgXG4gICAgICAgIHdvdXRwdXQuYWRkLmxlbmd0aCA9PSAwICYmIHdvdXRwdXQucmVtLmxlbmd0aCA9PSAwKSByZXR1cm4gaW5wdXQ7XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEga2V5LWpvaW4sIHRoZW4gd2UgbmVlZCB0byBtYXRlcmlhbGl6ZSBib3RoXG4gICAgLy8gZGF0YSBzb3VyY2VzIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtLiBcbiAgICB0aGlzLl9jb2xsZWN0b3IuZXZhbHVhdGUoaW5wdXQpO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpLCBcbiAgICAgICAgd2xlbiA9IHdkYXRhLmxlbmd0aCwgaTtcblxuICAgIGZvcihpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsgZGF0YVtpXVthc10gPSB3ZGF0YVtpJXdsZW5dOyB9XG4gIH1cblxuICBpbnB1dC5maWVsZHNbYXNdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBaaXA7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFnZ3JlZ2F0ZTogIHJlcXVpcmUoJy4vQWdncmVnYXRlJyksXG4gIGJpbjogICAgICAgIHJlcXVpcmUoJy4vQmluJyksXG4gIGNyb3NzOiAgICAgIHJlcXVpcmUoJy4vQ3Jvc3MnKSxcbiAgbGlua3BhdGg6ICAgcmVxdWlyZSgnLi9MaW5rUGF0aCcpLFxuICBmYWNldDogICAgICByZXF1aXJlKCcuL0ZhY2V0JyksXG4gIGZpbHRlcjogICAgIHJlcXVpcmUoJy4vRmlsdGVyJyksXG4gIGZvbGQ6ICAgICAgIHJlcXVpcmUoJy4vRm9sZCcpLFxuICBmb3JjZTogICAgICByZXF1aXJlKCcuL0ZvcmNlJyksXG4gIGZvcm11bGE6ICAgIHJlcXVpcmUoJy4vRm9ybXVsYScpLFxuICBnZW86ICAgICAgICByZXF1aXJlKCcuL0dlbycpLFxuICBnZW9wYXRoOiAgICByZXF1aXJlKCcuL0dlb1BhdGgnKSxcbiAgcGllOiAgICAgICAgcmVxdWlyZSgnLi9QaWUnKSxcbiAgc29ydDogICAgICAgcmVxdWlyZSgnLi9Tb3J0JyksXG4gIHN0YWNrOiAgICAgIHJlcXVpcmUoJy4vU3RhY2snKSxcbiAgdHJlZW1hcDogICAgcmVxdWlyZSgnLi9UcmVlbWFwJyksXG4gIHVuaXF1ZTogICAgIHJlcXVpcmUoJy4vVW5pcXVlJyksXG4gIHppcDogICAgICAgIHJlcXVpcmUoJy4vWmlwJylcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvcXVpY2tzZWxlY3QnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIHR5cGVzID0ge1xuICBcImNvdW50XCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwiY291bnRcIixcbiAgICBpbml0OiBcIlwiLFxuICAgIGFkZDogIFwiXCIsXG4gICAgcmVtOiAgXCJcIixcbiAgICBzZXQ6ICBcInRoaXMuY2VsbC5jbnRcIlxuICB9KSxcbiAgXCJfY291bnRzXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwiX2NvdW50c1wiLFxuICAgIGluaXQ6IFwidGhpcy5jbnRzID0ge307XCIsXG4gICAgYWRkOiAgXCJ0aGlzLmNudHNbdl0gPSArK3RoaXMuY250c1t2XSB8fCAxO1wiLFxuICAgIHJlbTogIFwidGhpcy5jbnRzW3ZdID0gLS10aGlzLmNudHNbdl0gPCAwID8gMCA6IHRoaXMuY250c1t2XTtcIixcbiAgICBzZXQ6ICBcIlwiLFxuICAgIHJlcTogIFtcImNvdW50XCJdXG4gIH0pLFxuICBcInN1bVwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInN1bVwiLFxuICAgIGluaXQ6IFwidGhpcy5zdW0gPSAwO1wiLFxuICAgIGFkZDogIFwidGhpcy5zdW0gKz0gdjtcIixcbiAgICByZW06ICBcInRoaXMuc3VtIC09IHY7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLnN1bVwiXG4gIH0pLFxuICBcImF2Z1wiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcImF2Z1wiLFxuICAgIGluaXQ6IFwidGhpcy5hdmcgPSAwO1wiLFxuICAgIGFkZDogIFwidmFyIGQgPSB2IC0gdGhpcy5hdmc7IHRoaXMuYXZnICs9IGQgLyB0aGlzLmNlbGwuY250O1wiLFxuICAgIHJlbTogIFwidmFyIGQgPSB2IC0gdGhpcy5hdmc7IHRoaXMuYXZnIC09IGQgLyB0aGlzLmNlbGwuY250O1wiLFxuICAgIHNldDogIFwidGhpcy5hdmdcIixcbiAgICByZXE6ICBbXCJjb3VudFwiXSwgaWR4OiAxXG4gIH0pLFxuICBcInZhclwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInZhclwiLFxuICAgIGluaXQ6IFwidGhpcy5kZXYgPSAwO1wiLFxuICAgIGFkZDogIFwidGhpcy5kZXYgKz0gZCAqICh2IC0gdGhpcy5hdmcpO1wiLFxuICAgIHJlbTogIFwidGhpcy5kZXYgLT0gZCAqICh2IC0gdGhpcy5hdmcpO1wiLFxuICAgIHNldDogIFwidGhpcy5kZXYgLyAodGhpcy5jZWxsLmNudC0xKVwiLFxuICAgIHJlcTogIFtcImF2Z1wiXSwgaWR4OiAyXG4gIH0pLFxuICBcInZhcnBcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJ2YXJwXCIsXG4gICAgaW5pdDogXCJcIixcbiAgICBhZGQ6ICBcIlwiLFxuICAgIHJlbTogIFwiXCIsXG4gICAgc2V0OiAgXCJ0aGlzLmRldiAvIHRoaXMuY2VsbC5jbnRcIixcbiAgICByZXE6ICBbXCJ2YXJcIl0sIGlkeDogM1xuICB9KSxcbiAgXCJzdGRldlwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInN0ZGV2XCIsXG4gICAgaW5pdDogXCJcIixcbiAgICBhZGQ6ICBcIlwiLFxuICAgIHJlbTogIFwiXCIsXG4gICAgc2V0OiAgXCJNYXRoLnNxcnQodGhpcy5kZXYgLyAodGhpcy5jZWxsLmNudC0xKSlcIixcbiAgICByZXE6ICBbXCJ2YXJcIl0sIGlkeDogNFxuICB9KSxcbiAgXCJzdGRldnBcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJzdGRldnBcIixcbiAgICBpbml0OiBcIlwiLFxuICAgIGFkZDogIFwiXCIsXG4gICAgcmVtOiAgXCJcIixcbiAgICBzZXQ6ICBcIk1hdGguc3FydCh0aGlzLmRldiAvIHRoaXMuY2VsbC5jbnQpXCIsXG4gICAgcmVxOiAgW1widmFyXCJdLCBpZHg6IDVcbiAgfSksXG4gIFwibWluXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwibWluXCIsXG4gICAgaW5pdDogXCJ0aGlzLm1pbiA9ICtJbmZpbml0eTtcIixcbiAgICBhZGQ6ICBcInRoaXMubWluID0gdiA8IHRoaXMubWluID8gdiA6IHRoaXMubWluO1wiLFxuICAgIHJlbTogIFwidmFyIHNlbGYgPSB0aGlzOyB0aGlzLm1pbiA9IHYgPT0gdGhpcy5taW4gXCIgK1xuICAgICAgICAgIFwiPyB0aGlzLmtleXModGhpcy5jbnRzKS5yZWR1Y2UoZnVuY3Rpb24obSwgdikgeyBcIiArXG4gICAgICAgICAgXCIgICByZXR1cm4gc2VsZi5jbnRzWyh2ID0gK3YpXSA+IDAgJiYgdiA8IG0gPyB2IDogbSB9LCArSW5maW5pdHkpIFwiICsgXG4gICAgICAgICAgXCI6IHRoaXMubWluO1wiLFxuICAgIHNldDogIFwidGhpcy5taW5cIixcbiAgICByZXE6IFtcIl9jb3VudHNcIl0sIGlkeDogNlxuICB9KSxcbiAgXCJtYXhcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJtYXhcIixcbiAgICBpbml0OiBcInRoaXMubWF4ID0gLUluZmluaXR5O1wiLFxuICAgIGFkZDogIFwidGhpcy5tYXggPSB2ID4gdGhpcy5tYXggPyB2IDogdGhpcy5tYXg7XCIsXG4gICAgcmVtOiAgXCJ2YXIgc2VsZiA9IHRoaXM7IHRoaXMubWF4ID0gdiA9PSB0aGlzLm1heCBcIiArXG4gICAgICAgICAgXCI/IHRoaXMua2V5cyh0aGlzLmNudHMpLnJlZHVjZShmdW5jdGlvbihtLCB2KSB7IFwiICtcbiAgICAgICAgICBcIiAgIHJldHVybiBzZWxmLmNudHNbKHYgPSArdildID4gMCAmJiB2ID4gbSA/IHYgOiBtIH0sIC1JbmZpbml0eSkgXCIgKyBcbiAgICAgICAgICBcIjogdGhpcy5tYXg7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLm1heFwiLFxuICAgIHJlcTogW1wiX2NvdW50c1wiXSwgaWR4OiA3XG4gIH0pLFxuICBcIm1lZGlhblwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcIm1lZGlhblwiLFxuICAgIGluaXQ6IFwidGhpcy52YWxzID0gW107IFwiLFxuICAgIGFkZDogIFwiaWYodGhpcy52YWxzKSB0aGlzLnZhbHMucHVzaCh2KTsgXCIsXG4gICAgcmVtOiAgXCJ0aGlzLnZhbHMgPSBudWxsO1wiLFxuICAgIHNldDogIFwidGhpcy5jZWxsLmNudCAlIDIgPyB0aGlzLnNlbCh+fih0aGlzLmNlbGwuY250LzIpLCB0aGlzLnZhbHMsIHRoaXMuY250cykgOiBcIitcbiAgICAgICAgICBcIjAuNSAqICh0aGlzLnNlbCh+fih0aGlzLmNlbGwuY250LzIpLTEsIHRoaXMudmFscywgdGhpcy5jbnRzKSArIHRoaXMuc2VsKH5+KHRoaXMuY2VsbC5jbnQvMiksIHRoaXMudmFscywgdGhpcy5jbnRzKSlcIixcbiAgICByZXE6IFtcIl9jb3VudHNcIl0sIGlkeDogOFxuICB9KVxufTtcblxuZnVuY3Rpb24gbWVhc3VyZShiYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvdXQpIHtcbiAgICB2YXIgbSA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XG4gICAgbS5vdXQgPSBvdXQgfHwgYmFzZS5uYW1lO1xuICAgIGlmICghbS5pZHgpIG0uaWR4ID0gMDtcbiAgICByZXR1cm4gbTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShhZ2cpIHtcbiAgZnVuY3Rpb24gY29sbGVjdChtLCBhKSB7XG4gICAgKGEucmVxIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGlmICghbVtyXSkgY29sbGVjdChtLCBtW3JdID0gdHlwZXNbcl0oKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgdmFyIG1hcCA9IGFnZy5yZWR1Y2UoY29sbGVjdCxcbiAgICBhZ2cucmVkdWNlKGZ1bmN0aW9uKG0sIGEpIHsgcmV0dXJuIChtW2EubmFtZV0gPSBhLCBtKTsgfSwge30pKTtcbiAgdmFyIGFsbCA9IFtdO1xuICBmb3IgKHZhciBrIGluIG1hcCkgYWxsLnB1c2gobWFwW2tdKTtcbiAgYWxsLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhLmlkeCAtIGIuaWR4OyB9KTtcbiAgcmV0dXJuIGFsbDtcbn1cblxuZnVuY3Rpb24gY29tcGlsZShhZ2cpIHtcbiAgdmFyIGFsbCA9IHJlc29sdmUoYWdnKSxcbiAgICAgIGN0ciA9IFwidGhpcy50cGwgPSB0OyB0aGlzLmNlbGwgPSBjO1wiLFxuICAgICAgYWRkID0gXCJcIixcbiAgICAgIHJlbSA9IFwiXCIsXG4gICAgICBzZXQgPSBcInZhciB0ID0gdGhpcy50cGw7XCI7XG5cbiAgYWxsLmZvckVhY2goZnVuY3Rpb24oYSkgeyBjdHIgKz0gYS5pbml0OyBhZGQgKz0gYS5hZGQ7IHJlbSArPSBhLnJlbTsgfSk7XG4gIGFnZy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHsgc2V0ICs9IFwidGhpcy50dXBsZS5zZXQodCwnXCIrYS5vdXQrXCInLFwiK2Euc2V0K1wiKTtcIjsgfSk7XG4gIHNldCArPSBcInJldHVybiB0O1wiO1xuXG4gIGN0ciA9IEZ1bmN0aW9uKFwiY1wiLCBcInRcIiwgY3RyKTtcbiAgY3RyLnByb3RvdHlwZS5hZGQgPSBGdW5jdGlvbihcInZcIiwgYWRkKTtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSBGdW5jdGlvbihcInZcIiwgcmVtKTtcbiAgY3RyLnByb3RvdHlwZS5zZXQgPSBGdW5jdGlvbihcInN0YW1wXCIsIHNldCk7XG4gIGN0ci5wcm90b3R5cGUubW9kID0gbW9kO1xuICBjdHIucHJvdG90eXBlLmtleXMgPSBkbC5rZXlzO1xuICBjdHIucHJvdG90eXBlLnNlbCA9IHF1aWNrc2VsZWN0O1xuICBjdHIucHJvdG90eXBlLnR1cGxlID0gdHVwbGU7XG4gIHJldHVybiBjdHI7XG59XG5cbmZ1bmN0aW9uIG1vZCh2X25ldywgdl9vbGQpIHtcbiAgaWYgKHZfb2xkID09PSB1bmRlZmluZWQgfHwgdl9vbGQgPT09IHZfbmV3KSByZXR1cm47XG4gIHRoaXMucmVtKHZfb2xkKTtcbiAgdGhpcy5hZGQodl9uZXcpO1xufTtcblxudHlwZXMuY3JlYXRlICAgPSBjb21waWxlO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlczsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kcycpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvcGF0aCcpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBwYXJzZSA9IGNhbnZhcy5wYXJzZSxcbiAgICBib3VuZFBhdGggPSBjYW52YXMuYm91bmRzLFxuICAgIGFyZWFQYXRoID0gY2FudmFzLmFyZWEsXG4gICAgbGluZVBhdGggPSBjYW52YXMubGluZSxcbiAgICBoYWxmcGkgPSBNYXRoLlBJIC8gMixcbiAgICBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCksXG4gICAgZ2Z4ID0gbnVsbDtcblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG5mdW5jdGlvbiBjb250ZXh0KCkge1xuICAvLyBUT0RPOiBob3cgdG8gY2hlY2sgaWYgbm9kZUpTIGluIHJlcXVpcmVKUz9cbiAgcmV0dXJuIGdmeCB8fCAoZ2Z4ID0gKC8qY29uZmlnLmlzTm9kZVxuICAgID8gbmV3IChyZXF1aXJlKFwiY2FudmFzXCIpKSgxLDEpXG4gICAgOiAqL2QzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwiY2FudmFzXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ2ZWdhX2hpZGRlblwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIDEpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDEpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgIC5ub2RlKCkpXG4gICAgLmdldENvbnRleHQoXCIyZFwiKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhCb3VuZHMobywgcGF0aCwgYm91bmRzKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kUGF0aChwYXRoLCBib3VuZHMpO1xuICAgIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHBhdGgobywgYm91bmRzKSB7XG4gIHZhciBwID0gby5wYXRoXG4gICAgPyBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShvLnBhdGgpKVxuICAgIDogbnVsbDtcbiAgcmV0dXJuIHBhdGhCb3VuZHMobywgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gYXJlYShvLCBib3VuZHMpIHtcbiAgdmFyIGl0ZW1zID0gby5tYXJrLml0ZW1zLCBvID0gaXRlbXNbMF07XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2UoYXJlYVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW1zWzBdLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBsaW5lKG8sIGJvdW5kcykge1xuICB2YXIgaXRlbXMgPSBvLm1hcmsuaXRlbXMsIG8gPSBpdGVtc1swXTtcbiAgdmFyIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShsaW5lUGF0aChpdGVtcykpKTtcbiAgcmV0dXJuIHBhdGhCb3VuZHMoaXRlbXNbMF0sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIHJlY3QobywgYm91bmRzKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICB3ID0gKHggKyBvLndpZHRoKSB8fCAwLFxuICAgICAgaCA9ICh5ICsgby5oZWlnaHQpIHx8IDA7XG4gIGJvdW5kcy5zZXQoeCwgeSwgdywgaCk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8sIGJvdW5kcykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwLFxuICAgICAgeCA9IChvLnh8fDApIC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IChvLnl8fDApIC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKTtcbiAgcmV0dXJuIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xufVxuXG5mdW5jdGlvbiBydWxlKG8sIGJvdW5kcykge1xuICB2YXIgeDEsIHkxO1xuICBib3VuZHMuc2V0KFxuICAgIHgxID0gby54IHx8IDAsXG4gICAgeTEgPSBvLnkgfHwgMCxcbiAgICBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgby55MiAhPSBudWxsID8gby55MiA6IHkxXG4gICk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGFyYyhvLCBib3VuZHMpIHtcbiAgdmFyIGN4ID0gby54IHx8IDAsXG4gICAgICBjeSA9IG8ueSB8fCAwLFxuICAgICAgaXIgPSBvLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IG8ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIHNhID0gKG8uc3RhcnRBbmdsZSB8fCAwKSAtIGhhbGZwaSxcbiAgICAgIGVhID0gKG8uZW5kQW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICB4bWluID0gSW5maW5pdHksIHhtYXggPSAtSW5maW5pdHksXG4gICAgICB5bWluID0gSW5maW5pdHksIHltYXggPSAtSW5maW5pdHksXG4gICAgICBhLCBpLCBuLCB4LCB5LCBpeCwgaXksIG94LCBveTtcblxuICB2YXIgYW5nbGVzID0gW3NhLCBlYV0sXG4gICAgICBzID0gc2EgLSAoc2ElaGFsZnBpKTtcbiAgZm9yIChpPTA7IGk8NCAmJiBzPGVhOyArK2ksIHMrPWhhbGZwaSkge1xuICAgIGFuZ2xlcy5wdXNoKHMpO1xuICB9XG5cbiAgZm9yIChpPTAsIG49YW5nbGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBhID0gYW5nbGVzW2ldO1xuICAgIHggPSBNYXRoLmNvcyhhKTsgaXggPSBpcip4OyBveCA9IG9yKng7XG4gICAgeSA9IE1hdGguc2luKGEpOyBpeSA9IGlyKnk7IG95ID0gb3IqeTtcbiAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgaXgsIG94KTtcbiAgICB4bWF4ID0gTWF0aC5tYXgoeG1heCwgaXgsIG94KTtcbiAgICB5bWluID0gTWF0aC5taW4oeW1pbiwgaXksIG95KTtcbiAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgaXksIG95KTtcbiAgfVxuXG4gIGJvdW5kcy5zZXQoY3greG1pbiwgY3kreW1pbiwgY3greG1heCwgY3kreW1heCk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvLCBib3VuZHMpIHtcbiAgdmFyIHNpemUgPSBvLnNpemUgIT0gbnVsbCA/IG8uc2l6ZSA6IDEwMCxcbiAgICAgIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIHIsIHQsIHJ4LCByeTtcblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlIFwiY3Jvc3NcIjpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBib3VuZHMuc2V0KHgtdCwgeS1yLCB4K3QsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiB0YW4zMCkpO1xuICAgICAgcnggPSByeSAqIHRhbjMwO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yLCB5LXIsIHgrciwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLWRvd25cIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLXVwXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUvTWF0aC5QSSk7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gIH1cbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gdGV4dChvLCBib3VuZHMsIG5vUm90YXRlKSB7XG4gIHZhciB4ID0gKG8ueCB8fCAwKSArIChvLmR4IHx8IDApLFxuICAgICAgeSA9IChvLnkgfHwgMCkgKyAoby5keSB8fCAwKSxcbiAgICAgIGggPSBvLmZvbnRTaXplIHx8IGNvbmZpZy5yZW5kZXIuZm9udFNpemUsXG4gICAgICBhID0gby5hbGlnbixcbiAgICAgIGIgPSBvLmJhc2VsaW5lLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBnID0gY29udGV4dCgpLCB3LCB0O1xuXG4gIGcuZm9udCA9IGZvbnRTdHJpbmcobyk7XG4gIGcudGV4dEFsaWduID0gYSB8fCBcImxlZnRcIjtcbiAgZy50ZXh0QmFzZWxpbmUgPSBiIHx8IFwiYWxwaGFiZXRpY1wiO1xuICB3ID0gZy5tZWFzdXJlVGV4dChvLnRleHQgfHwgXCJcIikud2lkdGg7XG5cbiAgaWYgKHIpIHtcbiAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICAvLyBob3Jpem9udGFsXG4gIGlmIChhID09PSBcImNlbnRlclwiKSB7XG4gICAgeCA9IHggLSAodyAvIDIpO1xuICB9IGVsc2UgaWYgKGEgPT09IFwicmlnaHRcIikge1xuICAgIHggPSB4IC0gdztcbiAgfSBlbHNlIHtcbiAgICAvLyBsZWZ0IGJ5IGRlZmF1bHQsIGRvIG5vdGhpbmdcbiAgfVxuXG4gIC8vLyBUT0RPIGZpbmQgYSByb2J1c3Qgc29sdXRpb24gZm9yIGhlaWdodHMuXG4gIC8vLyBUaGVzZSBvZmZzZXRzIHdvcmsgZm9yIHNvbWUgYnV0IG5vdCBhbGwgZm9udHMuXG5cbiAgLy8gdmVydGljYWxcbiAgaWYgKGIgPT09IFwidG9wXCIpIHtcbiAgICB5ID0geSArIChoLzUpO1xuICB9IGVsc2UgaWYgKGIgPT09IFwiYm90dG9tXCIpIHtcbiAgICB5ID0geSAtIGg7XG4gIH0gZWxzZSBpZiAoYiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHkgPSB5IC0gKGgvMikgKyAoaC8xMCk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IHkgLSA0KmgvNTsgLy8gYWxwaGFiZXRpYyBieSBkZWZhdWx0XG4gIH1cbiAgXG4gIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xuICBpZiAoby5hbmdsZSAmJiAhbm9Sb3RhdGUpIHtcbiAgICBib3VuZHMucm90YXRlKG8uYW5nbGUqTWF0aC5QSS8xODAsIG8ueHx8MCwgby55fHwwKTtcbiAgfVxuICByZXR1cm4gYm91bmRzLmV4cGFuZChub1JvdGF0ZSA/IDAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAoZywgYm91bmRzLCBpbmNsdWRlTGVnZW5kcykge1xuICB2YXIgYXhlcyA9IGcuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgbGVnZW5kcyA9IGcubGVnZW5kSXRlbXMgfHwgW10sIGosIG07XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgYm91bmRzLnVuaW9uKGF4ZXNbal0uYm91bmRzKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1nLml0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBib3VuZHMudW5pb24oZy5pdGVtc1tqXS5ib3VuZHMpO1xuICB9XG4gIGlmIChpbmNsdWRlTGVnZW5kcykge1xuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgYm91bmRzLnVuaW9uKGxlZ2VuZHNbal0uYm91bmRzKTtcbiAgICB9XG4gICAgaWYgKGcud2lkdGggIT0gbnVsbCAmJiBnLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICBib3VuZHMuYWRkKGcud2lkdGgsIGcuaGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGcueCAhPSBudWxsICYmIGcueSAhPSBudWxsKSB7XG4gICAgICBib3VuZHMuYWRkKDAsIDApO1xuICAgIH1cbiAgfVxuICBib3VuZHMudHJhbnNsYXRlKGcueHx8MCwgZy55fHwwKTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxudmFyIG1ldGhvZHMgPSB7XG4gIGdyb3VwOiAgZ3JvdXAsXG4gIHN5bWJvbDogc3ltYm9sLFxuICBpbWFnZTogIGltYWdlLFxuICByZWN0OiAgIHJlY3QsXG4gIHJ1bGU6ICAgcnVsZSxcbiAgYXJjOiAgICBhcmMsXG4gIHRleHQ6ICAgdGV4dCxcbiAgcGF0aDogICBwYXRoLFxuICBhcmVhOiAgIGFyZWEsXG4gIGxpbmU6ICAgbGluZVxufTtcblxuZnVuY3Rpb24gaXRlbUJvdW5kcyhpdGVtLCBmdW5jLCBvcHQpIHtcbiAgZnVuYyA9IGZ1bmMgfHwgbWV0aG9kc1tpdGVtLm1hcmsubWFya3R5cGVdO1xuICBpZiAoIWl0ZW0uYm91bmRzX3ByZXYpIGl0ZW1bJ2JvdW5kczpwcmV2J10gPSBuZXcgQm91bmRzKCk7XG4gIHZhciBiID0gaXRlbS5ib3VuZHMsIHBiID0gaXRlbVsnYm91bmRzOnByZXYnXTtcbiAgaWYgKGIpIHBiLmNsZWFyKCkudW5pb24oYik7XG4gIGl0ZW0uYm91bmRzID0gZnVuYyhpdGVtLCBiID8gYi5jbGVhcigpIDogbmV3IEJvdW5kcygpLCBvcHQpO1xuICBpZiAoIWIpIHBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpO1xuICByZXR1cm4gaXRlbS5ib3VuZHM7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3VuZHMobWFyaywgYm91bmRzLCBvcHQpIHtcbiAgYm91bmRzID0gYm91bmRzIHx8IG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNsZWFyKCkgfHwgbmV3IEJvdW5kcygpO1xuICB2YXIgdHlwZSAgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgZnVuYyAgPSBtZXRob2RzW3R5cGVdLFxuICAgICAgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaXRlbSwgaSwgbGVuO1xuICAgICAgXG4gIGlmICh0eXBlPT09XCJhcmVhXCIgfHwgdHlwZT09PVwibGluZVwiKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgaXRlbXNbMF0uYm91bmRzID0gZnVuYyhpdGVtc1swXSwgYm91bmRzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGJvdW5kcy51bmlvbihpdGVtQm91bmRzKGl0ZW1zW2ldLCBmdW5jLCBvcHQpKTtcbiAgICB9XG4gIH1cbiAgbWFyay5ib3VuZHMgPSBib3VuZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXJrOiAgbWFya0JvdW5kcyxcbiAgaXRlbTogIGl0ZW1Cb3VuZHMsXG4gIHRleHQ6ICB0ZXh0LFxuICBncm91cDogZ3JvdXBcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgY29uZmlnID0ge307XG5cbmNvbmZpZy5kZWJ1ZyA9IGZhbHNlO1xuXG5jb25maWcubG9hZCA9IHtcbiAgLy8gYmFzZSB1cmwgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZGF0YSBmaWxlc1xuICAvLyB1c2VkIG9ubHkgZm9yIHNlcnZlci1zaWRlIG9wZXJhdGlvblxuICBiYXNlVVJMOiBcIlwiLFxuICAvLyBBbGxvd3MgZG9tYWluIHJlc3RyaWN0aW9uIHdoZW4gdXNpbmcgZGF0YSBsb2FkaW5nIHZpYSBYSFIuXG4gIC8vIFRvIGVuYWJsZSwgc2V0IGl0IHRvIGEgbGlzdCBvZiBhbGxvd2VkIGRvbWFpbnNcbiAgLy8gZS5nLiwgWyd3aWtpcGVkaWEub3JnJywgJ2VmZi5vcmcnXVxuICBkb21haW5XaGl0ZUxpc3Q6IGZhbHNlXG59O1xuXG4vLyB2ZXJzaW9uIGFuZCBuYW1lcHNhY2VzIGZvciBleHBvcnRlZCBzdmdcbmNvbmZpZy5zdmdOYW1lc3BhY2UgPVxuICAndmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICtcbiAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJztcblxuLy8gaW5zZXQgcGFkZGluZyBmb3IgYXV0b21hdGljIHBhZGRpbmcgY2FsY3VsYXRpb25cbmNvbmZpZy5hdXRvcGFkSW5zZXQgPSA1O1xuXG4vLyBleHRlbnNpYmxlIHNjYWxlIGxvb2t1cCB0YWJsZVxuLy8gYWxsIGQzLnNjYWxlLiogaW5zdGFuY2VzIGFsc28gc3VwcG9ydGVkXG5jb25maWcuc2NhbGUgPSB7XG4gIHRpbWU6IGQzLnRpbWUuc2NhbGUsXG4gIHV0YzogIGQzLnRpbWUuc2NhbGUudXRjXG59O1xuXG4vLyBkZWZhdWx0IHJlbmRlcmluZyBzZXR0aW5nc1xuY29uZmlnLnJlbmRlciA9IHtcbiAgbGluZVdpZHRoOiAxLFxuICBsaW5lQ2FwOiAgIFwiYnV0dFwiLFxuICBmb250OiAgICAgIFwic2Fucy1zZXJpZlwiLFxuICBmb250U2l6ZTogIDExXG59O1xuXG4vLyBkZWZhdWx0IGF4aXMgcHJvcGVydGllc1xuY29uZmlnLmF4aXMgPSB7XG4gIG9yaWVudDogXCJib3R0b21cIixcbiAgdGlja3M6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBheGlzQ29sb3I6IFwiIzAwMFwiLFxuICBncmlkQ29sb3I6IFwiI2Q4ZDhkOFwiLFxuICB0aWNrQ29sb3I6IFwiIzAwMFwiLFxuICB0aWNrTGFiZWxDb2xvcjogXCIjMDAwXCIsXG4gIGF4aXNXaWR0aDogMSxcbiAgdGlja1dpZHRoOiAxLFxuICB0aWNrU2l6ZTogNixcbiAgdGlja0xhYmVsRm9udFNpemU6IDExLFxuICB0aWNrTGFiZWxGb250OiBcInNhbnMtc2VyaWZcIixcbiAgdGl0bGVDb2xvcjogXCIjMDAwXCIsXG4gIHRpdGxlRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIHRpdGxlRm9udFNpemU6IDExLFxuICB0aXRsZUZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICB0aXRsZU9mZnNldDogMzVcbn07XG5cbi8vIGRlZmF1bHQgbGVnZW5kIHByb3BlcnRpZXNcbmNvbmZpZy5sZWdlbmQgPSB7XG4gIG9yaWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBncmFkaWVudFN0cm9rZUNvbG9yOiBcIiM4ODhcIixcbiAgZ3JhZGllbnRTdHJva2VXaWR0aDogMSxcbiAgZ3JhZGllbnRIZWlnaHQ6IDE2LFxuICBncmFkaWVudFdpZHRoOiAxMDAsXG4gIGxhYmVsQ29sb3I6IFwiIzAwMFwiLFxuICBsYWJlbEZvbnRTaXplOiAxMCxcbiAgbGFiZWxGb250OiBcInNhbnMtc2VyaWZcIixcbiAgbGFiZWxBbGlnbjogXCJsZWZ0XCIsXG4gIGxhYmVsQmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gIGxhYmVsT2Zmc2V0OiA4LFxuICBzeW1ib2xTaGFwZTogXCJjaXJjbGVcIixcbiAgc3ltYm9sU2l6ZTogNTAsXG4gIHN5bWJvbENvbG9yOiBcIiM4ODhcIixcbiAgc3ltYm9sU3Ryb2tlV2lkdGg6IDEsXG4gIHRpdGxlQ29sb3I6IFwiIzAwMFwiLFxuICB0aXRsZUZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiBcImJvbGRcIlxufTtcblxuLy8gZGVmYXVsdCBjb2xvciB2YWx1ZXNcbmNvbmZpZy5jb2xvciA9IHtcbiAgcmdiOiBbMTI4LCAxMjgsIDEyOF0sXG4gIGxhYjogWzUwLCAwLCAwXSxcbiAgaGNsOiBbMCwgMCwgNTBdLFxuICBoc2w6IFswLCAwLCAwLjVdXG59O1xuXG4vLyBkZWZhdWx0IHNjYWxlIHJhbmdlc1xuY29uZmlnLnJhbmdlID0ge1xuICBjYXRlZ29yeTEwOiBbXG4gICAgXCIjMWY3N2I0XCIsXG4gICAgXCIjZmY3ZjBlXCIsXG4gICAgXCIjMmNhMDJjXCIsXG4gICAgXCIjZDYyNzI4XCIsXG4gICAgXCIjOTQ2N2JkXCIsXG4gICAgXCIjOGM1NjRiXCIsXG4gICAgXCIjZTM3N2MyXCIsXG4gICAgXCIjN2Y3ZjdmXCIsXG4gICAgXCIjYmNiZDIyXCIsXG4gICAgXCIjMTdiZWNmXCJcbiAgXSxcbiAgY2F0ZWdvcnkyMDogW1xuICAgIFwiIzFmNzdiNFwiLFxuICAgIFwiI2FlYzdlOFwiLFxuICAgIFwiI2ZmN2YwZVwiLFxuICAgIFwiI2ZmYmI3OFwiLFxuICAgIFwiIzJjYTAyY1wiLFxuICAgIFwiIzk4ZGY4YVwiLFxuICAgIFwiI2Q2MjcyOFwiLFxuICAgIFwiI2ZmOTg5NlwiLFxuICAgIFwiIzk0NjdiZFwiLFxuICAgIFwiI2M1YjBkNVwiLFxuICAgIFwiIzhjNTY0YlwiLFxuICAgIFwiI2M0OWM5NFwiLFxuICAgIFwiI2UzNzdjMlwiLFxuICAgIFwiI2Y3YjZkMlwiLFxuICAgIFwiIzdmN2Y3ZlwiLFxuICAgIFwiI2M3YzdjN1wiLFxuICAgIFwiI2JjYmQyMlwiLFxuICAgIFwiI2RiZGI4ZFwiLFxuICAgIFwiIzE3YmVjZlwiLFxuICAgIFwiIzllZGFlNVwiXG4gIF0sXG4gIHNoYXBlczogW1xuICAgIFwiY2lyY2xlXCIsXG4gICAgXCJjcm9zc1wiLFxuICAgIFwiZGlhbW9uZFwiLFxuICAgIFwic3F1YXJlXCIsXG4gICAgXCJ0cmlhbmdsZS1kb3duXCIsXG4gICAgXCJ0cmlhbmdsZS11cFwiXG4gIF1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBRERfQ0VMTDogMSxcbiAgTU9EX0NFTEw6IDIsXG5cbiAgREFUQTogXCJkYXRhXCIsXG4gIEZJRUxEUzogIFwiZmllbGRzXCIsXG4gIFNDQUxFUzogIFwic2NhbGVzXCIsXG4gIFNJR05BTDogIFwic2lnbmFsXCIsXG4gIFNJR05BTFM6IFwic2lnbmFsc1wiLFxuXG4gIEdST1VQOiBcImdyb3VwXCIsXG5cbiAgRU5URVI6IFwiZW50ZXJcIixcbiAgVVBEQVRFOiBcInVwZGF0ZVwiLFxuICBFWElUOiBcImV4aXRcIixcblxuICBTRU5USU5FTDoge1wic2VudGluZWxcIjogMX0sXG4gIFNJTkdMRVRPTjogXCJfc2luZ2xldG9uXCIsXG5cbiAgQUREOiBcImFkZFwiLFxuICBSRU1PVkU6IFwicmVtb3ZlXCIsXG4gIFRPR0dMRTogXCJ0b2dnbGVcIixcbiAgQ0xFQVI6IFwiY2xlYXJcIixcblxuICBMSU5FQVI6IFwibGluZWFyXCIsXG4gIE9SRElOQUw6IFwib3JkaW5hbFwiLFxuICBMT0c6IFwibG9nXCIsXG4gIFBPV0VSOiBcInBvd1wiLFxuICBUSU1FOiBcInRpbWVcIixcbiAgUVVBTlRJTEU6IFwicXVhbnRpbGVcIixcblxuICBET01BSU46IFwiZG9tYWluXCIsXG4gIFJBTkdFOiBcInJhbmdlXCIsXG5cbiAgTUFSSzogXCJtYXJrXCIsXG4gIEFYSVM6IFwiYXhpc1wiLFxuXG4gIENPVU5UOiBcImNvdW50XCIsXG4gIE1JTjogXCJtaW5cIixcbiAgTUFYOiBcIm1heFwiLFxuXG4gIEFTQzogXCJhc2NcIixcbiAgREVTQzogXCJkZXNjXCJcbn07IiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgdHM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5wdXQsIGFyZ3MpIHtcbiAgaWYgKCFjb25maWcuZGVidWcpIHJldHVybjtcbiAgdmFyIGxvZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICBhcmdzLnVuc2hpZnQoaW5wdXQuc3RhbXB8fC0xKTtcbiAgYXJncy51bnNoaWZ0KERhdGUubm93KCkgLSB0cyk7XG4gIGlmKGlucHV0LmFkZCkgYXJncy5wdXNoKGlucHV0LmFkZC5sZW5ndGgsIGlucHV0Lm1vZC5sZW5ndGgsIGlucHV0LnJlbS5sZW5ndGgsICEhaW5wdXQucmVmbG93KTtcbiAgbG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB0cyA9IERhdGUubm93KCk7XG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBxdWlja3NlbGVjdChrLCB4LCBjKSB7XG4gIGZ1bmN0aW9uIHN3YXAoYSwgYikge1xuICAgIHZhciB0ID0geFthXTtcbiAgICB4W2FdID0geFtiXTtcbiAgICB4W2JdID0gdDtcbiAgfVxuXG4gIC8vIHggbWF5IGJlIG51bGwsIGluIHdoaWNoIGNhc2UgYXNzZW1ibGUgYW4gYXJyYXkgZnJvbSBjIChjb3VudHMpXG4gIGlmKHggPT09IG51bGwpIHtcbiAgICB4ID0gW107XG4gICAgZGwua2V5cyhjKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBpID0gMCwgbGVuID0gY1trXTtcbiAgICAgIGsgPSArayB8fCBrO1xuICAgICAgZm9yKDsgaTxsZW47ICsraSkgeC5wdXNoKGspO1xuICAgIH0pO1xuICB9XG4gIFxuICB2YXIgbGVmdCA9IDAsXG4gICAgICByaWdodCA9IHgubGVuZ3RoIC0gMSxcbiAgICAgIHBvcywgaSwgcGl2b3Q7XG4gIFxuICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgcGl2b3QgPSB4W2tdO1xuICAgIHN3YXAoaywgcmlnaHQpO1xuICAgIGZvciAoaSA9IHBvcyA9IGxlZnQ7IGkgPCByaWdodDsgKytpKSB7XG4gICAgICBpZiAoeFtpXSA8IHBpdm90KSB7IHN3YXAoaSwgcG9zKyspOyB9XG4gICAgfVxuICAgIHN3YXAocmlnaHQsIHBvcyk7XG4gICAgaWYgKHBvcyA9PT0gaykgYnJlYWs7XG4gICAgaWYgKHBvcyA8IGspIGxlZnQgPSBwb3MgKyAxO1xuICAgIGVsc2UgcmlnaHQgPSBwb3MgLSAxO1xuICB9XG4gIHJldHVybiB4W2tdO1xufTsiXX0=\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('./util');\nvar units = require('./date-units');\nvar EPSILON = 1e-15;\n\nfunction bin(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, logb, level, minstep, precision, v, i, eps;\n\n  if (opt.step != null) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n};\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbin.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin);\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      bins = bin({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  bins.unit = unit;\n  bins.index = date_index;\n  if (!opt.raw) bins.value = date_value;\n  return bins;\n};\n\nmodule.exports = bin;\n","var util = require('./util');\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nvar entries = [\n  {\n    type: \"second\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M:%S.%L\",\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: \"minute\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M\",\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: \"hour\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:00\",\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: \"day\",\n    minstep: 1,\n    step: [1, 7],\n    format: \"%Y %b %-d\",\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: \"month\",\n    minstep: 1,\n    step: [1, 3, 6],\n    format: \"%b %Y\",\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (util.isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: \"year\",\n    minstep: 1,\n    format: \"%Y\",\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (util.isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: \"minuteOfHour\",\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: \"%M\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: \"hourOfDay\",\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: \"%H\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: \"dayOfWeek\",\n  min: 0,\n  max: 6,\n  step: [1],\n  format: \"%a\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: \"dayOfMonth\",\n  min: 1,\n  max: 31,\n  step: [1],\n  format: \"%-d\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: \"monthOfYear\",\n  min: 0,\n  max: 11,\n  step: [1],\n  format: \"%b\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  \"second\":       entries[0],\n  \"minute\":       entries[1],\n  \"hour\":         entries[2],\n  \"day\":          entries[3],\n  \"month\":        entries[4],\n  \"year\":         entries[5],\n  \"minuteOfHour\": minuteOfHour,\n  \"hourOfDay\":    hourOfDay,\n  \"dayOfWeek\":    dayOfWeek,\n  \"dayOfMonth\":   dayOfMonth,\n  \"monthOfYear\":  monthOfYear,\n  \"timesteps\":    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tvar d = max - min;\n\tvar f = function() {\n\t\treturn min + d * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n  var d = b - a;\n\tvar f = function() {\n\t\treturn a + Math.floor(d * Math.random());\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};","var stats = require('./stats');\nvar util = require('./util');\nvar bin = require('./bin');\nvar gen = require('./generate');\n\nmodule.exports = function(values, f, options) {\n  if (options === undefined && !util.isFunction(f)) { options = f; f = null; }\n\n  var type = options && options.type || infer(values, f);\n  if (type !== 'number' && type !== 'date' && type !== 'integer') {\n    return categorical(values, f, options && options.sort);\n  }\n\n  var ext = stats.extent(values, f),\n      opt = util.extend({min: ext[0], max: ext[1]}, options);\n  if (type === 'integer' && opt.minstep == null) opt.minstep = 1;\n  var b = type === 'date' ? bin.date(opt) : bin(opt);\n  return numerical(values, f, b);\n};\n\nfunction infer(values, f) {\n  var v = null, i;\n\n  // if data array has type annotations, use them\n  if (values.types) {\n    v = f(values.types);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0; !util.isNotNull(v) && i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n  return util.isDate(v) ? 'date' : util.isNumber(v) ? 'number' : 'string';\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var c = stats.unique(values, f).counts;\n  return util.keys(c)\n    .map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? \"-count\" : \"+value\"));\n}","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.csv.parse(data ? data.toString() : data);\n  return d;\n};\n","module.exports = {\n  json: require('./json'),\n  csv: require('./csv'),\n  tsv: require('./tsv'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data)\n    ? data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error(\"TopoJSON library not loaded.\"); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if (obj = t.objects[format.feature]) {\n      return topojson.feature(t, obj).features\n    } else {\n      throw Error(\"Invalid TopoJSON object: \"+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if (obj = t.objects[format.mesh]) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error(\"Invalid TopoJSON object: \" + format.mesh);\n    }\n  } else {\n    throw Error(\"Missing TopoJSON feature or mesh parameter.\");\n  }\n\n  return [];\n};\n","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || \"children\";\n  var table = [];\n  \n  function visit(node, parent) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.tsv.parse(data ? data.toString() : data);\n  return d;\n};\n","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host == \"\") {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function (d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; };\n  \n  try {\n    var url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== \"text\"\n      ? request.response // null on error\n      : request.responseText; // \"\" on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest;\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest\n      && !(\"withCredentials\" in request)\n      && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest;\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    \"onload\" in request\n      ? request.onload = request.onerror = respond\n      : request.onreadystatechange = function() { request.readyState > 3 && respond(); };\n  }\n  \n  request.open(\"GET\", url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(file, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(file, 'utf8');\n  }\n  require('fs').readFile(file, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) opt = {url: opt};\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\nvar formats = require('./formats');\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  util.identity\n};\n\nvar TESTS = {\n  boolean: function(x) { return x===\"true\" || x===\"false\" || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction read(data, format) {\n  var type = (format && format.type) || \"json\";\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction infer_type(values, f) {\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isNotNull(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction infer_types(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer_type(data, util.accessor(f));\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? infer_types(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return PARSERS[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  data.types = types;\n}\n\nread.type = infer_type;\nread.types = infer_types;\nread.formats = formats;\nread.parse = parse;\nmodule.exports = read;\n","var util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  bin:       require('./bin'),\n  histogram: require('./histogram'),\n  summary:   require('./summary'),\n  template:  require('./template'),\n  dateunits: require('./date-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/loaders'));\n\nmodule.exports = dl;","var util = require('./util');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Count the number of non-null values.\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Count the number of null or undefined values.\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error(\"Array lengths must match.\");\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!isNaN(v)) sum += v;\n    }\n  } else {  \n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  var a = values.map(function(v, i) {\n      return {\n        idx: i,\n        val: (f ? f(v) : v)\n      };\n    })\n    .sort(util.comparator(\"val\"));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(b) : a,\n  a = fn ? values.map(a) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(a) : values,\n      Y = b ? values.map(b) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      n = values.length, s = 0, d, i;\n\n  if (e === 2 || e === undefined) {\n    for (i=0; i<n; ++i) {\n      d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n      s += d*d;\n    }\n    return Math.sqrt(s); \n  } else {\n    for (i=0; i<n; ++i) {\n      d = Math.abs(f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]));\n      s += Math.pow(d, e);\n    }\n    return Math.pow(s, 1/e);\n  }\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  var i, p, s = 0, H = 0, N = counts.length;\n  for (i=0; i<N; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<N; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\n// Compute the normalized Shannon entropy (log base 2) of an array of counts.\nstats.entropy.normalized = function(counts, f) {\n  var H = stats.entropy(counts, f);\n  return H===0 ? 0 : H * Math.LN2 / Math.log(counts.length);\n};\n\n// Compute the mutual information between two discrete variables.\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.entropy.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(a) : values,\n      y = counts ? values.map(b) : a,\n      z = counts ? values.map(counts) : b;\n\n  var px = {},\n\t    py = {},\n\t    i, xx, yy, zz, s = 0, t, N = z.length, p, I = 0;\n\n\tfor (i=0; i<N; ++i) {\n\t  px[x[i]] = 0;\n\t  py[y[i]] = 0;\n  }\n\n\tfor (i=0; i<N; ++i) {\n\t\tpx[x[i]] += z[i];\n\t\tpy[y[i]] += z[i];\n\t\ts += z[i];\n\t}\n\n\tt = 1 / (s * Math.LN2);\n\tfor (i=0; i<N; ++i) {\n\t\tif (z[i] === 0) continue;\n\t\tp = (s * z[i]) / (px[x[i]] * py[y[i]]);\n\t\tI += z[i] * t * Math.log(p);\n\t}\n\n\treturn I;\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half, h, h2;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (util.isNotNull(v)) {\n      // update min/max\n      if (min===null || v < min) min = v;\n      if (max===null || v > max) max = v;\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\n    iqr:      [stats.quantile(vals, 0.25), stats.quantile(vals, 0.75)]\n  };\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar stats = require('./stats');\n\n// Compute profiles for all variables in a data set.\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"modeskew: \" + p.modeskew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate\n};\n\nfunction template(text) {\n  var src = source(text, \"d\");\n  src = \"var __t; return \" + src + \";\";\n\n  try {\n    return (new Function(\"d\", src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || \"obj\";\n  var index = 0;\n  var src = \"'\";\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += \"'\\n+((__t=(\"\n        + template_var(interpolate, variable)\n        + \"))==null?'':__t)+\\n'\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + \"'\";\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var format = [];\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || \"\";\n    if (stringCast) {\n      stringCast = false;\n      src = \"String(\" + src + \")\" + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  var src = util.field(prop).map(util.str).join(\"][\");\n  src = variable + \"[\" + src + \"]\";\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a\n          + (args.length > 1 ? ',' + util.number(args[1]) : '')\n          + ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!==\"left\" && b!==\"middle\" && b!==\"center\") ? \"right\" : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\"' + b + '\")';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      default:\n        throw Error(\"Unrecognized template filter: \" + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === \"'\" && pattern[pattern.length-1] === \"'\") ||\n      (pattern[0] !== '\"' && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error(\"Format pattern must be quoted: \" + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n","var Buffer = require('buffer').Buffer;\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null && (typeof obj !== 'number' ? true : !isNaN(obj));\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.false = function() { return false; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : \"…\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","var bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;","var dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n","var Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io = canvas;\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\nprototype.data = function(data) {\n  var m = this.model();\n  if (!arguments.length) return m.data();\n  dl.keys(data).forEach(function(d) { m.data(d).add(dl.duplicate(data[d])); });\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  // TODO: with streaming data API, adds should dl.duplicate just parseSpec\n  // to prevent Vega from polluting the environment.\n\n  var cs = changeset.create();\n  if(trans) cs.trans = trans;\n  if(opt.reflow !== undefined) cs.reflow = opt.reflow\n\n  if(!v._build) {\n    v._renderNode = new Node(v._model)\n      .router(true);\n\n    v._renderNode.evaluate = function(input) {\n      debug(input, [\"rendering\"]);\n\n      var s = v._model.scene();\n      if(input.trans) {\n        input.trans.start(function(items) { v._renderer.render(s, items); });\n      } else {\n        v._renderer.render(s);\n      }\n\n      // For all updated datasources, finalize their changesets.\n      var d, ds;\n      for(d in input.data) {\n        ds = v._model.data(d);\n        if(!ds.revises()) continue;\n        changeset.finalize(ds.last());\n      }\n\n      return input;\n    };\n\n    v._model.scene(v._renderNode);\n    v._build = true;\n  }\n\n  // Pulse the entire model (Datasources + scene).\n  v._model.fire(cs);\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n","var Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.add = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.add(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;","var dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(name) {\n  var graph = this;\n  if(!arguments.length) name = dl.keys(this._signals);\n  if(!dl.isArray(name)) return this._signals[name].value();\n  return name.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;","var dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;","var Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nmodule.exports = Signal;","var C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};","var dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};","var dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};","module.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};","var datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;","var dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n","/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};","var dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;","var dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};","var parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}","var dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}","var dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;","var expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};","var dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;","module.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};","var Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n","module.exports = {\n  Renderer: require('./Renderer')\n};\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n","var dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};","var Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;","var Node = require('../dataflow/Node'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db, i, len, item;\n\n  db = graph.data().reduce(function(db, ds) { \n    return (db[ds.name()] = ds.values(), db);\n  }, {});\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg);\n    if(exit)   encode.call(this, exit,   item, input.trans), db, sg; \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg);\n    if(update) encode.call(this, update, item, input.trans, db, sg);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, this._graph.predicates());\n}\n\n// If update property set uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n  return Node.prototype.reevaluate.call(this, pulse) || (update ? update.reflow : false);\n};\n\nmodule.exports = Encoder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;","var tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bin({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;","var Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;","var Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;","var dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;","var Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;","module.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};","var dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;","module.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};","var config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};","var dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};"],"sourceRoot":"/source/"}